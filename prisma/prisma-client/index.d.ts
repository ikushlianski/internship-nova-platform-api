
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model UserApplicationPreferences
 * 
 */
export type UserApplicationPreferences = $Result.DefaultSelection<Prisma.$UserApplicationPreferencesPayload>
/**
 * Model Application
 * 
 */
export type Application = $Result.DefaultSelection<Prisma.$ApplicationPayload>
/**
 * Model DataRemovalRequest
 * 
 */
export type DataRemovalRequest = $Result.DefaultSelection<Prisma.$DataRemovalRequestPayload>
/**
 * Model MeetingKind
 * 
 */
export type MeetingKind = $Result.DefaultSelection<Prisma.$MeetingKindPayload>
/**
 * Model CourseStructure
 * 
 */
export type CourseStructure = $Result.DefaultSelection<Prisma.$CourseStructurePayload>
/**
 * Model Class
 * Instance of a course
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model ClassCall
 * 
 */
export type ClassCall = $Result.DefaultSelection<Prisma.$ClassCallPayload>
/**
 * Model ClassSize
 * 
 */
export type ClassSize = $Result.DefaultSelection<Prisma.$ClassSizePayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model CourseAdvice
 * 
 */
export type CourseAdvice = $Result.DefaultSelection<Prisma.$CourseAdvicePayload>
/**
 * Model CourseTask
 * 
 */
export type CourseTask = $Result.DefaultSelection<Prisma.$CourseTaskPayload>
/**
 * Model CourseLevel
 * 
 */
export type CourseLevel = $Result.DefaultSelection<Prisma.$CourseLevelPayload>
/**
 * Model Subject
 * 
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model CourseLevelsPerSubject
 * 
 */
export type CourseLevelsPerSubject = $Result.DefaultSelection<Prisma.$CourseLevelsPerSubjectPayload>
/**
 * Model Lesson
 * 
 */
export type Lesson = $Result.DefaultSelection<Prisma.$LessonPayload>
/**
 * Model Mentor
 * 
 */
export type Mentor = $Result.DefaultSelection<Prisma.$MentorPayload>
/**
 * Model MentorsClasses
 * 
 */
export type MentorsClasses = $Result.DefaultSelection<Prisma.$MentorsClassesPayload>
/**
 * Model MentorPayModel
 * 
 */
export type MentorPayModel = $Result.DefaultSelection<Prisma.$MentorPayModelPayload>
/**
 * Model Module
 * 
 */
export type Module = $Result.DefaultSelection<Prisma.$ModulePayload>
/**
 * Model Section
 * 
 */
export type Section = $Result.DefaultSelection<Prisma.$SectionPayload>
/**
 * Model TimeOfDay
 * 
 */
export type TimeOfDay = $Result.DefaultSelection<Prisma.$TimeOfDayPayload>
/**
 * Model TuitionLang
 * 
 */
export type TuitionLang = $Result.DefaultSelection<Prisma.$TuitionLangPayload>
/**
 * Model Deck
 * 
 */
export type Deck = $Result.DefaultSelection<Prisma.$DeckPayload>
/**
 * Model LessonCard
 * 
 */
export type LessonCard = $Result.DefaultSelection<Prisma.$LessonCardPayload>
/**
 * Model UserCard
 * 
 */
export type UserCard = $Result.DefaultSelection<Prisma.$UserCardPayload>
/**
 * Model Vocabulary
 * 
 */
export type Vocabulary = $Result.DefaultSelection<Prisma.$VocabularyPayload>
/**
 * Model VocabularyInbox
 * 
 */
export type VocabularyInbox = $Result.DefaultSelection<Prisma.$VocabularyInboxPayload>
/**
 * Model BookingRequest
 * 
 */
export type BookingRequest = $Result.DefaultSelection<Prisma.$BookingRequestPayload>
/**
 * Model ClassTask
 * 
 */
export type ClassTask = $Result.DefaultSelection<Prisma.$ClassTaskPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model StudentAnswer
 * 
 */
export type StudentAnswer = $Result.DefaultSelection<Prisma.$StudentAnswerPayload>
/**
 * Model StudentTask
 * 
 */
export type StudentTask = $Result.DefaultSelection<Prisma.$StudentTaskPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TaskForm
 * e.g. Quiz, blank-filling, Discussion
 */
export type TaskForm = $Result.DefaultSelection<Prisma.$TaskFormPayload>
/**
 * Model TaskContext
 * Where the task is done: during live lesson, homework, self-study etc
 */
export type TaskContext = $Result.DefaultSelection<Prisma.$TaskContextPayload>
/**
 * Model TaskOption
 * 
 */
export type TaskOption = $Result.DefaultSelection<Prisma.$TaskOptionPayload>
/**
 * Model TaskType
 * e.g. Speaking, Reading, Vocabulary elicitation, Listening Comprehension, etc
 */
export type TaskType = $Result.DefaultSelection<Prisma.$TaskTypePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const DataRemovalStatusEnum: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type DataRemovalStatusEnum = (typeof DataRemovalStatusEnum)[keyof typeof DataRemovalStatusEnum]


export const ClassSizesEnum: {
  INDIVIDUAL: 'INDIVIDUAL',
  GROUP_2_4: 'GROUP_2_4',
  GROUP_5_8: 'GROUP_5_8',
  GROUP_9_12: 'GROUP_9_12'
};

export type ClassSizesEnum = (typeof ClassSizesEnum)[keyof typeof ClassSizesEnum]


export const BookingRequestStatus: {
  PENDING: 'PENDING',
  NEGOITIATING: 'NEGOITIATING',
  ASSIGNED: 'ASSIGNED',
  REJECTED: 'REJECTED',
  LOST: 'LOST'
};

export type BookingRequestStatus = (typeof BookingRequestStatus)[keyof typeof BookingRequestStatus]


export const StudentTaskStatus: {
  PENDING: 'PENDING',
  BLOCKED: 'BLOCKED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED'
};

export type StudentTaskStatus = (typeof StudentTaskStatus)[keyof typeof StudentTaskStatus]

}

export type DataRemovalStatusEnum = $Enums.DataRemovalStatusEnum

export const DataRemovalStatusEnum: typeof $Enums.DataRemovalStatusEnum

export type ClassSizesEnum = $Enums.ClassSizesEnum

export const ClassSizesEnum: typeof $Enums.ClassSizesEnum

export type BookingRequestStatus = $Enums.BookingRequestStatus

export const BookingRequestStatus: typeof $Enums.BookingRequestStatus

export type StudentTaskStatus = $Enums.StudentTaskStatus

export const StudentTaskStatus: typeof $Enums.StudentTaskStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs>;

  /**
   * `prisma.userApplicationPreferences`: Exposes CRUD operations for the **UserApplicationPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserApplicationPreferences
    * const userApplicationPreferences = await prisma.userApplicationPreferences.findMany()
    * ```
    */
  get userApplicationPreferences(): Prisma.UserApplicationPreferencesDelegate<ExtArgs>;

  /**
   * `prisma.application`: Exposes CRUD operations for the **Application** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applications
    * const applications = await prisma.application.findMany()
    * ```
    */
  get application(): Prisma.ApplicationDelegate<ExtArgs>;

  /**
   * `prisma.dataRemovalRequest`: Exposes CRUD operations for the **DataRemovalRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataRemovalRequests
    * const dataRemovalRequests = await prisma.dataRemovalRequest.findMany()
    * ```
    */
  get dataRemovalRequest(): Prisma.DataRemovalRequestDelegate<ExtArgs>;

  /**
   * `prisma.meetingKind`: Exposes CRUD operations for the **MeetingKind** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MeetingKinds
    * const meetingKinds = await prisma.meetingKind.findMany()
    * ```
    */
  get meetingKind(): Prisma.MeetingKindDelegate<ExtArgs>;

  /**
   * `prisma.courseStructure`: Exposes CRUD operations for the **CourseStructure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseStructures
    * const courseStructures = await prisma.courseStructure.findMany()
    * ```
    */
  get courseStructure(): Prisma.CourseStructureDelegate<ExtArgs>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs>;

  /**
   * `prisma.classCall`: Exposes CRUD operations for the **ClassCall** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassCalls
    * const classCalls = await prisma.classCall.findMany()
    * ```
    */
  get classCall(): Prisma.ClassCallDelegate<ExtArgs>;

  /**
   * `prisma.classSize`: Exposes CRUD operations for the **ClassSize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassSizes
    * const classSizes = await prisma.classSize.findMany()
    * ```
    */
  get classSize(): Prisma.ClassSizeDelegate<ExtArgs>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs>;

  /**
   * `prisma.courseAdvice`: Exposes CRUD operations for the **CourseAdvice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseAdvices
    * const courseAdvices = await prisma.courseAdvice.findMany()
    * ```
    */
  get courseAdvice(): Prisma.CourseAdviceDelegate<ExtArgs>;

  /**
   * `prisma.courseTask`: Exposes CRUD operations for the **CourseTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseTasks
    * const courseTasks = await prisma.courseTask.findMany()
    * ```
    */
  get courseTask(): Prisma.CourseTaskDelegate<ExtArgs>;

  /**
   * `prisma.courseLevel`: Exposes CRUD operations for the **CourseLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseLevels
    * const courseLevels = await prisma.courseLevel.findMany()
    * ```
    */
  get courseLevel(): Prisma.CourseLevelDelegate<ExtArgs>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs>;

  /**
   * `prisma.courseLevelsPerSubject`: Exposes CRUD operations for the **CourseLevelsPerSubject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseLevelsPerSubjects
    * const courseLevelsPerSubjects = await prisma.courseLevelsPerSubject.findMany()
    * ```
    */
  get courseLevelsPerSubject(): Prisma.CourseLevelsPerSubjectDelegate<ExtArgs>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<ExtArgs>;

  /**
   * `prisma.mentor`: Exposes CRUD operations for the **Mentor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mentors
    * const mentors = await prisma.mentor.findMany()
    * ```
    */
  get mentor(): Prisma.MentorDelegate<ExtArgs>;

  /**
   * `prisma.mentorsClasses`: Exposes CRUD operations for the **MentorsClasses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MentorsClasses
    * const mentorsClasses = await prisma.mentorsClasses.findMany()
    * ```
    */
  get mentorsClasses(): Prisma.MentorsClassesDelegate<ExtArgs>;

  /**
   * `prisma.mentorPayModel`: Exposes CRUD operations for the **MentorPayModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MentorPayModels
    * const mentorPayModels = await prisma.mentorPayModel.findMany()
    * ```
    */
  get mentorPayModel(): Prisma.MentorPayModelDelegate<ExtArgs>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **Module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.ModuleDelegate<ExtArgs>;

  /**
   * `prisma.section`: Exposes CRUD operations for the **Section** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sections
    * const sections = await prisma.section.findMany()
    * ```
    */
  get section(): Prisma.SectionDelegate<ExtArgs>;

  /**
   * `prisma.timeOfDay`: Exposes CRUD operations for the **TimeOfDay** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeOfDays
    * const timeOfDays = await prisma.timeOfDay.findMany()
    * ```
    */
  get timeOfDay(): Prisma.TimeOfDayDelegate<ExtArgs>;

  /**
   * `prisma.tuitionLang`: Exposes CRUD operations for the **TuitionLang** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TuitionLangs
    * const tuitionLangs = await prisma.tuitionLang.findMany()
    * ```
    */
  get tuitionLang(): Prisma.TuitionLangDelegate<ExtArgs>;

  /**
   * `prisma.deck`: Exposes CRUD operations for the **Deck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Decks
    * const decks = await prisma.deck.findMany()
    * ```
    */
  get deck(): Prisma.DeckDelegate<ExtArgs>;

  /**
   * `prisma.lessonCard`: Exposes CRUD operations for the **LessonCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonCards
    * const lessonCards = await prisma.lessonCard.findMany()
    * ```
    */
  get lessonCard(): Prisma.LessonCardDelegate<ExtArgs>;

  /**
   * `prisma.userCard`: Exposes CRUD operations for the **UserCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCards
    * const userCards = await prisma.userCard.findMany()
    * ```
    */
  get userCard(): Prisma.UserCardDelegate<ExtArgs>;

  /**
   * `prisma.vocabulary`: Exposes CRUD operations for the **Vocabulary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vocabularies
    * const vocabularies = await prisma.vocabulary.findMany()
    * ```
    */
  get vocabulary(): Prisma.VocabularyDelegate<ExtArgs>;

  /**
   * `prisma.vocabularyInbox`: Exposes CRUD operations for the **VocabularyInbox** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VocabularyInboxes
    * const vocabularyInboxes = await prisma.vocabularyInbox.findMany()
    * ```
    */
  get vocabularyInbox(): Prisma.VocabularyInboxDelegate<ExtArgs>;

  /**
   * `prisma.bookingRequest`: Exposes CRUD operations for the **BookingRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingRequests
    * const bookingRequests = await prisma.bookingRequest.findMany()
    * ```
    */
  get bookingRequest(): Prisma.BookingRequestDelegate<ExtArgs>;

  /**
   * `prisma.classTask`: Exposes CRUD operations for the **ClassTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassTasks
    * const classTasks = await prisma.classTask.findMany()
    * ```
    */
  get classTask(): Prisma.ClassTaskDelegate<ExtArgs>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs>;

  /**
   * `prisma.studentAnswer`: Exposes CRUD operations for the **StudentAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentAnswers
    * const studentAnswers = await prisma.studentAnswer.findMany()
    * ```
    */
  get studentAnswer(): Prisma.StudentAnswerDelegate<ExtArgs>;

  /**
   * `prisma.studentTask`: Exposes CRUD operations for the **StudentTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentTasks
    * const studentTasks = await prisma.studentTask.findMany()
    * ```
    */
  get studentTask(): Prisma.StudentTaskDelegate<ExtArgs>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs>;

  /**
   * `prisma.taskForm`: Exposes CRUD operations for the **TaskForm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskForms
    * const taskForms = await prisma.taskForm.findMany()
    * ```
    */
  get taskForm(): Prisma.TaskFormDelegate<ExtArgs>;

  /**
   * `prisma.taskContext`: Exposes CRUD operations for the **TaskContext** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskContexts
    * const taskContexts = await prisma.taskContext.findMany()
    * ```
    */
  get taskContext(): Prisma.TaskContextDelegate<ExtArgs>;

  /**
   * `prisma.taskOption`: Exposes CRUD operations for the **TaskOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskOptions
    * const taskOptions = await prisma.taskOption.findMany()
    * ```
    */
  get taskOption(): Prisma.TaskOptionDelegate<ExtArgs>;

  /**
   * `prisma.taskType`: Exposes CRUD operations for the **TaskType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskTypes
    * const taskTypes = await prisma.taskType.findMany()
    * ```
    */
  get taskType(): Prisma.TaskTypeDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.19.1
   * Query Engine version: 69d742ee20b815d88e17e54db4a2a7a3b30324e3
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    UserRole: 'UserRole',
    UserApplicationPreferences: 'UserApplicationPreferences',
    Application: 'Application',
    DataRemovalRequest: 'DataRemovalRequest',
    MeetingKind: 'MeetingKind',
    CourseStructure: 'CourseStructure',
    Class: 'Class',
    ClassCall: 'ClassCall',
    ClassSize: 'ClassSize',
    Course: 'Course',
    CourseAdvice: 'CourseAdvice',
    CourseTask: 'CourseTask',
    CourseLevel: 'CourseLevel',
    Subject: 'Subject',
    CourseLevelsPerSubject: 'CourseLevelsPerSubject',
    Lesson: 'Lesson',
    Mentor: 'Mentor',
    MentorsClasses: 'MentorsClasses',
    MentorPayModel: 'MentorPayModel',
    Module: 'Module',
    Section: 'Section',
    TimeOfDay: 'TimeOfDay',
    TuitionLang: 'TuitionLang',
    Deck: 'Deck',
    LessonCard: 'LessonCard',
    UserCard: 'UserCard',
    Vocabulary: 'Vocabulary',
    VocabularyInbox: 'VocabularyInbox',
    BookingRequest: 'BookingRequest',
    ClassTask: 'ClassTask',
    Student: 'Student',
    StudentAnswer: 'StudentAnswer',
    StudentTask: 'StudentTask',
    Task: 'Task',
    TaskForm: 'TaskForm',
    TaskContext: 'TaskContext',
    TaskOption: 'TaskOption',
    TaskType: 'TaskType'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "role" | "userRole" | "userApplicationPreferences" | "application" | "dataRemovalRequest" | "meetingKind" | "courseStructure" | "class" | "classCall" | "classSize" | "course" | "courseAdvice" | "courseTask" | "courseLevel" | "subject" | "courseLevelsPerSubject" | "lesson" | "mentor" | "mentorsClasses" | "mentorPayModel" | "module" | "section" | "timeOfDay" | "tuitionLang" | "deck" | "lessonCard" | "userCard" | "vocabulary" | "vocabularyInbox" | "bookingRequest" | "classTask" | "student" | "studentAnswer" | "studentTask" | "task" | "taskForm" | "taskContext" | "taskOption" | "taskType"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      UserApplicationPreferences: {
        payload: Prisma.$UserApplicationPreferencesPayload<ExtArgs>
        fields: Prisma.UserApplicationPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserApplicationPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApplicationPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserApplicationPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApplicationPreferencesPayload>
          }
          findFirst: {
            args: Prisma.UserApplicationPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApplicationPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserApplicationPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApplicationPreferencesPayload>
          }
          findMany: {
            args: Prisma.UserApplicationPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApplicationPreferencesPayload>[]
          }
          create: {
            args: Prisma.UserApplicationPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApplicationPreferencesPayload>
          }
          createMany: {
            args: Prisma.UserApplicationPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserApplicationPreferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApplicationPreferencesPayload>[]
          }
          delete: {
            args: Prisma.UserApplicationPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApplicationPreferencesPayload>
          }
          update: {
            args: Prisma.UserApplicationPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApplicationPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.UserApplicationPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserApplicationPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserApplicationPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserApplicationPreferencesPayload>
          }
          aggregate: {
            args: Prisma.UserApplicationPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserApplicationPreferences>
          }
          groupBy: {
            args: Prisma.UserApplicationPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserApplicationPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserApplicationPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<UserApplicationPreferencesCountAggregateOutputType> | number
          }
        }
      }
      Application: {
        payload: Prisma.$ApplicationPayload<ExtArgs>
        fields: Prisma.ApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findFirst: {
            args: Prisma.ApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findMany: {
            args: Prisma.ApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          create: {
            args: Prisma.ApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          createMany: {
            args: Prisma.ApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          delete: {
            args: Prisma.ApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          update: {
            args: Prisma.ApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          deleteMany: {
            args: Prisma.ApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          aggregate: {
            args: Prisma.ApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplication>
          }
          groupBy: {
            args: Prisma.ApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationCountAggregateOutputType> | number
          }
        }
      }
      DataRemovalRequest: {
        payload: Prisma.$DataRemovalRequestPayload<ExtArgs>
        fields: Prisma.DataRemovalRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataRemovalRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRemovalRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataRemovalRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRemovalRequestPayload>
          }
          findFirst: {
            args: Prisma.DataRemovalRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRemovalRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataRemovalRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRemovalRequestPayload>
          }
          findMany: {
            args: Prisma.DataRemovalRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRemovalRequestPayload>[]
          }
          create: {
            args: Prisma.DataRemovalRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRemovalRequestPayload>
          }
          createMany: {
            args: Prisma.DataRemovalRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataRemovalRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRemovalRequestPayload>[]
          }
          delete: {
            args: Prisma.DataRemovalRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRemovalRequestPayload>
          }
          update: {
            args: Prisma.DataRemovalRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRemovalRequestPayload>
          }
          deleteMany: {
            args: Prisma.DataRemovalRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataRemovalRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataRemovalRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRemovalRequestPayload>
          }
          aggregate: {
            args: Prisma.DataRemovalRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataRemovalRequest>
          }
          groupBy: {
            args: Prisma.DataRemovalRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataRemovalRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataRemovalRequestCountArgs<ExtArgs>
            result: $Utils.Optional<DataRemovalRequestCountAggregateOutputType> | number
          }
        }
      }
      MeetingKind: {
        payload: Prisma.$MeetingKindPayload<ExtArgs>
        fields: Prisma.MeetingKindFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeetingKindFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingKindPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeetingKindFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingKindPayload>
          }
          findFirst: {
            args: Prisma.MeetingKindFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingKindPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeetingKindFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingKindPayload>
          }
          findMany: {
            args: Prisma.MeetingKindFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingKindPayload>[]
          }
          create: {
            args: Prisma.MeetingKindCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingKindPayload>
          }
          createMany: {
            args: Prisma.MeetingKindCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeetingKindCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingKindPayload>[]
          }
          delete: {
            args: Prisma.MeetingKindDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingKindPayload>
          }
          update: {
            args: Prisma.MeetingKindUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingKindPayload>
          }
          deleteMany: {
            args: Prisma.MeetingKindDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeetingKindUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MeetingKindUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingKindPayload>
          }
          aggregate: {
            args: Prisma.MeetingKindAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeetingKind>
          }
          groupBy: {
            args: Prisma.MeetingKindGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingKindGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeetingKindCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingKindCountAggregateOutputType> | number
          }
        }
      }
      CourseStructure: {
        payload: Prisma.$CourseStructurePayload<ExtArgs>
        fields: Prisma.CourseStructureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseStructureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseStructurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseStructureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseStructurePayload>
          }
          findFirst: {
            args: Prisma.CourseStructureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseStructurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseStructureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseStructurePayload>
          }
          findMany: {
            args: Prisma.CourseStructureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseStructurePayload>[]
          }
          create: {
            args: Prisma.CourseStructureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseStructurePayload>
          }
          createMany: {
            args: Prisma.CourseStructureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseStructureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseStructurePayload>[]
          }
          delete: {
            args: Prisma.CourseStructureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseStructurePayload>
          }
          update: {
            args: Prisma.CourseStructureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseStructurePayload>
          }
          deleteMany: {
            args: Prisma.CourseStructureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseStructureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseStructureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseStructurePayload>
          }
          aggregate: {
            args: Prisma.CourseStructureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseStructure>
          }
          groupBy: {
            args: Prisma.CourseStructureGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseStructureGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseStructureCountArgs<ExtArgs>
            result: $Utils.Optional<CourseStructureCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      ClassCall: {
        payload: Prisma.$ClassCallPayload<ExtArgs>
        fields: Prisma.ClassCallFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassCallFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassCallPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassCallFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassCallPayload>
          }
          findFirst: {
            args: Prisma.ClassCallFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassCallPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassCallFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassCallPayload>
          }
          findMany: {
            args: Prisma.ClassCallFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassCallPayload>[]
          }
          create: {
            args: Prisma.ClassCallCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassCallPayload>
          }
          createMany: {
            args: Prisma.ClassCallCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCallCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassCallPayload>[]
          }
          delete: {
            args: Prisma.ClassCallDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassCallPayload>
          }
          update: {
            args: Prisma.ClassCallUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassCallPayload>
          }
          deleteMany: {
            args: Prisma.ClassCallDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassCallUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassCallUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassCallPayload>
          }
          aggregate: {
            args: Prisma.ClassCallAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassCall>
          }
          groupBy: {
            args: Prisma.ClassCallGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassCallGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCallCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCallCountAggregateOutputType> | number
          }
        }
      }
      ClassSize: {
        payload: Prisma.$ClassSizePayload<ExtArgs>
        fields: Prisma.ClassSizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassSizeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassSizeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSizePayload>
          }
          findFirst: {
            args: Prisma.ClassSizeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassSizeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSizePayload>
          }
          findMany: {
            args: Prisma.ClassSizeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSizePayload>[]
          }
          create: {
            args: Prisma.ClassSizeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSizePayload>
          }
          createMany: {
            args: Prisma.ClassSizeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassSizeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSizePayload>[]
          }
          delete: {
            args: Prisma.ClassSizeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSizePayload>
          }
          update: {
            args: Prisma.ClassSizeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSizePayload>
          }
          deleteMany: {
            args: Prisma.ClassSizeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassSizeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassSizeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSizePayload>
          }
          aggregate: {
            args: Prisma.ClassSizeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassSize>
          }
          groupBy: {
            args: Prisma.ClassSizeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassSizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassSizeCountArgs<ExtArgs>
            result: $Utils.Optional<ClassSizeCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      CourseAdvice: {
        payload: Prisma.$CourseAdvicePayload<ExtArgs>
        fields: Prisma.CourseAdviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseAdviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdvicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseAdviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdvicePayload>
          }
          findFirst: {
            args: Prisma.CourseAdviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdvicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseAdviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdvicePayload>
          }
          findMany: {
            args: Prisma.CourseAdviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdvicePayload>[]
          }
          create: {
            args: Prisma.CourseAdviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdvicePayload>
          }
          createMany: {
            args: Prisma.CourseAdviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseAdviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdvicePayload>[]
          }
          delete: {
            args: Prisma.CourseAdviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdvicePayload>
          }
          update: {
            args: Prisma.CourseAdviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdvicePayload>
          }
          deleteMany: {
            args: Prisma.CourseAdviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseAdviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseAdviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseAdvicePayload>
          }
          aggregate: {
            args: Prisma.CourseAdviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseAdvice>
          }
          groupBy: {
            args: Prisma.CourseAdviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseAdviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseAdviceCountArgs<ExtArgs>
            result: $Utils.Optional<CourseAdviceCountAggregateOutputType> | number
          }
        }
      }
      CourseTask: {
        payload: Prisma.$CourseTaskPayload<ExtArgs>
        fields: Prisma.CourseTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTaskPayload>
          }
          findFirst: {
            args: Prisma.CourseTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTaskPayload>
          }
          findMany: {
            args: Prisma.CourseTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTaskPayload>[]
          }
          create: {
            args: Prisma.CourseTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTaskPayload>
          }
          createMany: {
            args: Prisma.CourseTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTaskPayload>[]
          }
          delete: {
            args: Prisma.CourseTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTaskPayload>
          }
          update: {
            args: Prisma.CourseTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTaskPayload>
          }
          deleteMany: {
            args: Prisma.CourseTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseTaskPayload>
          }
          aggregate: {
            args: Prisma.CourseTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseTask>
          }
          groupBy: {
            args: Prisma.CourseTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseTaskCountArgs<ExtArgs>
            result: $Utils.Optional<CourseTaskCountAggregateOutputType> | number
          }
        }
      }
      CourseLevel: {
        payload: Prisma.$CourseLevelPayload<ExtArgs>
        fields: Prisma.CourseLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseLevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseLevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelPayload>
          }
          findFirst: {
            args: Prisma.CourseLevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseLevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelPayload>
          }
          findMany: {
            args: Prisma.CourseLevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelPayload>[]
          }
          create: {
            args: Prisma.CourseLevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelPayload>
          }
          createMany: {
            args: Prisma.CourseLevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseLevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelPayload>[]
          }
          delete: {
            args: Prisma.CourseLevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelPayload>
          }
          update: {
            args: Prisma.CourseLevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelPayload>
          }
          deleteMany: {
            args: Prisma.CourseLevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseLevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseLevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelPayload>
          }
          aggregate: {
            args: Prisma.CourseLevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseLevel>
          }
          groupBy: {
            args: Prisma.CourseLevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseLevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseLevelCountArgs<ExtArgs>
            result: $Utils.Optional<CourseLevelCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      CourseLevelsPerSubject: {
        payload: Prisma.$CourseLevelsPerSubjectPayload<ExtArgs>
        fields: Prisma.CourseLevelsPerSubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseLevelsPerSubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelsPerSubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseLevelsPerSubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelsPerSubjectPayload>
          }
          findFirst: {
            args: Prisma.CourseLevelsPerSubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelsPerSubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseLevelsPerSubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelsPerSubjectPayload>
          }
          findMany: {
            args: Prisma.CourseLevelsPerSubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelsPerSubjectPayload>[]
          }
          create: {
            args: Prisma.CourseLevelsPerSubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelsPerSubjectPayload>
          }
          createMany: {
            args: Prisma.CourseLevelsPerSubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseLevelsPerSubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelsPerSubjectPayload>[]
          }
          delete: {
            args: Prisma.CourseLevelsPerSubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelsPerSubjectPayload>
          }
          update: {
            args: Prisma.CourseLevelsPerSubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelsPerSubjectPayload>
          }
          deleteMany: {
            args: Prisma.CourseLevelsPerSubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseLevelsPerSubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseLevelsPerSubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseLevelsPerSubjectPayload>
          }
          aggregate: {
            args: Prisma.CourseLevelsPerSubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseLevelsPerSubject>
          }
          groupBy: {
            args: Prisma.CourseLevelsPerSubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseLevelsPerSubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseLevelsPerSubjectCountArgs<ExtArgs>
            result: $Utils.Optional<CourseLevelsPerSubjectCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: Prisma.$LessonPayload<ExtArgs>
        fields: Prisma.LessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      Mentor: {
        payload: Prisma.$MentorPayload<ExtArgs>
        fields: Prisma.MentorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>
          }
          findFirst: {
            args: Prisma.MentorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>
          }
          findMany: {
            args: Prisma.MentorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>[]
          }
          create: {
            args: Prisma.MentorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>
          }
          createMany: {
            args: Prisma.MentorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>[]
          }
          delete: {
            args: Prisma.MentorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>
          }
          update: {
            args: Prisma.MentorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>
          }
          deleteMany: {
            args: Prisma.MentorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MentorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayload>
          }
          aggregate: {
            args: Prisma.MentorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentor>
          }
          groupBy: {
            args: Prisma.MentorGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentorCountArgs<ExtArgs>
            result: $Utils.Optional<MentorCountAggregateOutputType> | number
          }
        }
      }
      MentorsClasses: {
        payload: Prisma.$MentorsClassesPayload<ExtArgs>
        fields: Prisma.MentorsClassesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentorsClassesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorsClassesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentorsClassesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorsClassesPayload>
          }
          findFirst: {
            args: Prisma.MentorsClassesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorsClassesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentorsClassesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorsClassesPayload>
          }
          findMany: {
            args: Prisma.MentorsClassesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorsClassesPayload>[]
          }
          create: {
            args: Prisma.MentorsClassesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorsClassesPayload>
          }
          createMany: {
            args: Prisma.MentorsClassesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentorsClassesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorsClassesPayload>[]
          }
          delete: {
            args: Prisma.MentorsClassesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorsClassesPayload>
          }
          update: {
            args: Prisma.MentorsClassesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorsClassesPayload>
          }
          deleteMany: {
            args: Prisma.MentorsClassesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentorsClassesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MentorsClassesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorsClassesPayload>
          }
          aggregate: {
            args: Prisma.MentorsClassesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentorsClasses>
          }
          groupBy: {
            args: Prisma.MentorsClassesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorsClassesGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentorsClassesCountArgs<ExtArgs>
            result: $Utils.Optional<MentorsClassesCountAggregateOutputType> | number
          }
        }
      }
      MentorPayModel: {
        payload: Prisma.$MentorPayModelPayload<ExtArgs>
        fields: Prisma.MentorPayModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentorPayModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentorPayModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayModelPayload>
          }
          findFirst: {
            args: Prisma.MentorPayModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentorPayModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayModelPayload>
          }
          findMany: {
            args: Prisma.MentorPayModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayModelPayload>[]
          }
          create: {
            args: Prisma.MentorPayModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayModelPayload>
          }
          createMany: {
            args: Prisma.MentorPayModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentorPayModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayModelPayload>[]
          }
          delete: {
            args: Prisma.MentorPayModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayModelPayload>
          }
          update: {
            args: Prisma.MentorPayModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayModelPayload>
          }
          deleteMany: {
            args: Prisma.MentorPayModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentorPayModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MentorPayModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorPayModelPayload>
          }
          aggregate: {
            args: Prisma.MentorPayModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentorPayModel>
          }
          groupBy: {
            args: Prisma.MentorPayModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorPayModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentorPayModelCountArgs<ExtArgs>
            result: $Utils.Optional<MentorPayModelCountAggregateOutputType> | number
          }
        }
      }
      Module: {
        payload: Prisma.$ModulePayload<ExtArgs>
        fields: Prisma.ModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findFirst: {
            args: Prisma.ModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findMany: {
            args: Prisma.ModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          create: {
            args: Prisma.ModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          createMany: {
            args: Prisma.ModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          delete: {
            args: Prisma.ModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          update: {
            args: Prisma.ModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          deleteMany: {
            args: Prisma.ModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          aggregate: {
            args: Prisma.ModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModule>
          }
          groupBy: {
            args: Prisma.ModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleCountAggregateOutputType> | number
          }
        }
      }
      Section: {
        payload: Prisma.$SectionPayload<ExtArgs>
        fields: Prisma.SectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findFirst: {
            args: Prisma.SectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findMany: {
            args: Prisma.SectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          create: {
            args: Prisma.SectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          createMany: {
            args: Prisma.SectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          delete: {
            args: Prisma.SectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          update: {
            args: Prisma.SectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          deleteMany: {
            args: Prisma.SectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          aggregate: {
            args: Prisma.SectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSection>
          }
          groupBy: {
            args: Prisma.SectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectionCountArgs<ExtArgs>
            result: $Utils.Optional<SectionCountAggregateOutputType> | number
          }
        }
      }
      TimeOfDay: {
        payload: Prisma.$TimeOfDayPayload<ExtArgs>
        fields: Prisma.TimeOfDayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeOfDayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeOfDayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeOfDayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeOfDayPayload>
          }
          findFirst: {
            args: Prisma.TimeOfDayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeOfDayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeOfDayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeOfDayPayload>
          }
          findMany: {
            args: Prisma.TimeOfDayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeOfDayPayload>[]
          }
          create: {
            args: Prisma.TimeOfDayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeOfDayPayload>
          }
          createMany: {
            args: Prisma.TimeOfDayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeOfDayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeOfDayPayload>[]
          }
          delete: {
            args: Prisma.TimeOfDayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeOfDayPayload>
          }
          update: {
            args: Prisma.TimeOfDayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeOfDayPayload>
          }
          deleteMany: {
            args: Prisma.TimeOfDayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeOfDayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TimeOfDayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeOfDayPayload>
          }
          aggregate: {
            args: Prisma.TimeOfDayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeOfDay>
          }
          groupBy: {
            args: Prisma.TimeOfDayGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeOfDayGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeOfDayCountArgs<ExtArgs>
            result: $Utils.Optional<TimeOfDayCountAggregateOutputType> | number
          }
        }
      }
      TuitionLang: {
        payload: Prisma.$TuitionLangPayload<ExtArgs>
        fields: Prisma.TuitionLangFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TuitionLangFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuitionLangPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TuitionLangFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuitionLangPayload>
          }
          findFirst: {
            args: Prisma.TuitionLangFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuitionLangPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TuitionLangFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuitionLangPayload>
          }
          findMany: {
            args: Prisma.TuitionLangFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuitionLangPayload>[]
          }
          create: {
            args: Prisma.TuitionLangCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuitionLangPayload>
          }
          createMany: {
            args: Prisma.TuitionLangCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TuitionLangCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuitionLangPayload>[]
          }
          delete: {
            args: Prisma.TuitionLangDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuitionLangPayload>
          }
          update: {
            args: Prisma.TuitionLangUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuitionLangPayload>
          }
          deleteMany: {
            args: Prisma.TuitionLangDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TuitionLangUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TuitionLangUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuitionLangPayload>
          }
          aggregate: {
            args: Prisma.TuitionLangAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTuitionLang>
          }
          groupBy: {
            args: Prisma.TuitionLangGroupByArgs<ExtArgs>
            result: $Utils.Optional<TuitionLangGroupByOutputType>[]
          }
          count: {
            args: Prisma.TuitionLangCountArgs<ExtArgs>
            result: $Utils.Optional<TuitionLangCountAggregateOutputType> | number
          }
        }
      }
      Deck: {
        payload: Prisma.$DeckPayload<ExtArgs>
        fields: Prisma.DeckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeckPayload>
          }
          findFirst: {
            args: Prisma.DeckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeckPayload>
          }
          findMany: {
            args: Prisma.DeckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeckPayload>[]
          }
          create: {
            args: Prisma.DeckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeckPayload>
          }
          createMany: {
            args: Prisma.DeckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeckPayload>[]
          }
          delete: {
            args: Prisma.DeckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeckPayload>
          }
          update: {
            args: Prisma.DeckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeckPayload>
          }
          deleteMany: {
            args: Prisma.DeckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeckPayload>
          }
          aggregate: {
            args: Prisma.DeckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeck>
          }
          groupBy: {
            args: Prisma.DeckGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeckGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeckCountArgs<ExtArgs>
            result: $Utils.Optional<DeckCountAggregateOutputType> | number
          }
        }
      }
      LessonCard: {
        payload: Prisma.$LessonCardPayload<ExtArgs>
        fields: Prisma.LessonCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCardPayload>
          }
          findFirst: {
            args: Prisma.LessonCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCardPayload>
          }
          findMany: {
            args: Prisma.LessonCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCardPayload>[]
          }
          create: {
            args: Prisma.LessonCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCardPayload>
          }
          createMany: {
            args: Prisma.LessonCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCardPayload>[]
          }
          delete: {
            args: Prisma.LessonCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCardPayload>
          }
          update: {
            args: Prisma.LessonCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCardPayload>
          }
          deleteMany: {
            args: Prisma.LessonCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LessonCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonCardPayload>
          }
          aggregate: {
            args: Prisma.LessonCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLessonCard>
          }
          groupBy: {
            args: Prisma.LessonCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCardCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCardCountAggregateOutputType> | number
          }
        }
      }
      UserCard: {
        payload: Prisma.$UserCardPayload<ExtArgs>
        fields: Prisma.UserCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          findFirst: {
            args: Prisma.UserCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          findMany: {
            args: Prisma.UserCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>[]
          }
          create: {
            args: Prisma.UserCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          createMany: {
            args: Prisma.UserCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>[]
          }
          delete: {
            args: Prisma.UserCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          update: {
            args: Prisma.UserCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          deleteMany: {
            args: Prisma.UserCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCardPayload>
          }
          aggregate: {
            args: Prisma.UserCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCard>
          }
          groupBy: {
            args: Prisma.UserCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCardCountArgs<ExtArgs>
            result: $Utils.Optional<UserCardCountAggregateOutputType> | number
          }
        }
      }
      Vocabulary: {
        payload: Prisma.$VocabularyPayload<ExtArgs>
        fields: Prisma.VocabularyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VocabularyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VocabularyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload>
          }
          findFirst: {
            args: Prisma.VocabularyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VocabularyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload>
          }
          findMany: {
            args: Prisma.VocabularyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload>[]
          }
          create: {
            args: Prisma.VocabularyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload>
          }
          createMany: {
            args: Prisma.VocabularyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VocabularyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload>[]
          }
          delete: {
            args: Prisma.VocabularyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload>
          }
          update: {
            args: Prisma.VocabularyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload>
          }
          deleteMany: {
            args: Prisma.VocabularyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VocabularyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VocabularyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyPayload>
          }
          aggregate: {
            args: Prisma.VocabularyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVocabulary>
          }
          groupBy: {
            args: Prisma.VocabularyGroupByArgs<ExtArgs>
            result: $Utils.Optional<VocabularyGroupByOutputType>[]
          }
          count: {
            args: Prisma.VocabularyCountArgs<ExtArgs>
            result: $Utils.Optional<VocabularyCountAggregateOutputType> | number
          }
        }
      }
      VocabularyInbox: {
        payload: Prisma.$VocabularyInboxPayload<ExtArgs>
        fields: Prisma.VocabularyInboxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VocabularyInboxFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyInboxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VocabularyInboxFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyInboxPayload>
          }
          findFirst: {
            args: Prisma.VocabularyInboxFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyInboxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VocabularyInboxFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyInboxPayload>
          }
          findMany: {
            args: Prisma.VocabularyInboxFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyInboxPayload>[]
          }
          create: {
            args: Prisma.VocabularyInboxCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyInboxPayload>
          }
          createMany: {
            args: Prisma.VocabularyInboxCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VocabularyInboxCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyInboxPayload>[]
          }
          delete: {
            args: Prisma.VocabularyInboxDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyInboxPayload>
          }
          update: {
            args: Prisma.VocabularyInboxUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyInboxPayload>
          }
          deleteMany: {
            args: Prisma.VocabularyInboxDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VocabularyInboxUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VocabularyInboxUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VocabularyInboxPayload>
          }
          aggregate: {
            args: Prisma.VocabularyInboxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVocabularyInbox>
          }
          groupBy: {
            args: Prisma.VocabularyInboxGroupByArgs<ExtArgs>
            result: $Utils.Optional<VocabularyInboxGroupByOutputType>[]
          }
          count: {
            args: Prisma.VocabularyInboxCountArgs<ExtArgs>
            result: $Utils.Optional<VocabularyInboxCountAggregateOutputType> | number
          }
        }
      }
      BookingRequest: {
        payload: Prisma.$BookingRequestPayload<ExtArgs>
        fields: Prisma.BookingRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload>
          }
          findFirst: {
            args: Prisma.BookingRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload>
          }
          findMany: {
            args: Prisma.BookingRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload>[]
          }
          create: {
            args: Prisma.BookingRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload>
          }
          createMany: {
            args: Prisma.BookingRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload>[]
          }
          delete: {
            args: Prisma.BookingRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload>
          }
          update: {
            args: Prisma.BookingRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload>
          }
          deleteMany: {
            args: Prisma.BookingRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequestPayload>
          }
          aggregate: {
            args: Prisma.BookingRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingRequest>
          }
          groupBy: {
            args: Prisma.BookingRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingRequestCountArgs<ExtArgs>
            result: $Utils.Optional<BookingRequestCountAggregateOutputType> | number
          }
        }
      }
      ClassTask: {
        payload: Prisma.$ClassTaskPayload<ExtArgs>
        fields: Prisma.ClassTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassTaskPayload>
          }
          findFirst: {
            args: Prisma.ClassTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassTaskPayload>
          }
          findMany: {
            args: Prisma.ClassTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassTaskPayload>[]
          }
          create: {
            args: Prisma.ClassTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassTaskPayload>
          }
          createMany: {
            args: Prisma.ClassTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassTaskPayload>[]
          }
          delete: {
            args: Prisma.ClassTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassTaskPayload>
          }
          update: {
            args: Prisma.ClassTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassTaskPayload>
          }
          deleteMany: {
            args: Prisma.ClassTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassTaskPayload>
          }
          aggregate: {
            args: Prisma.ClassTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassTask>
          }
          groupBy: {
            args: Prisma.ClassTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassTaskCountArgs<ExtArgs>
            result: $Utils.Optional<ClassTaskCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      StudentAnswer: {
        payload: Prisma.$StudentAnswerPayload<ExtArgs>
        fields: Prisma.StudentAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAnswerPayload>
          }
          findFirst: {
            args: Prisma.StudentAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAnswerPayload>
          }
          findMany: {
            args: Prisma.StudentAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAnswerPayload>[]
          }
          create: {
            args: Prisma.StudentAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAnswerPayload>
          }
          createMany: {
            args: Prisma.StudentAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAnswerPayload>[]
          }
          delete: {
            args: Prisma.StudentAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAnswerPayload>
          }
          update: {
            args: Prisma.StudentAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAnswerPayload>
          }
          deleteMany: {
            args: Prisma.StudentAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAnswerPayload>
          }
          aggregate: {
            args: Prisma.StudentAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentAnswer>
          }
          groupBy: {
            args: Prisma.StudentAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<StudentAnswerCountAggregateOutputType> | number
          }
        }
      }
      StudentTask: {
        payload: Prisma.$StudentTaskPayload<ExtArgs>
        fields: Prisma.StudentTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload>
          }
          findFirst: {
            args: Prisma.StudentTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload>
          }
          findMany: {
            args: Prisma.StudentTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload>[]
          }
          create: {
            args: Prisma.StudentTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload>
          }
          createMany: {
            args: Prisma.StudentTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload>[]
          }
          delete: {
            args: Prisma.StudentTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload>
          }
          update: {
            args: Prisma.StudentTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload>
          }
          deleteMany: {
            args: Prisma.StudentTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload>
          }
          aggregate: {
            args: Prisma.StudentTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentTask>
          }
          groupBy: {
            args: Prisma.StudentTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentTaskCountArgs<ExtArgs>
            result: $Utils.Optional<StudentTaskCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TaskForm: {
        payload: Prisma.$TaskFormPayload<ExtArgs>
        fields: Prisma.TaskFormFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFormFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFormPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFormFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFormPayload>
          }
          findFirst: {
            args: Prisma.TaskFormFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFormPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFormFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFormPayload>
          }
          findMany: {
            args: Prisma.TaskFormFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFormPayload>[]
          }
          create: {
            args: Prisma.TaskFormCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFormPayload>
          }
          createMany: {
            args: Prisma.TaskFormCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskFormCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFormPayload>[]
          }
          delete: {
            args: Prisma.TaskFormDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFormPayload>
          }
          update: {
            args: Prisma.TaskFormUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFormPayload>
          }
          deleteMany: {
            args: Prisma.TaskFormDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskFormUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskFormUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskFormPayload>
          }
          aggregate: {
            args: Prisma.TaskFormAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskForm>
          }
          groupBy: {
            args: Prisma.TaskFormGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskFormGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskFormCountArgs<ExtArgs>
            result: $Utils.Optional<TaskFormCountAggregateOutputType> | number
          }
        }
      }
      TaskContext: {
        payload: Prisma.$TaskContextPayload<ExtArgs>
        fields: Prisma.TaskContextFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskContextFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskContextPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskContextFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskContextPayload>
          }
          findFirst: {
            args: Prisma.TaskContextFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskContextPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskContextFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskContextPayload>
          }
          findMany: {
            args: Prisma.TaskContextFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskContextPayload>[]
          }
          create: {
            args: Prisma.TaskContextCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskContextPayload>
          }
          createMany: {
            args: Prisma.TaskContextCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskContextCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskContextPayload>[]
          }
          delete: {
            args: Prisma.TaskContextDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskContextPayload>
          }
          update: {
            args: Prisma.TaskContextUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskContextPayload>
          }
          deleteMany: {
            args: Prisma.TaskContextDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskContextUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskContextUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskContextPayload>
          }
          aggregate: {
            args: Prisma.TaskContextAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskContext>
          }
          groupBy: {
            args: Prisma.TaskContextGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskContextGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskContextCountArgs<ExtArgs>
            result: $Utils.Optional<TaskContextCountAggregateOutputType> | number
          }
        }
      }
      TaskOption: {
        payload: Prisma.$TaskOptionPayload<ExtArgs>
        fields: Prisma.TaskOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOptionPayload>
          }
          findFirst: {
            args: Prisma.TaskOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOptionPayload>
          }
          findMany: {
            args: Prisma.TaskOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOptionPayload>[]
          }
          create: {
            args: Prisma.TaskOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOptionPayload>
          }
          createMany: {
            args: Prisma.TaskOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOptionPayload>[]
          }
          delete: {
            args: Prisma.TaskOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOptionPayload>
          }
          update: {
            args: Prisma.TaskOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOptionPayload>
          }
          deleteMany: {
            args: Prisma.TaskOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskOptionPayload>
          }
          aggregate: {
            args: Prisma.TaskOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskOption>
          }
          groupBy: {
            args: Prisma.TaskOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskOptionCountArgs<ExtArgs>
            result: $Utils.Optional<TaskOptionCountAggregateOutputType> | number
          }
        }
      }
      TaskType: {
        payload: Prisma.$TaskTypePayload<ExtArgs>
        fields: Prisma.TaskTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTypePayload>
          }
          findFirst: {
            args: Prisma.TaskTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTypePayload>
          }
          findMany: {
            args: Prisma.TaskTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTypePayload>[]
          }
          create: {
            args: Prisma.TaskTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTypePayload>
          }
          createMany: {
            args: Prisma.TaskTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTypePayload>[]
          }
          delete: {
            args: Prisma.TaskTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTypePayload>
          }
          update: {
            args: Prisma.TaskTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTypePayload>
          }
          deleteMany: {
            args: Prisma.TaskTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskTypePayload>
          }
          aggregate: {
            args: Prisma.TaskTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskType>
          }
          groupBy: {
            args: Prisma.TaskTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskTypeCountArgs<ExtArgs>
            result: $Utils.Optional<TaskTypeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    user_roles: number
    user_application_preferences: number
    mentor: number
    is_student_of: number
    DataRemovalRequest: number
    Deck: number
    UserCard: number
    VocabularyInbox: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_roles?: boolean | UserCountOutputTypeCountUser_rolesArgs
    user_application_preferences?: boolean | UserCountOutputTypeCountUser_application_preferencesArgs
    mentor?: boolean | UserCountOutputTypeCountMentorArgs
    is_student_of?: boolean | UserCountOutputTypeCountIs_student_ofArgs
    DataRemovalRequest?: boolean | UserCountOutputTypeCountDataRemovalRequestArgs
    Deck?: boolean | UserCountOutputTypeCountDeckArgs
    UserCard?: boolean | UserCountOutputTypeCountUserCardArgs
    VocabularyInbox?: boolean | UserCountOutputTypeCountVocabularyInboxArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_application_preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserApplicationPreferencesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMentorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIs_student_ofArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDataRemovalRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataRemovalRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeckArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeckWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVocabularyInboxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VocabularyInboxWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    user_roles: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_roles?: boolean | RoleCountOutputTypeCountUser_rolesArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUser_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type ApplicationCountOutputType
   */

  export type ApplicationCountOutputType = {
    user_application_preferences: number
  }

  export type ApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_application_preferences?: boolean | ApplicationCountOutputTypeCountUser_application_preferencesArgs
  }

  // Custom InputTypes
  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApplicationCountOutputType
     */
    select?: ApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApplicationCountOutputType without action
   */
  export type ApplicationCountOutputTypeCountUser_application_preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserApplicationPreferencesWhereInput
  }


  /**
   * Count Type MeetingKindCountOutputType
   */

  export type MeetingKindCountOutputType = {
    class_calls: number
  }

  export type MeetingKindCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class_calls?: boolean | MeetingKindCountOutputTypeCountClass_callsArgs
  }

  // Custom InputTypes
  /**
   * MeetingKindCountOutputType without action
   */
  export type MeetingKindCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingKindCountOutputType
     */
    select?: MeetingKindCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MeetingKindCountOutputType without action
   */
  export type MeetingKindCountOutputTypeCountClass_callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassCallWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    mentor_classes: number
    students: number
    booking_requests: number
    class_calls: number
    ClassTask: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentor_classes?: boolean | ClassCountOutputTypeCountMentor_classesArgs
    students?: boolean | ClassCountOutputTypeCountStudentsArgs
    booking_requests?: boolean | ClassCountOutputTypeCountBooking_requestsArgs
    class_calls?: boolean | ClassCountOutputTypeCountClass_callsArgs
    ClassTask?: boolean | ClassCountOutputTypeCountClassTaskArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountMentor_classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorsClassesWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountBooking_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingRequestWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountClass_callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassCallWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountClassTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassTaskWhereInput
  }


  /**
   * Count Type ClassSizeCountOutputType
   */

  export type ClassSizeCountOutputType = {
    classes: number
    MentorPayModel: number
  }

  export type ClassSizeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | ClassSizeCountOutputTypeCountClassesArgs
    MentorPayModel?: boolean | ClassSizeCountOutputTypeCountMentorPayModelArgs
  }

  // Custom InputTypes
  /**
   * ClassSizeCountOutputType without action
   */
  export type ClassSizeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSizeCountOutputType
     */
    select?: ClassSizeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassSizeCountOutputType without action
   */
  export type ClassSizeCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * ClassSizeCountOutputType without action
   */
  export type ClassSizeCountOutputTypeCountMentorPayModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorPayModelWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    course_advice: number
    classes: number
    CourseStructure: number
    CourseTask: number
    Module: number
    LessonCard: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course_advice?: boolean | CourseCountOutputTypeCountCourse_adviceArgs
    classes?: boolean | CourseCountOutputTypeCountClassesArgs
    CourseStructure?: boolean | CourseCountOutputTypeCountCourseStructureArgs
    CourseTask?: boolean | CourseCountOutputTypeCountCourseTaskArgs
    Module?: boolean | CourseCountOutputTypeCountModuleArgs
    LessonCard?: boolean | CourseCountOutputTypeCountLessonCardArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCourse_adviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseAdviceWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCourseStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseStructureWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCourseTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTaskWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountModuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountLessonCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonCardWhereInput
  }


  /**
   * Count Type CourseTaskCountOutputType
   */

  export type CourseTaskCountOutputType = {
    ClassTask: number
  }

  export type CourseTaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ClassTask?: boolean | CourseTaskCountOutputTypeCountClassTaskArgs
  }

  // Custom InputTypes
  /**
   * CourseTaskCountOutputType without action
   */
  export type CourseTaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTaskCountOutputType
     */
    select?: CourseTaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseTaskCountOutputType without action
   */
  export type CourseTaskCountOutputTypeCountClassTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassTaskWhereInput
  }


  /**
   * Count Type CourseLevelCountOutputType
   */

  export type CourseLevelCountOutputType = {
    course: number
    CourseLevelsPerSubject: number
  }

  export type CourseLevelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseLevelCountOutputTypeCountCourseArgs
    CourseLevelsPerSubject?: boolean | CourseLevelCountOutputTypeCountCourseLevelsPerSubjectArgs
  }

  // Custom InputTypes
  /**
   * CourseLevelCountOutputType without action
   */
  export type CourseLevelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevelCountOutputType
     */
    select?: CourseLevelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseLevelCountOutputType without action
   */
  export type CourseLevelCountOutputTypeCountCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * CourseLevelCountOutputType without action
   */
  export type CourseLevelCountOutputTypeCountCourseLevelsPerSubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseLevelsPerSubjectWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    Course: number
    CourseLevelsPerSubject: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Course?: boolean | SubjectCountOutputTypeCountCourseArgs
    CourseLevelsPerSubject?: boolean | SubjectCountOutputTypeCountCourseLevelsPerSubjectArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountCourseLevelsPerSubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseLevelsPerSubjectWhereInput
  }


  /**
   * Count Type LessonCountOutputType
   */

  export type LessonCountOutputType = {
    tasks: number
    CourseStructure: number
    CourseTask: number
    LessonCard: number
    UserCard: number
  }

  export type LessonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | LessonCountOutputTypeCountTasksArgs
    CourseStructure?: boolean | LessonCountOutputTypeCountCourseStructureArgs
    CourseTask?: boolean | LessonCountOutputTypeCountCourseTaskArgs
    LessonCard?: boolean | LessonCountOutputTypeCountLessonCardArgs
    UserCard?: boolean | LessonCountOutputTypeCountUserCardArgs
  }

  // Custom InputTypes
  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCountOutputType
     */
    select?: LessonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountCourseStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseStructureWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountCourseTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTaskWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountLessonCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonCardWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountUserCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCardWhereInput
  }


  /**
   * Count Type MentorCountOutputType
   */

  export type MentorCountOutputType = {
    mentor_classes: number
    MentorPayModel: number
  }

  export type MentorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentor_classes?: boolean | MentorCountOutputTypeCountMentor_classesArgs
    MentorPayModel?: boolean | MentorCountOutputTypeCountMentorPayModelArgs
  }

  // Custom InputTypes
  /**
   * MentorCountOutputType without action
   */
  export type MentorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorCountOutputType
     */
    select?: MentorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MentorCountOutputType without action
   */
  export type MentorCountOutputTypeCountMentor_classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorsClassesWhereInput
  }

  /**
   * MentorCountOutputType without action
   */
  export type MentorCountOutputTypeCountMentorPayModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorPayModelWhereInput
  }


  /**
   * Count Type ModuleCountOutputType
   */

  export type ModuleCountOutputType = {
    sections: number
    lessons: number
    CourseStructure: number
    CourseTask: number
  }

  export type ModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | ModuleCountOutputTypeCountSectionsArgs
    lessons?: boolean | ModuleCountOutputTypeCountLessonsArgs
    CourseStructure?: boolean | ModuleCountOutputTypeCountCourseStructureArgs
    CourseTask?: boolean | ModuleCountOutputTypeCountCourseTaskArgs
  }

  // Custom InputTypes
  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     */
    select?: ModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountCourseStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseStructureWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountCourseTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTaskWhereInput
  }


  /**
   * Count Type SectionCountOutputType
   */

  export type SectionCountOutputType = {
    CourseStructure: number
    CourseTask: number
    Lesson: number
  }

  export type SectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CourseStructure?: boolean | SectionCountOutputTypeCountCourseStructureArgs
    CourseTask?: boolean | SectionCountOutputTypeCountCourseTaskArgs
    Lesson?: boolean | SectionCountOutputTypeCountLessonArgs
  }

  // Custom InputTypes
  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionCountOutputType
     */
    select?: SectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountCourseStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseStructureWhereInput
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountCourseTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTaskWhereInput
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountLessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }


  /**
   * Count Type TimeOfDayCountOutputType
   */

  export type TimeOfDayCountOutputType = {
    classes: number
  }

  export type TimeOfDayCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | TimeOfDayCountOutputTypeCountClassesArgs
  }

  // Custom InputTypes
  /**
   * TimeOfDayCountOutputType without action
   */
  export type TimeOfDayCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeOfDayCountOutputType
     */
    select?: TimeOfDayCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TimeOfDayCountOutputType without action
   */
  export type TimeOfDayCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }


  /**
   * Count Type TuitionLangCountOutputType
   */

  export type TuitionLangCountOutputType = {
    classes: number
  }

  export type TuitionLangCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | TuitionLangCountOutputTypeCountClassesArgs
  }

  // Custom InputTypes
  /**
   * TuitionLangCountOutputType without action
   */
  export type TuitionLangCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuitionLangCountOutputType
     */
    select?: TuitionLangCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TuitionLangCountOutputType without action
   */
  export type TuitionLangCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }


  /**
   * Count Type DeckCountOutputType
   */

  export type DeckCountOutputType = {
    Card: number
  }

  export type DeckCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Card?: boolean | DeckCountOutputTypeCountCardArgs
  }

  // Custom InputTypes
  /**
   * DeckCountOutputType without action
   */
  export type DeckCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeckCountOutputType
     */
    select?: DeckCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeckCountOutputType without action
   */
  export type DeckCountOutputTypeCountCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonCardWhereInput
  }


  /**
   * Count Type ClassTaskCountOutputType
   */

  export type ClassTaskCountOutputType = {
    student_tasks: number
    student_answer: number
  }

  export type ClassTaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student_tasks?: boolean | ClassTaskCountOutputTypeCountStudent_tasksArgs
    student_answer?: boolean | ClassTaskCountOutputTypeCountStudent_answerArgs
  }

  // Custom InputTypes
  /**
   * ClassTaskCountOutputType without action
   */
  export type ClassTaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassTaskCountOutputType
     */
    select?: ClassTaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassTaskCountOutputType without action
   */
  export type ClassTaskCountOutputTypeCountStudent_tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTaskWhereInput
  }

  /**
   * ClassTaskCountOutputType without action
   */
  export type ClassTaskCountOutputTypeCountStudent_answerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAnswerWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    student_task: number
    student_answers: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student_task?: boolean | StudentCountOutputTypeCountStudent_taskArgs
    student_answers?: boolean | StudentCountOutputTypeCountStudent_answersArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudent_taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTaskWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudent_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAnswerWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    task_forms: number
    task_options: number
    CourseTask: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_forms?: boolean | TaskCountOutputTypeCountTask_formsArgs
    task_options?: boolean | TaskCountOutputTypeCountTask_optionsArgs
    CourseTask?: boolean | TaskCountOutputTypeCountCourseTaskArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTask_formsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskFormWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountTask_optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskOptionWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountCourseTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTaskWhereInput
  }


  /**
   * Count Type TaskFormCountOutputType
   */

  export type TaskFormCountOutputType = {
    task: number
  }

  export type TaskFormCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskFormCountOutputTypeCountTaskArgs
  }

  // Custom InputTypes
  /**
   * TaskFormCountOutputType without action
   */
  export type TaskFormCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskFormCountOutputType
     */
    select?: TaskFormCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskFormCountOutputType without action
   */
  export type TaskFormCountOutputTypeCountTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type TaskContextCountOutputType
   */

  export type TaskContextCountOutputType = {
    task: number
  }

  export type TaskContextCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskContextCountOutputTypeCountTaskArgs
  }

  // Custom InputTypes
  /**
   * TaskContextCountOutputType without action
   */
  export type TaskContextCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskContextCountOutputType
     */
    select?: TaskContextCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskContextCountOutputType without action
   */
  export type TaskContextCountOutputTypeCountTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type TaskTypeCountOutputType
   */

  export type TaskTypeCountOutputType = {
    task: number
  }

  export type TaskTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskTypeCountOutputTypeCountTaskArgs
  }

  // Custom InputTypes
  /**
   * TaskTypeCountOutputType without action
   */
  export type TaskTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskTypeCountOutputType
     */
    select?: TaskTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskTypeCountOutputType without action
   */
  export type TaskTypeCountOutputTypeCountTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    user_email: string | null
    created_at: Date | null
    updated_at: Date | null
    first_name: string | null
    last_name: string | null
    nickname: string | null
    deleted: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    user_email: string | null
    created_at: Date | null
    updated_at: Date | null
    first_name: string | null
    last_name: string | null
    nickname: string | null
    deleted: boolean | null
  }

  export type UserCountAggregateOutputType = {
    user_email: number
    created_at: number
    updated_at: number
    first_name: number
    last_name: number
    nickname: number
    deleted: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    user_email?: true
    created_at?: true
    updated_at?: true
    first_name?: true
    last_name?: true
    nickname?: true
    deleted?: true
  }

  export type UserMaxAggregateInputType = {
    user_email?: true
    created_at?: true
    updated_at?: true
    first_name?: true
    last_name?: true
    nickname?: true
    deleted?: true
  }

  export type UserCountAggregateInputType = {
    user_email?: true
    created_at?: true
    updated_at?: true
    first_name?: true
    last_name?: true
    nickname?: true
    deleted?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    user_email: string
    created_at: Date
    updated_at: Date | null
    first_name: string
    last_name: string
    nickname: string | null
    deleted: boolean
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_email?: boolean
    created_at?: boolean
    updated_at?: boolean
    first_name?: boolean
    last_name?: boolean
    nickname?: boolean
    deleted?: boolean
    user_roles?: boolean | User$user_rolesArgs<ExtArgs>
    user_application_preferences?: boolean | User$user_application_preferencesArgs<ExtArgs>
    mentor?: boolean | User$mentorArgs<ExtArgs>
    is_student_of?: boolean | User$is_student_ofArgs<ExtArgs>
    DataRemovalRequest?: boolean | User$DataRemovalRequestArgs<ExtArgs>
    Deck?: boolean | User$DeckArgs<ExtArgs>
    UserCard?: boolean | User$UserCardArgs<ExtArgs>
    VocabularyInbox?: boolean | User$VocabularyInboxArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_email?: boolean
    created_at?: boolean
    updated_at?: boolean
    first_name?: boolean
    last_name?: boolean
    nickname?: boolean
    deleted?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    user_email?: boolean
    created_at?: boolean
    updated_at?: boolean
    first_name?: boolean
    last_name?: boolean
    nickname?: boolean
    deleted?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_roles?: boolean | User$user_rolesArgs<ExtArgs>
    user_application_preferences?: boolean | User$user_application_preferencesArgs<ExtArgs>
    mentor?: boolean | User$mentorArgs<ExtArgs>
    is_student_of?: boolean | User$is_student_ofArgs<ExtArgs>
    DataRemovalRequest?: boolean | User$DataRemovalRequestArgs<ExtArgs>
    Deck?: boolean | User$DeckArgs<ExtArgs>
    UserCard?: boolean | User$UserCardArgs<ExtArgs>
    VocabularyInbox?: boolean | User$VocabularyInboxArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      user_roles: Prisma.$UserRolePayload<ExtArgs>[]
      user_application_preferences: Prisma.$UserApplicationPreferencesPayload<ExtArgs>[]
      mentor: Prisma.$MentorPayload<ExtArgs>[]
      is_student_of: Prisma.$StudentPayload<ExtArgs>[]
      DataRemovalRequest: Prisma.$DataRemovalRequestPayload<ExtArgs>[]
      Deck: Prisma.$DeckPayload<ExtArgs>[]
      UserCard: Prisma.$UserCardPayload<ExtArgs>[]
      VocabularyInbox: Prisma.$VocabularyInboxPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      user_email: string
      created_at: Date
      updated_at: Date | null
      first_name: string
      last_name: string
      nickname: string | null
      /**
       * This field is used to soft delete the user
       */
      deleted: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `user_email`
     * const userWithUser_emailOnly = await prisma.user.findMany({ select: { user_email: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `user_email`
     * const userWithUser_emailOnly = await prisma.user.createManyAndReturn({ 
     *   select: { user_email: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_roles<T extends User$user_rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$user_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    user_application_preferences<T extends User$user_application_preferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$user_application_preferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserApplicationPreferencesPayload<ExtArgs>, T, "findMany"> | Null>
    mentor<T extends User$mentorArgs<ExtArgs> = {}>(args?: Subset<T, User$mentorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "findMany"> | Null>
    is_student_of<T extends User$is_student_ofArgs<ExtArgs> = {}>(args?: Subset<T, User$is_student_ofArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany"> | Null>
    DataRemovalRequest<T extends User$DataRemovalRequestArgs<ExtArgs> = {}>(args?: Subset<T, User$DataRemovalRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRemovalRequestPayload<ExtArgs>, T, "findMany"> | Null>
    Deck<T extends User$DeckArgs<ExtArgs> = {}>(args?: Subset<T, User$DeckArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeckPayload<ExtArgs>, T, "findMany"> | Null>
    UserCard<T extends User$UserCardArgs<ExtArgs> = {}>(args?: Subset<T, User$UserCardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "findMany"> | Null>
    VocabularyInbox<T extends User$VocabularyInboxArgs<ExtArgs> = {}>(args?: Subset<T, User$VocabularyInboxArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VocabularyInboxPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly user_email: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
    readonly first_name: FieldRef<"User", 'String'>
    readonly last_name: FieldRef<"User", 'String'>
    readonly nickname: FieldRef<"User", 'String'>
    readonly deleted: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.user_roles
   */
  export type User$user_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.user_application_preferences
   */
  export type User$user_application_preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApplicationPreferences
     */
    select?: UserApplicationPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplicationPreferencesInclude<ExtArgs> | null
    where?: UserApplicationPreferencesWhereInput
    orderBy?: UserApplicationPreferencesOrderByWithRelationInput | UserApplicationPreferencesOrderByWithRelationInput[]
    cursor?: UserApplicationPreferencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserApplicationPreferencesScalarFieldEnum | UserApplicationPreferencesScalarFieldEnum[]
  }

  /**
   * User.mentor
   */
  export type User$mentorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    where?: MentorWhereInput
    orderBy?: MentorOrderByWithRelationInput | MentorOrderByWithRelationInput[]
    cursor?: MentorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorScalarFieldEnum | MentorScalarFieldEnum[]
  }

  /**
   * User.is_student_of
   */
  export type User$is_student_ofArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * User.DataRemovalRequest
   */
  export type User$DataRemovalRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRemovalRequest
     */
    select?: DataRemovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRemovalRequestInclude<ExtArgs> | null
    where?: DataRemovalRequestWhereInput
    orderBy?: DataRemovalRequestOrderByWithRelationInput | DataRemovalRequestOrderByWithRelationInput[]
    cursor?: DataRemovalRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataRemovalRequestScalarFieldEnum | DataRemovalRequestScalarFieldEnum[]
  }

  /**
   * User.Deck
   */
  export type User$DeckArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deck
     */
    select?: DeckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeckInclude<ExtArgs> | null
    where?: DeckWhereInput
    orderBy?: DeckOrderByWithRelationInput | DeckOrderByWithRelationInput[]
    cursor?: DeckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeckScalarFieldEnum | DeckScalarFieldEnum[]
  }

  /**
   * User.UserCard
   */
  export type User$UserCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    where?: UserCardWhereInput
    orderBy?: UserCardOrderByWithRelationInput | UserCardOrderByWithRelationInput[]
    cursor?: UserCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCardScalarFieldEnum | UserCardScalarFieldEnum[]
  }

  /**
   * User.VocabularyInbox
   */
  export type User$VocabularyInboxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyInbox
     */
    select?: VocabularyInboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInboxInclude<ExtArgs> | null
    where?: VocabularyInboxWhereInput
    orderBy?: VocabularyInboxOrderByWithRelationInput | VocabularyInboxOrderByWithRelationInput[]
    cursor?: VocabularyInboxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VocabularyInboxScalarFieldEnum | VocabularyInboxScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    role_id: string | null
    role_name: string | null
    role_description: string | null
  }

  export type RoleMaxAggregateOutputType = {
    role_id: string | null
    role_name: string | null
    role_description: string | null
  }

  export type RoleCountAggregateOutputType = {
    role_id: number
    role_name: number
    role_description: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    role_id?: true
    role_name?: true
    role_description?: true
  }

  export type RoleMaxAggregateInputType = {
    role_id?: true
    role_name?: true
    role_description?: true
  }

  export type RoleCountAggregateInputType = {
    role_id?: true
    role_name?: true
    role_description?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    role_id: string
    role_name: string | null
    role_description: string | null
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    role_name?: boolean
    role_description?: boolean
    user_roles?: boolean | Role$user_rolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    role_name?: boolean
    role_description?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    role_id?: boolean
    role_name?: boolean
    role_description?: boolean
  }

  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_roles?: boolean | Role$user_rolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      user_roles: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      role_id: string
      role_name: string | null
      role_description: string | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const roleWithRole_idOnly = await prisma.role.findMany({ select: { role_id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `role_id`
     * const roleWithRole_idOnly = await prisma.role.createManyAndReturn({ 
     *   select: { role_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_roles<T extends Role$user_rolesArgs<ExtArgs> = {}>(args?: Subset<T, Role$user_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly role_id: FieldRef<"Role", 'String'>
    readonly role_name: FieldRef<"Role", 'String'>
    readonly role_description: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.user_roles
   */
  export type Role$user_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    user_email: string | null
    role_id: string | null
  }

  export type UserRoleMaxAggregateOutputType = {
    user_email: string | null
    role_id: string | null
  }

  export type UserRoleCountAggregateOutputType = {
    user_email: number
    role_id: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    user_email?: true
    role_id?: true
  }

  export type UserRoleMaxAggregateInputType = {
    user_email?: true
    role_id?: true
  }

  export type UserRoleCountAggregateInputType = {
    user_email?: true
    role_id?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    user_email: string
    role_id: string
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_email?: boolean
    role_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_email?: boolean
    role_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    user_email?: boolean
    role_id?: boolean
  }

  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_email: string
      role_id: string
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `user_email`
     * const userRoleWithUser_emailOnly = await prisma.userRole.findMany({ select: { user_email: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `user_email`
     * const userRoleWithUser_emailOnly = await prisma.userRole.createManyAndReturn({ 
     *   select: { user_email: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */ 
  interface UserRoleFieldRefs {
    readonly user_email: FieldRef<"UserRole", 'String'>
    readonly role_id: FieldRef<"UserRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model UserApplicationPreferences
   */

  export type AggregateUserApplicationPreferences = {
    _count: UserApplicationPreferencesCountAggregateOutputType | null
    _min: UserApplicationPreferencesMinAggregateOutputType | null
    _max: UserApplicationPreferencesMaxAggregateOutputType | null
  }

  export type UserApplicationPreferencesMinAggregateOutputType = {
    user_email: string | null
    application_id: string | null
    accepted_privacy_policy: boolean | null
    accepted_cookies_policy: boolean | null
  }

  export type UserApplicationPreferencesMaxAggregateOutputType = {
    user_email: string | null
    application_id: string | null
    accepted_privacy_policy: boolean | null
    accepted_cookies_policy: boolean | null
  }

  export type UserApplicationPreferencesCountAggregateOutputType = {
    user_email: number
    application_id: number
    accepted_privacy_policy: number
    accepted_cookies_policy: number
    _all: number
  }


  export type UserApplicationPreferencesMinAggregateInputType = {
    user_email?: true
    application_id?: true
    accepted_privacy_policy?: true
    accepted_cookies_policy?: true
  }

  export type UserApplicationPreferencesMaxAggregateInputType = {
    user_email?: true
    application_id?: true
    accepted_privacy_policy?: true
    accepted_cookies_policy?: true
  }

  export type UserApplicationPreferencesCountAggregateInputType = {
    user_email?: true
    application_id?: true
    accepted_privacy_policy?: true
    accepted_cookies_policy?: true
    _all?: true
  }

  export type UserApplicationPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserApplicationPreferences to aggregate.
     */
    where?: UserApplicationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserApplicationPreferences to fetch.
     */
    orderBy?: UserApplicationPreferencesOrderByWithRelationInput | UserApplicationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserApplicationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserApplicationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserApplicationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserApplicationPreferences
    **/
    _count?: true | UserApplicationPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserApplicationPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserApplicationPreferencesMaxAggregateInputType
  }

  export type GetUserApplicationPreferencesAggregateType<T extends UserApplicationPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserApplicationPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserApplicationPreferences[P]>
      : GetScalarType<T[P], AggregateUserApplicationPreferences[P]>
  }




  export type UserApplicationPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserApplicationPreferencesWhereInput
    orderBy?: UserApplicationPreferencesOrderByWithAggregationInput | UserApplicationPreferencesOrderByWithAggregationInput[]
    by: UserApplicationPreferencesScalarFieldEnum[] | UserApplicationPreferencesScalarFieldEnum
    having?: UserApplicationPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserApplicationPreferencesCountAggregateInputType | true
    _min?: UserApplicationPreferencesMinAggregateInputType
    _max?: UserApplicationPreferencesMaxAggregateInputType
  }

  export type UserApplicationPreferencesGroupByOutputType = {
    user_email: string
    application_id: string
    accepted_privacy_policy: boolean
    accepted_cookies_policy: boolean
    _count: UserApplicationPreferencesCountAggregateOutputType | null
    _min: UserApplicationPreferencesMinAggregateOutputType | null
    _max: UserApplicationPreferencesMaxAggregateOutputType | null
  }

  type GetUserApplicationPreferencesGroupByPayload<T extends UserApplicationPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserApplicationPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserApplicationPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserApplicationPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], UserApplicationPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type UserApplicationPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_email?: boolean
    application_id?: boolean
    accepted_privacy_policy?: boolean
    accepted_cookies_policy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userApplicationPreferences"]>

  export type UserApplicationPreferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_email?: boolean
    application_id?: boolean
    accepted_privacy_policy?: boolean
    accepted_cookies_policy?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userApplicationPreferences"]>

  export type UserApplicationPreferencesSelectScalar = {
    user_email?: boolean
    application_id?: boolean
    accepted_privacy_policy?: boolean
    accepted_cookies_policy?: boolean
  }

  export type UserApplicationPreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }
  export type UserApplicationPreferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    application?: boolean | ApplicationDefaultArgs<ExtArgs>
  }

  export type $UserApplicationPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserApplicationPreferences"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      application: Prisma.$ApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_email: string
      application_id: string
      accepted_privacy_policy: boolean
      accepted_cookies_policy: boolean
    }, ExtArgs["result"]["userApplicationPreferences"]>
    composites: {}
  }

  type UserApplicationPreferencesGetPayload<S extends boolean | null | undefined | UserApplicationPreferencesDefaultArgs> = $Result.GetResult<Prisma.$UserApplicationPreferencesPayload, S>

  type UserApplicationPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserApplicationPreferencesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserApplicationPreferencesCountAggregateInputType | true
    }

  export interface UserApplicationPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserApplicationPreferences'], meta: { name: 'UserApplicationPreferences' } }
    /**
     * Find zero or one UserApplicationPreferences that matches the filter.
     * @param {UserApplicationPreferencesFindUniqueArgs} args - Arguments to find a UserApplicationPreferences
     * @example
     * // Get one UserApplicationPreferences
     * const userApplicationPreferences = await prisma.userApplicationPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserApplicationPreferencesFindUniqueArgs>(args: SelectSubset<T, UserApplicationPreferencesFindUniqueArgs<ExtArgs>>): Prisma__UserApplicationPreferencesClient<$Result.GetResult<Prisma.$UserApplicationPreferencesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserApplicationPreferences that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserApplicationPreferencesFindUniqueOrThrowArgs} args - Arguments to find a UserApplicationPreferences
     * @example
     * // Get one UserApplicationPreferences
     * const userApplicationPreferences = await prisma.userApplicationPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserApplicationPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserApplicationPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserApplicationPreferencesClient<$Result.GetResult<Prisma.$UserApplicationPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserApplicationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApplicationPreferencesFindFirstArgs} args - Arguments to find a UserApplicationPreferences
     * @example
     * // Get one UserApplicationPreferences
     * const userApplicationPreferences = await prisma.userApplicationPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserApplicationPreferencesFindFirstArgs>(args?: SelectSubset<T, UserApplicationPreferencesFindFirstArgs<ExtArgs>>): Prisma__UserApplicationPreferencesClient<$Result.GetResult<Prisma.$UserApplicationPreferencesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserApplicationPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApplicationPreferencesFindFirstOrThrowArgs} args - Arguments to find a UserApplicationPreferences
     * @example
     * // Get one UserApplicationPreferences
     * const userApplicationPreferences = await prisma.userApplicationPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserApplicationPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserApplicationPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserApplicationPreferencesClient<$Result.GetResult<Prisma.$UserApplicationPreferencesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserApplicationPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApplicationPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserApplicationPreferences
     * const userApplicationPreferences = await prisma.userApplicationPreferences.findMany()
     * 
     * // Get first 10 UserApplicationPreferences
     * const userApplicationPreferences = await prisma.userApplicationPreferences.findMany({ take: 10 })
     * 
     * // Only select the `user_email`
     * const userApplicationPreferencesWithUser_emailOnly = await prisma.userApplicationPreferences.findMany({ select: { user_email: true } })
     * 
     */
    findMany<T extends UserApplicationPreferencesFindManyArgs>(args?: SelectSubset<T, UserApplicationPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserApplicationPreferencesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserApplicationPreferences.
     * @param {UserApplicationPreferencesCreateArgs} args - Arguments to create a UserApplicationPreferences.
     * @example
     * // Create one UserApplicationPreferences
     * const UserApplicationPreferences = await prisma.userApplicationPreferences.create({
     *   data: {
     *     // ... data to create a UserApplicationPreferences
     *   }
     * })
     * 
     */
    create<T extends UserApplicationPreferencesCreateArgs>(args: SelectSubset<T, UserApplicationPreferencesCreateArgs<ExtArgs>>): Prisma__UserApplicationPreferencesClient<$Result.GetResult<Prisma.$UserApplicationPreferencesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserApplicationPreferences.
     * @param {UserApplicationPreferencesCreateManyArgs} args - Arguments to create many UserApplicationPreferences.
     * @example
     * // Create many UserApplicationPreferences
     * const userApplicationPreferences = await prisma.userApplicationPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserApplicationPreferencesCreateManyArgs>(args?: SelectSubset<T, UserApplicationPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserApplicationPreferences and returns the data saved in the database.
     * @param {UserApplicationPreferencesCreateManyAndReturnArgs} args - Arguments to create many UserApplicationPreferences.
     * @example
     * // Create many UserApplicationPreferences
     * const userApplicationPreferences = await prisma.userApplicationPreferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserApplicationPreferences and only return the `user_email`
     * const userApplicationPreferencesWithUser_emailOnly = await prisma.userApplicationPreferences.createManyAndReturn({ 
     *   select: { user_email: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserApplicationPreferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, UserApplicationPreferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserApplicationPreferencesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserApplicationPreferences.
     * @param {UserApplicationPreferencesDeleteArgs} args - Arguments to delete one UserApplicationPreferences.
     * @example
     * // Delete one UserApplicationPreferences
     * const UserApplicationPreferences = await prisma.userApplicationPreferences.delete({
     *   where: {
     *     // ... filter to delete one UserApplicationPreferences
     *   }
     * })
     * 
     */
    delete<T extends UserApplicationPreferencesDeleteArgs>(args: SelectSubset<T, UserApplicationPreferencesDeleteArgs<ExtArgs>>): Prisma__UserApplicationPreferencesClient<$Result.GetResult<Prisma.$UserApplicationPreferencesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserApplicationPreferences.
     * @param {UserApplicationPreferencesUpdateArgs} args - Arguments to update one UserApplicationPreferences.
     * @example
     * // Update one UserApplicationPreferences
     * const userApplicationPreferences = await prisma.userApplicationPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserApplicationPreferencesUpdateArgs>(args: SelectSubset<T, UserApplicationPreferencesUpdateArgs<ExtArgs>>): Prisma__UserApplicationPreferencesClient<$Result.GetResult<Prisma.$UserApplicationPreferencesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserApplicationPreferences.
     * @param {UserApplicationPreferencesDeleteManyArgs} args - Arguments to filter UserApplicationPreferences to delete.
     * @example
     * // Delete a few UserApplicationPreferences
     * const { count } = await prisma.userApplicationPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserApplicationPreferencesDeleteManyArgs>(args?: SelectSubset<T, UserApplicationPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserApplicationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApplicationPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserApplicationPreferences
     * const userApplicationPreferences = await prisma.userApplicationPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserApplicationPreferencesUpdateManyArgs>(args: SelectSubset<T, UserApplicationPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserApplicationPreferences.
     * @param {UserApplicationPreferencesUpsertArgs} args - Arguments to update or create a UserApplicationPreferences.
     * @example
     * // Update or create a UserApplicationPreferences
     * const userApplicationPreferences = await prisma.userApplicationPreferences.upsert({
     *   create: {
     *     // ... data to create a UserApplicationPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserApplicationPreferences we want to update
     *   }
     * })
     */
    upsert<T extends UserApplicationPreferencesUpsertArgs>(args: SelectSubset<T, UserApplicationPreferencesUpsertArgs<ExtArgs>>): Prisma__UserApplicationPreferencesClient<$Result.GetResult<Prisma.$UserApplicationPreferencesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserApplicationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApplicationPreferencesCountArgs} args - Arguments to filter UserApplicationPreferences to count.
     * @example
     * // Count the number of UserApplicationPreferences
     * const count = await prisma.userApplicationPreferences.count({
     *   where: {
     *     // ... the filter for the UserApplicationPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserApplicationPreferencesCountArgs>(
      args?: Subset<T, UserApplicationPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserApplicationPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserApplicationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApplicationPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserApplicationPreferencesAggregateArgs>(args: Subset<T, UserApplicationPreferencesAggregateArgs>): Prisma.PrismaPromise<GetUserApplicationPreferencesAggregateType<T>>

    /**
     * Group by UserApplicationPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserApplicationPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserApplicationPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserApplicationPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: UserApplicationPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserApplicationPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserApplicationPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserApplicationPreferences model
   */
  readonly fields: UserApplicationPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserApplicationPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserApplicationPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    application<T extends ApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApplicationDefaultArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserApplicationPreferences model
   */ 
  interface UserApplicationPreferencesFieldRefs {
    readonly user_email: FieldRef<"UserApplicationPreferences", 'String'>
    readonly application_id: FieldRef<"UserApplicationPreferences", 'String'>
    readonly accepted_privacy_policy: FieldRef<"UserApplicationPreferences", 'Boolean'>
    readonly accepted_cookies_policy: FieldRef<"UserApplicationPreferences", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UserApplicationPreferences findUnique
   */
  export type UserApplicationPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApplicationPreferences
     */
    select?: UserApplicationPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplicationPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserApplicationPreferences to fetch.
     */
    where: UserApplicationPreferencesWhereUniqueInput
  }

  /**
   * UserApplicationPreferences findUniqueOrThrow
   */
  export type UserApplicationPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApplicationPreferences
     */
    select?: UserApplicationPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplicationPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserApplicationPreferences to fetch.
     */
    where: UserApplicationPreferencesWhereUniqueInput
  }

  /**
   * UserApplicationPreferences findFirst
   */
  export type UserApplicationPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApplicationPreferences
     */
    select?: UserApplicationPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplicationPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserApplicationPreferences to fetch.
     */
    where?: UserApplicationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserApplicationPreferences to fetch.
     */
    orderBy?: UserApplicationPreferencesOrderByWithRelationInput | UserApplicationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserApplicationPreferences.
     */
    cursor?: UserApplicationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserApplicationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserApplicationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserApplicationPreferences.
     */
    distinct?: UserApplicationPreferencesScalarFieldEnum | UserApplicationPreferencesScalarFieldEnum[]
  }

  /**
   * UserApplicationPreferences findFirstOrThrow
   */
  export type UserApplicationPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApplicationPreferences
     */
    select?: UserApplicationPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplicationPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserApplicationPreferences to fetch.
     */
    where?: UserApplicationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserApplicationPreferences to fetch.
     */
    orderBy?: UserApplicationPreferencesOrderByWithRelationInput | UserApplicationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserApplicationPreferences.
     */
    cursor?: UserApplicationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserApplicationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserApplicationPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserApplicationPreferences.
     */
    distinct?: UserApplicationPreferencesScalarFieldEnum | UserApplicationPreferencesScalarFieldEnum[]
  }

  /**
   * UserApplicationPreferences findMany
   */
  export type UserApplicationPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApplicationPreferences
     */
    select?: UserApplicationPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplicationPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserApplicationPreferences to fetch.
     */
    where?: UserApplicationPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserApplicationPreferences to fetch.
     */
    orderBy?: UserApplicationPreferencesOrderByWithRelationInput | UserApplicationPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserApplicationPreferences.
     */
    cursor?: UserApplicationPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserApplicationPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserApplicationPreferences.
     */
    skip?: number
    distinct?: UserApplicationPreferencesScalarFieldEnum | UserApplicationPreferencesScalarFieldEnum[]
  }

  /**
   * UserApplicationPreferences create
   */
  export type UserApplicationPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApplicationPreferences
     */
    select?: UserApplicationPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplicationPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserApplicationPreferences.
     */
    data: XOR<UserApplicationPreferencesCreateInput, UserApplicationPreferencesUncheckedCreateInput>
  }

  /**
   * UserApplicationPreferences createMany
   */
  export type UserApplicationPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserApplicationPreferences.
     */
    data: UserApplicationPreferencesCreateManyInput | UserApplicationPreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserApplicationPreferences createManyAndReturn
   */
  export type UserApplicationPreferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApplicationPreferences
     */
    select?: UserApplicationPreferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserApplicationPreferences.
     */
    data: UserApplicationPreferencesCreateManyInput | UserApplicationPreferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplicationPreferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserApplicationPreferences update
   */
  export type UserApplicationPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApplicationPreferences
     */
    select?: UserApplicationPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplicationPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserApplicationPreferences.
     */
    data: XOR<UserApplicationPreferencesUpdateInput, UserApplicationPreferencesUncheckedUpdateInput>
    /**
     * Choose, which UserApplicationPreferences to update.
     */
    where: UserApplicationPreferencesWhereUniqueInput
  }

  /**
   * UserApplicationPreferences updateMany
   */
  export type UserApplicationPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserApplicationPreferences.
     */
    data: XOR<UserApplicationPreferencesUpdateManyMutationInput, UserApplicationPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserApplicationPreferences to update
     */
    where?: UserApplicationPreferencesWhereInput
  }

  /**
   * UserApplicationPreferences upsert
   */
  export type UserApplicationPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApplicationPreferences
     */
    select?: UserApplicationPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplicationPreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserApplicationPreferences to update in case it exists.
     */
    where: UserApplicationPreferencesWhereUniqueInput
    /**
     * In case the UserApplicationPreferences found by the `where` argument doesn't exist, create a new UserApplicationPreferences with this data.
     */
    create: XOR<UserApplicationPreferencesCreateInput, UserApplicationPreferencesUncheckedCreateInput>
    /**
     * In case the UserApplicationPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserApplicationPreferencesUpdateInput, UserApplicationPreferencesUncheckedUpdateInput>
  }

  /**
   * UserApplicationPreferences delete
   */
  export type UserApplicationPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApplicationPreferences
     */
    select?: UserApplicationPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplicationPreferencesInclude<ExtArgs> | null
    /**
     * Filter which UserApplicationPreferences to delete.
     */
    where: UserApplicationPreferencesWhereUniqueInput
  }

  /**
   * UserApplicationPreferences deleteMany
   */
  export type UserApplicationPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserApplicationPreferences to delete
     */
    where?: UserApplicationPreferencesWhereInput
  }

  /**
   * UserApplicationPreferences without action
   */
  export type UserApplicationPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApplicationPreferences
     */
    select?: UserApplicationPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplicationPreferencesInclude<ExtArgs> | null
  }


  /**
   * Model Application
   */

  export type AggregateApplication = {
    _count: ApplicationCountAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  export type ApplicationMinAggregateOutputType = {
    application_id: string | null
    application_name: string | null
    application_description: string | null
    application_url: string | null
  }

  export type ApplicationMaxAggregateOutputType = {
    application_id: string | null
    application_name: string | null
    application_description: string | null
    application_url: string | null
  }

  export type ApplicationCountAggregateOutputType = {
    application_id: number
    application_name: number
    application_description: number
    application_url: number
    _all: number
  }


  export type ApplicationMinAggregateInputType = {
    application_id?: true
    application_name?: true
    application_description?: true
    application_url?: true
  }

  export type ApplicationMaxAggregateInputType = {
    application_id?: true
    application_name?: true
    application_description?: true
    application_url?: true
  }

  export type ApplicationCountAggregateInputType = {
    application_id?: true
    application_name?: true
    application_description?: true
    application_url?: true
    _all?: true
  }

  export type ApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Application to aggregate.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Applications
    **/
    _count?: true | ApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationMaxAggregateInputType
  }

  export type GetApplicationAggregateType<T extends ApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplication[P]>
      : GetScalarType<T[P], AggregateApplication[P]>
  }




  export type ApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithAggregationInput | ApplicationOrderByWithAggregationInput[]
    by: ApplicationScalarFieldEnum[] | ApplicationScalarFieldEnum
    having?: ApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationCountAggregateInputType | true
    _min?: ApplicationMinAggregateInputType
    _max?: ApplicationMaxAggregateInputType
  }

  export type ApplicationGroupByOutputType = {
    application_id: string
    application_name: string
    application_description: string | null
    application_url: string | null
    _count: ApplicationCountAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  type GetApplicationGroupByPayload<T extends ApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
        }
      >
    >


  export type ApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    application_id?: boolean
    application_name?: boolean
    application_description?: boolean
    application_url?: boolean
    user_application_preferences?: boolean | Application$user_application_preferencesArgs<ExtArgs>
    _count?: boolean | ApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>

  export type ApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    application_id?: boolean
    application_name?: boolean
    application_description?: boolean
    application_url?: boolean
  }, ExtArgs["result"]["application"]>

  export type ApplicationSelectScalar = {
    application_id?: boolean
    application_name?: boolean
    application_description?: boolean
    application_url?: boolean
  }

  export type ApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_application_preferences?: boolean | Application$user_application_preferencesArgs<ExtArgs>
    _count?: boolean | ApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Application"
    objects: {
      user_application_preferences: Prisma.$UserApplicationPreferencesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * admin_portal, marketing_website, etc
       */
      application_id: string
      application_name: string
      application_description: string | null
      application_url: string | null
    }, ExtArgs["result"]["application"]>
    composites: {}
  }

  type ApplicationGetPayload<S extends boolean | null | undefined | ApplicationDefaultArgs> = $Result.GetResult<Prisma.$ApplicationPayload, S>

  type ApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApplicationCountAggregateInputType | true
    }

  export interface ApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Application'], meta: { name: 'Application' } }
    /**
     * Find zero or one Application that matches the filter.
     * @param {ApplicationFindUniqueArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationFindUniqueArgs>(args: SelectSubset<T, ApplicationFindUniqueArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Application that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApplicationFindUniqueOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Application that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationFindFirstArgs>(args?: SelectSubset<T, ApplicationFindFirstArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Application that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applications
     * const applications = await prisma.application.findMany()
     * 
     * // Get first 10 Applications
     * const applications = await prisma.application.findMany({ take: 10 })
     * 
     * // Only select the `application_id`
     * const applicationWithApplication_idOnly = await prisma.application.findMany({ select: { application_id: true } })
     * 
     */
    findMany<T extends ApplicationFindManyArgs>(args?: SelectSubset<T, ApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Application.
     * @param {ApplicationCreateArgs} args - Arguments to create a Application.
     * @example
     * // Create one Application
     * const Application = await prisma.application.create({
     *   data: {
     *     // ... data to create a Application
     *   }
     * })
     * 
     */
    create<T extends ApplicationCreateArgs>(args: SelectSubset<T, ApplicationCreateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Applications.
     * @param {ApplicationCreateManyArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicationCreateManyArgs>(args?: SelectSubset<T, ApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Applications and returns the data saved in the database.
     * @param {ApplicationCreateManyAndReturnArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Applications and only return the `application_id`
     * const applicationWithApplication_idOnly = await prisma.application.createManyAndReturn({ 
     *   select: { application_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, ApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Application.
     * @param {ApplicationDeleteArgs} args - Arguments to delete one Application.
     * @example
     * // Delete one Application
     * const Application = await prisma.application.delete({
     *   where: {
     *     // ... filter to delete one Application
     *   }
     * })
     * 
     */
    delete<T extends ApplicationDeleteArgs>(args: SelectSubset<T, ApplicationDeleteArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Application.
     * @param {ApplicationUpdateArgs} args - Arguments to update one Application.
     * @example
     * // Update one Application
     * const application = await prisma.application.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicationUpdateArgs>(args: SelectSubset<T, ApplicationUpdateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Applications.
     * @param {ApplicationDeleteManyArgs} args - Arguments to filter Applications to delete.
     * @example
     * // Delete a few Applications
     * const { count } = await prisma.application.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicationDeleteManyArgs>(args?: SelectSubset<T, ApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicationUpdateManyArgs>(args: SelectSubset<T, ApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Application.
     * @param {ApplicationUpsertArgs} args - Arguments to update or create a Application.
     * @example
     * // Update or create a Application
     * const application = await prisma.application.upsert({
     *   create: {
     *     // ... data to create a Application
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Application we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationUpsertArgs>(args: SelectSubset<T, ApplicationUpsertArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationCountArgs} args - Arguments to filter Applications to count.
     * @example
     * // Count the number of Applications
     * const count = await prisma.application.count({
     *   where: {
     *     // ... the filter for the Applications we want to count
     *   }
     * })
    **/
    count<T extends ApplicationCountArgs>(
      args?: Subset<T, ApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationAggregateArgs>(args: Subset<T, ApplicationAggregateArgs>): Prisma.PrismaPromise<GetApplicationAggregateType<T>>

    /**
     * Group by Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Application model
   */
  readonly fields: ApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Application.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_application_preferences<T extends Application$user_application_preferencesArgs<ExtArgs> = {}>(args?: Subset<T, Application$user_application_preferencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserApplicationPreferencesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Application model
   */ 
  interface ApplicationFieldRefs {
    readonly application_id: FieldRef<"Application", 'String'>
    readonly application_name: FieldRef<"Application", 'String'>
    readonly application_description: FieldRef<"Application", 'String'>
    readonly application_url: FieldRef<"Application", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Application findUnique
   */
  export type ApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findUniqueOrThrow
   */
  export type ApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findFirst
   */
  export type ApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findFirstOrThrow
   */
  export type ApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findMany
   */
  export type ApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Applications to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application create
   */
  export type ApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Application.
     */
    data: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
  }

  /**
   * Application createMany
   */
  export type ApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Application createManyAndReturn
   */
  export type ApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Application update
   */
  export type ApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Application.
     */
    data: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
    /**
     * Choose, which Application to update.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application updateMany
   */
  export type ApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput
  }

  /**
   * Application upsert
   */
  export type ApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Application to update in case it exists.
     */
    where: ApplicationWhereUniqueInput
    /**
     * In case the Application found by the `where` argument doesn't exist, create a new Application with this data.
     */
    create: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
    /**
     * In case the Application was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
  }

  /**
   * Application delete
   */
  export type ApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter which Application to delete.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application deleteMany
   */
  export type ApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Applications to delete
     */
    where?: ApplicationWhereInput
  }

  /**
   * Application.user_application_preferences
   */
  export type Application$user_application_preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserApplicationPreferences
     */
    select?: UserApplicationPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserApplicationPreferencesInclude<ExtArgs> | null
    where?: UserApplicationPreferencesWhereInput
    orderBy?: UserApplicationPreferencesOrderByWithRelationInput | UserApplicationPreferencesOrderByWithRelationInput[]
    cursor?: UserApplicationPreferencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserApplicationPreferencesScalarFieldEnum | UserApplicationPreferencesScalarFieldEnum[]
  }

  /**
   * Application without action
   */
  export type ApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
  }


  /**
   * Model DataRemovalRequest
   */

  export type AggregateDataRemovalRequest = {
    _count: DataRemovalRequestCountAggregateOutputType | null
    _avg: DataRemovalRequestAvgAggregateOutputType | null
    _sum: DataRemovalRequestSumAggregateOutputType | null
    _min: DataRemovalRequestMinAggregateOutputType | null
    _max: DataRemovalRequestMaxAggregateOutputType | null
  }

  export type DataRemovalRequestAvgAggregateOutputType = {
    data_removal_request_id: number | null
  }

  export type DataRemovalRequestSumAggregateOutputType = {
    data_removal_request_id: number | null
  }

  export type DataRemovalRequestMinAggregateOutputType = {
    data_removal_request_id: number | null
    user_email: string | null
    data_removal_request: string | null
    data_removal_status: $Enums.DataRemovalStatusEnum | null
    data_removal_date: Date | null
  }

  export type DataRemovalRequestMaxAggregateOutputType = {
    data_removal_request_id: number | null
    user_email: string | null
    data_removal_request: string | null
    data_removal_status: $Enums.DataRemovalStatusEnum | null
    data_removal_date: Date | null
  }

  export type DataRemovalRequestCountAggregateOutputType = {
    data_removal_request_id: number
    user_email: number
    data_removal_request: number
    data_removal_status: number
    data_removal_date: number
    _all: number
  }


  export type DataRemovalRequestAvgAggregateInputType = {
    data_removal_request_id?: true
  }

  export type DataRemovalRequestSumAggregateInputType = {
    data_removal_request_id?: true
  }

  export type DataRemovalRequestMinAggregateInputType = {
    data_removal_request_id?: true
    user_email?: true
    data_removal_request?: true
    data_removal_status?: true
    data_removal_date?: true
  }

  export type DataRemovalRequestMaxAggregateInputType = {
    data_removal_request_id?: true
    user_email?: true
    data_removal_request?: true
    data_removal_status?: true
    data_removal_date?: true
  }

  export type DataRemovalRequestCountAggregateInputType = {
    data_removal_request_id?: true
    user_email?: true
    data_removal_request?: true
    data_removal_status?: true
    data_removal_date?: true
    _all?: true
  }

  export type DataRemovalRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataRemovalRequest to aggregate.
     */
    where?: DataRemovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRemovalRequests to fetch.
     */
    orderBy?: DataRemovalRequestOrderByWithRelationInput | DataRemovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataRemovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRemovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRemovalRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataRemovalRequests
    **/
    _count?: true | DataRemovalRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataRemovalRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataRemovalRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataRemovalRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataRemovalRequestMaxAggregateInputType
  }

  export type GetDataRemovalRequestAggregateType<T extends DataRemovalRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateDataRemovalRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataRemovalRequest[P]>
      : GetScalarType<T[P], AggregateDataRemovalRequest[P]>
  }




  export type DataRemovalRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataRemovalRequestWhereInput
    orderBy?: DataRemovalRequestOrderByWithAggregationInput | DataRemovalRequestOrderByWithAggregationInput[]
    by: DataRemovalRequestScalarFieldEnum[] | DataRemovalRequestScalarFieldEnum
    having?: DataRemovalRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataRemovalRequestCountAggregateInputType | true
    _avg?: DataRemovalRequestAvgAggregateInputType
    _sum?: DataRemovalRequestSumAggregateInputType
    _min?: DataRemovalRequestMinAggregateInputType
    _max?: DataRemovalRequestMaxAggregateInputType
  }

  export type DataRemovalRequestGroupByOutputType = {
    data_removal_request_id: number
    user_email: string
    data_removal_request: string
    data_removal_status: $Enums.DataRemovalStatusEnum
    data_removal_date: Date
    _count: DataRemovalRequestCountAggregateOutputType | null
    _avg: DataRemovalRequestAvgAggregateOutputType | null
    _sum: DataRemovalRequestSumAggregateOutputType | null
    _min: DataRemovalRequestMinAggregateOutputType | null
    _max: DataRemovalRequestMaxAggregateOutputType | null
  }

  type GetDataRemovalRequestGroupByPayload<T extends DataRemovalRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataRemovalRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataRemovalRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataRemovalRequestGroupByOutputType[P]>
            : GetScalarType<T[P], DataRemovalRequestGroupByOutputType[P]>
        }
      >
    >


  export type DataRemovalRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    data_removal_request_id?: boolean
    user_email?: boolean
    data_removal_request?: boolean
    data_removal_status?: boolean
    data_removal_date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataRemovalRequest"]>

  export type DataRemovalRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    data_removal_request_id?: boolean
    user_email?: boolean
    data_removal_request?: boolean
    data_removal_status?: boolean
    data_removal_date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataRemovalRequest"]>

  export type DataRemovalRequestSelectScalar = {
    data_removal_request_id?: boolean
    user_email?: boolean
    data_removal_request?: boolean
    data_removal_status?: boolean
    data_removal_date?: boolean
  }

  export type DataRemovalRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DataRemovalRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DataRemovalRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataRemovalRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      data_removal_request_id: number
      user_email: string
      data_removal_request: string
      data_removal_status: $Enums.DataRemovalStatusEnum
      data_removal_date: Date
    }, ExtArgs["result"]["dataRemovalRequest"]>
    composites: {}
  }

  type DataRemovalRequestGetPayload<S extends boolean | null | undefined | DataRemovalRequestDefaultArgs> = $Result.GetResult<Prisma.$DataRemovalRequestPayload, S>

  type DataRemovalRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DataRemovalRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DataRemovalRequestCountAggregateInputType | true
    }

  export interface DataRemovalRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataRemovalRequest'], meta: { name: 'DataRemovalRequest' } }
    /**
     * Find zero or one DataRemovalRequest that matches the filter.
     * @param {DataRemovalRequestFindUniqueArgs} args - Arguments to find a DataRemovalRequest
     * @example
     * // Get one DataRemovalRequest
     * const dataRemovalRequest = await prisma.dataRemovalRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataRemovalRequestFindUniqueArgs>(args: SelectSubset<T, DataRemovalRequestFindUniqueArgs<ExtArgs>>): Prisma__DataRemovalRequestClient<$Result.GetResult<Prisma.$DataRemovalRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DataRemovalRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DataRemovalRequestFindUniqueOrThrowArgs} args - Arguments to find a DataRemovalRequest
     * @example
     * // Get one DataRemovalRequest
     * const dataRemovalRequest = await prisma.dataRemovalRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataRemovalRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, DataRemovalRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataRemovalRequestClient<$Result.GetResult<Prisma.$DataRemovalRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DataRemovalRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRemovalRequestFindFirstArgs} args - Arguments to find a DataRemovalRequest
     * @example
     * // Get one DataRemovalRequest
     * const dataRemovalRequest = await prisma.dataRemovalRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataRemovalRequestFindFirstArgs>(args?: SelectSubset<T, DataRemovalRequestFindFirstArgs<ExtArgs>>): Prisma__DataRemovalRequestClient<$Result.GetResult<Prisma.$DataRemovalRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DataRemovalRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRemovalRequestFindFirstOrThrowArgs} args - Arguments to find a DataRemovalRequest
     * @example
     * // Get one DataRemovalRequest
     * const dataRemovalRequest = await prisma.dataRemovalRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataRemovalRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, DataRemovalRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataRemovalRequestClient<$Result.GetResult<Prisma.$DataRemovalRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DataRemovalRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRemovalRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataRemovalRequests
     * const dataRemovalRequests = await prisma.dataRemovalRequest.findMany()
     * 
     * // Get first 10 DataRemovalRequests
     * const dataRemovalRequests = await prisma.dataRemovalRequest.findMany({ take: 10 })
     * 
     * // Only select the `data_removal_request_id`
     * const dataRemovalRequestWithData_removal_request_idOnly = await prisma.dataRemovalRequest.findMany({ select: { data_removal_request_id: true } })
     * 
     */
    findMany<T extends DataRemovalRequestFindManyArgs>(args?: SelectSubset<T, DataRemovalRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRemovalRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DataRemovalRequest.
     * @param {DataRemovalRequestCreateArgs} args - Arguments to create a DataRemovalRequest.
     * @example
     * // Create one DataRemovalRequest
     * const DataRemovalRequest = await prisma.dataRemovalRequest.create({
     *   data: {
     *     // ... data to create a DataRemovalRequest
     *   }
     * })
     * 
     */
    create<T extends DataRemovalRequestCreateArgs>(args: SelectSubset<T, DataRemovalRequestCreateArgs<ExtArgs>>): Prisma__DataRemovalRequestClient<$Result.GetResult<Prisma.$DataRemovalRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DataRemovalRequests.
     * @param {DataRemovalRequestCreateManyArgs} args - Arguments to create many DataRemovalRequests.
     * @example
     * // Create many DataRemovalRequests
     * const dataRemovalRequest = await prisma.dataRemovalRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataRemovalRequestCreateManyArgs>(args?: SelectSubset<T, DataRemovalRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataRemovalRequests and returns the data saved in the database.
     * @param {DataRemovalRequestCreateManyAndReturnArgs} args - Arguments to create many DataRemovalRequests.
     * @example
     * // Create many DataRemovalRequests
     * const dataRemovalRequest = await prisma.dataRemovalRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataRemovalRequests and only return the `data_removal_request_id`
     * const dataRemovalRequestWithData_removal_request_idOnly = await prisma.dataRemovalRequest.createManyAndReturn({ 
     *   select: { data_removal_request_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataRemovalRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, DataRemovalRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRemovalRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DataRemovalRequest.
     * @param {DataRemovalRequestDeleteArgs} args - Arguments to delete one DataRemovalRequest.
     * @example
     * // Delete one DataRemovalRequest
     * const DataRemovalRequest = await prisma.dataRemovalRequest.delete({
     *   where: {
     *     // ... filter to delete one DataRemovalRequest
     *   }
     * })
     * 
     */
    delete<T extends DataRemovalRequestDeleteArgs>(args: SelectSubset<T, DataRemovalRequestDeleteArgs<ExtArgs>>): Prisma__DataRemovalRequestClient<$Result.GetResult<Prisma.$DataRemovalRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DataRemovalRequest.
     * @param {DataRemovalRequestUpdateArgs} args - Arguments to update one DataRemovalRequest.
     * @example
     * // Update one DataRemovalRequest
     * const dataRemovalRequest = await prisma.dataRemovalRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataRemovalRequestUpdateArgs>(args: SelectSubset<T, DataRemovalRequestUpdateArgs<ExtArgs>>): Prisma__DataRemovalRequestClient<$Result.GetResult<Prisma.$DataRemovalRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DataRemovalRequests.
     * @param {DataRemovalRequestDeleteManyArgs} args - Arguments to filter DataRemovalRequests to delete.
     * @example
     * // Delete a few DataRemovalRequests
     * const { count } = await prisma.dataRemovalRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataRemovalRequestDeleteManyArgs>(args?: SelectSubset<T, DataRemovalRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataRemovalRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRemovalRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataRemovalRequests
     * const dataRemovalRequest = await prisma.dataRemovalRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataRemovalRequestUpdateManyArgs>(args: SelectSubset<T, DataRemovalRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataRemovalRequest.
     * @param {DataRemovalRequestUpsertArgs} args - Arguments to update or create a DataRemovalRequest.
     * @example
     * // Update or create a DataRemovalRequest
     * const dataRemovalRequest = await prisma.dataRemovalRequest.upsert({
     *   create: {
     *     // ... data to create a DataRemovalRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataRemovalRequest we want to update
     *   }
     * })
     */
    upsert<T extends DataRemovalRequestUpsertArgs>(args: SelectSubset<T, DataRemovalRequestUpsertArgs<ExtArgs>>): Prisma__DataRemovalRequestClient<$Result.GetResult<Prisma.$DataRemovalRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DataRemovalRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRemovalRequestCountArgs} args - Arguments to filter DataRemovalRequests to count.
     * @example
     * // Count the number of DataRemovalRequests
     * const count = await prisma.dataRemovalRequest.count({
     *   where: {
     *     // ... the filter for the DataRemovalRequests we want to count
     *   }
     * })
    **/
    count<T extends DataRemovalRequestCountArgs>(
      args?: Subset<T, DataRemovalRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataRemovalRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataRemovalRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRemovalRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataRemovalRequestAggregateArgs>(args: Subset<T, DataRemovalRequestAggregateArgs>): Prisma.PrismaPromise<GetDataRemovalRequestAggregateType<T>>

    /**
     * Group by DataRemovalRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRemovalRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataRemovalRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataRemovalRequestGroupByArgs['orderBy'] }
        : { orderBy?: DataRemovalRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataRemovalRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataRemovalRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataRemovalRequest model
   */
  readonly fields: DataRemovalRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataRemovalRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataRemovalRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataRemovalRequest model
   */ 
  interface DataRemovalRequestFieldRefs {
    readonly data_removal_request_id: FieldRef<"DataRemovalRequest", 'Int'>
    readonly user_email: FieldRef<"DataRemovalRequest", 'String'>
    readonly data_removal_request: FieldRef<"DataRemovalRequest", 'String'>
    readonly data_removal_status: FieldRef<"DataRemovalRequest", 'DataRemovalStatusEnum'>
    readonly data_removal_date: FieldRef<"DataRemovalRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataRemovalRequest findUnique
   */
  export type DataRemovalRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRemovalRequest
     */
    select?: DataRemovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRemovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataRemovalRequest to fetch.
     */
    where: DataRemovalRequestWhereUniqueInput
  }

  /**
   * DataRemovalRequest findUniqueOrThrow
   */
  export type DataRemovalRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRemovalRequest
     */
    select?: DataRemovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRemovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataRemovalRequest to fetch.
     */
    where: DataRemovalRequestWhereUniqueInput
  }

  /**
   * DataRemovalRequest findFirst
   */
  export type DataRemovalRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRemovalRequest
     */
    select?: DataRemovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRemovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataRemovalRequest to fetch.
     */
    where?: DataRemovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRemovalRequests to fetch.
     */
    orderBy?: DataRemovalRequestOrderByWithRelationInput | DataRemovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataRemovalRequests.
     */
    cursor?: DataRemovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRemovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRemovalRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataRemovalRequests.
     */
    distinct?: DataRemovalRequestScalarFieldEnum | DataRemovalRequestScalarFieldEnum[]
  }

  /**
   * DataRemovalRequest findFirstOrThrow
   */
  export type DataRemovalRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRemovalRequest
     */
    select?: DataRemovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRemovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataRemovalRequest to fetch.
     */
    where?: DataRemovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRemovalRequests to fetch.
     */
    orderBy?: DataRemovalRequestOrderByWithRelationInput | DataRemovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataRemovalRequests.
     */
    cursor?: DataRemovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRemovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRemovalRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataRemovalRequests.
     */
    distinct?: DataRemovalRequestScalarFieldEnum | DataRemovalRequestScalarFieldEnum[]
  }

  /**
   * DataRemovalRequest findMany
   */
  export type DataRemovalRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRemovalRequest
     */
    select?: DataRemovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRemovalRequestInclude<ExtArgs> | null
    /**
     * Filter, which DataRemovalRequests to fetch.
     */
    where?: DataRemovalRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRemovalRequests to fetch.
     */
    orderBy?: DataRemovalRequestOrderByWithRelationInput | DataRemovalRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataRemovalRequests.
     */
    cursor?: DataRemovalRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRemovalRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRemovalRequests.
     */
    skip?: number
    distinct?: DataRemovalRequestScalarFieldEnum | DataRemovalRequestScalarFieldEnum[]
  }

  /**
   * DataRemovalRequest create
   */
  export type DataRemovalRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRemovalRequest
     */
    select?: DataRemovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRemovalRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a DataRemovalRequest.
     */
    data: XOR<DataRemovalRequestCreateInput, DataRemovalRequestUncheckedCreateInput>
  }

  /**
   * DataRemovalRequest createMany
   */
  export type DataRemovalRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataRemovalRequests.
     */
    data: DataRemovalRequestCreateManyInput | DataRemovalRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataRemovalRequest createManyAndReturn
   */
  export type DataRemovalRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRemovalRequest
     */
    select?: DataRemovalRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DataRemovalRequests.
     */
    data: DataRemovalRequestCreateManyInput | DataRemovalRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRemovalRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataRemovalRequest update
   */
  export type DataRemovalRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRemovalRequest
     */
    select?: DataRemovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRemovalRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a DataRemovalRequest.
     */
    data: XOR<DataRemovalRequestUpdateInput, DataRemovalRequestUncheckedUpdateInput>
    /**
     * Choose, which DataRemovalRequest to update.
     */
    where: DataRemovalRequestWhereUniqueInput
  }

  /**
   * DataRemovalRequest updateMany
   */
  export type DataRemovalRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataRemovalRequests.
     */
    data: XOR<DataRemovalRequestUpdateManyMutationInput, DataRemovalRequestUncheckedUpdateManyInput>
    /**
     * Filter which DataRemovalRequests to update
     */
    where?: DataRemovalRequestWhereInput
  }

  /**
   * DataRemovalRequest upsert
   */
  export type DataRemovalRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRemovalRequest
     */
    select?: DataRemovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRemovalRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the DataRemovalRequest to update in case it exists.
     */
    where: DataRemovalRequestWhereUniqueInput
    /**
     * In case the DataRemovalRequest found by the `where` argument doesn't exist, create a new DataRemovalRequest with this data.
     */
    create: XOR<DataRemovalRequestCreateInput, DataRemovalRequestUncheckedCreateInput>
    /**
     * In case the DataRemovalRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataRemovalRequestUpdateInput, DataRemovalRequestUncheckedUpdateInput>
  }

  /**
   * DataRemovalRequest delete
   */
  export type DataRemovalRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRemovalRequest
     */
    select?: DataRemovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRemovalRequestInclude<ExtArgs> | null
    /**
     * Filter which DataRemovalRequest to delete.
     */
    where: DataRemovalRequestWhereUniqueInput
  }

  /**
   * DataRemovalRequest deleteMany
   */
  export type DataRemovalRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataRemovalRequests to delete
     */
    where?: DataRemovalRequestWhereInput
  }

  /**
   * DataRemovalRequest without action
   */
  export type DataRemovalRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRemovalRequest
     */
    select?: DataRemovalRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataRemovalRequestInclude<ExtArgs> | null
  }


  /**
   * Model MeetingKind
   */

  export type AggregateMeetingKind = {
    _count: MeetingKindCountAggregateOutputType | null
    _min: MeetingKindMinAggregateOutputType | null
    _max: MeetingKindMaxAggregateOutputType | null
  }

  export type MeetingKindMinAggregateOutputType = {
    meeting_kind_id: string | null
    meeting_kind_name: string | null
  }

  export type MeetingKindMaxAggregateOutputType = {
    meeting_kind_id: string | null
    meeting_kind_name: string | null
  }

  export type MeetingKindCountAggregateOutputType = {
    meeting_kind_id: number
    meeting_kind_name: number
    _all: number
  }


  export type MeetingKindMinAggregateInputType = {
    meeting_kind_id?: true
    meeting_kind_name?: true
  }

  export type MeetingKindMaxAggregateInputType = {
    meeting_kind_id?: true
    meeting_kind_name?: true
  }

  export type MeetingKindCountAggregateInputType = {
    meeting_kind_id?: true
    meeting_kind_name?: true
    _all?: true
  }

  export type MeetingKindAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeetingKind to aggregate.
     */
    where?: MeetingKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingKinds to fetch.
     */
    orderBy?: MeetingKindOrderByWithRelationInput | MeetingKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeetingKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MeetingKinds
    **/
    _count?: true | MeetingKindCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingKindMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingKindMaxAggregateInputType
  }

  export type GetMeetingKindAggregateType<T extends MeetingKindAggregateArgs> = {
        [P in keyof T & keyof AggregateMeetingKind]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeetingKind[P]>
      : GetScalarType<T[P], AggregateMeetingKind[P]>
  }




  export type MeetingKindGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingKindWhereInput
    orderBy?: MeetingKindOrderByWithAggregationInput | MeetingKindOrderByWithAggregationInput[]
    by: MeetingKindScalarFieldEnum[] | MeetingKindScalarFieldEnum
    having?: MeetingKindScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingKindCountAggregateInputType | true
    _min?: MeetingKindMinAggregateInputType
    _max?: MeetingKindMaxAggregateInputType
  }

  export type MeetingKindGroupByOutputType = {
    meeting_kind_id: string
    meeting_kind_name: string
    _count: MeetingKindCountAggregateOutputType | null
    _min: MeetingKindMinAggregateOutputType | null
    _max: MeetingKindMaxAggregateOutputType | null
  }

  type GetMeetingKindGroupByPayload<T extends MeetingKindGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingKindGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingKindGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingKindGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingKindGroupByOutputType[P]>
        }
      >
    >


  export type MeetingKindSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    meeting_kind_id?: boolean
    meeting_kind_name?: boolean
    class_calls?: boolean | MeetingKind$class_callsArgs<ExtArgs>
    _count?: boolean | MeetingKindCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meetingKind"]>

  export type MeetingKindSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    meeting_kind_id?: boolean
    meeting_kind_name?: boolean
  }, ExtArgs["result"]["meetingKind"]>

  export type MeetingKindSelectScalar = {
    meeting_kind_id?: boolean
    meeting_kind_name?: boolean
  }

  export type MeetingKindInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class_calls?: boolean | MeetingKind$class_callsArgs<ExtArgs>
    _count?: boolean | MeetingKindCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MeetingKindIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MeetingKindPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MeetingKind"
    objects: {
      class_calls: Prisma.$ClassCallPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      meeting_kind_id: string
      meeting_kind_name: string
    }, ExtArgs["result"]["meetingKind"]>
    composites: {}
  }

  type MeetingKindGetPayload<S extends boolean | null | undefined | MeetingKindDefaultArgs> = $Result.GetResult<Prisma.$MeetingKindPayload, S>

  type MeetingKindCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MeetingKindFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MeetingKindCountAggregateInputType | true
    }

  export interface MeetingKindDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MeetingKind'], meta: { name: 'MeetingKind' } }
    /**
     * Find zero or one MeetingKind that matches the filter.
     * @param {MeetingKindFindUniqueArgs} args - Arguments to find a MeetingKind
     * @example
     * // Get one MeetingKind
     * const meetingKind = await prisma.meetingKind.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingKindFindUniqueArgs>(args: SelectSubset<T, MeetingKindFindUniqueArgs<ExtArgs>>): Prisma__MeetingKindClient<$Result.GetResult<Prisma.$MeetingKindPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MeetingKind that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MeetingKindFindUniqueOrThrowArgs} args - Arguments to find a MeetingKind
     * @example
     * // Get one MeetingKind
     * const meetingKind = await prisma.meetingKind.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingKindFindUniqueOrThrowArgs>(args: SelectSubset<T, MeetingKindFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeetingKindClient<$Result.GetResult<Prisma.$MeetingKindPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MeetingKind that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingKindFindFirstArgs} args - Arguments to find a MeetingKind
     * @example
     * // Get one MeetingKind
     * const meetingKind = await prisma.meetingKind.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingKindFindFirstArgs>(args?: SelectSubset<T, MeetingKindFindFirstArgs<ExtArgs>>): Prisma__MeetingKindClient<$Result.GetResult<Prisma.$MeetingKindPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MeetingKind that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingKindFindFirstOrThrowArgs} args - Arguments to find a MeetingKind
     * @example
     * // Get one MeetingKind
     * const meetingKind = await prisma.meetingKind.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingKindFindFirstOrThrowArgs>(args?: SelectSubset<T, MeetingKindFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeetingKindClient<$Result.GetResult<Prisma.$MeetingKindPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MeetingKinds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingKindFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MeetingKinds
     * const meetingKinds = await prisma.meetingKind.findMany()
     * 
     * // Get first 10 MeetingKinds
     * const meetingKinds = await prisma.meetingKind.findMany({ take: 10 })
     * 
     * // Only select the `meeting_kind_id`
     * const meetingKindWithMeeting_kind_idOnly = await prisma.meetingKind.findMany({ select: { meeting_kind_id: true } })
     * 
     */
    findMany<T extends MeetingKindFindManyArgs>(args?: SelectSubset<T, MeetingKindFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingKindPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MeetingKind.
     * @param {MeetingKindCreateArgs} args - Arguments to create a MeetingKind.
     * @example
     * // Create one MeetingKind
     * const MeetingKind = await prisma.meetingKind.create({
     *   data: {
     *     // ... data to create a MeetingKind
     *   }
     * })
     * 
     */
    create<T extends MeetingKindCreateArgs>(args: SelectSubset<T, MeetingKindCreateArgs<ExtArgs>>): Prisma__MeetingKindClient<$Result.GetResult<Prisma.$MeetingKindPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MeetingKinds.
     * @param {MeetingKindCreateManyArgs} args - Arguments to create many MeetingKinds.
     * @example
     * // Create many MeetingKinds
     * const meetingKind = await prisma.meetingKind.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeetingKindCreateManyArgs>(args?: SelectSubset<T, MeetingKindCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MeetingKinds and returns the data saved in the database.
     * @param {MeetingKindCreateManyAndReturnArgs} args - Arguments to create many MeetingKinds.
     * @example
     * // Create many MeetingKinds
     * const meetingKind = await prisma.meetingKind.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MeetingKinds and only return the `meeting_kind_id`
     * const meetingKindWithMeeting_kind_idOnly = await prisma.meetingKind.createManyAndReturn({ 
     *   select: { meeting_kind_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeetingKindCreateManyAndReturnArgs>(args?: SelectSubset<T, MeetingKindCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingKindPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MeetingKind.
     * @param {MeetingKindDeleteArgs} args - Arguments to delete one MeetingKind.
     * @example
     * // Delete one MeetingKind
     * const MeetingKind = await prisma.meetingKind.delete({
     *   where: {
     *     // ... filter to delete one MeetingKind
     *   }
     * })
     * 
     */
    delete<T extends MeetingKindDeleteArgs>(args: SelectSubset<T, MeetingKindDeleteArgs<ExtArgs>>): Prisma__MeetingKindClient<$Result.GetResult<Prisma.$MeetingKindPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MeetingKind.
     * @param {MeetingKindUpdateArgs} args - Arguments to update one MeetingKind.
     * @example
     * // Update one MeetingKind
     * const meetingKind = await prisma.meetingKind.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeetingKindUpdateArgs>(args: SelectSubset<T, MeetingKindUpdateArgs<ExtArgs>>): Prisma__MeetingKindClient<$Result.GetResult<Prisma.$MeetingKindPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MeetingKinds.
     * @param {MeetingKindDeleteManyArgs} args - Arguments to filter MeetingKinds to delete.
     * @example
     * // Delete a few MeetingKinds
     * const { count } = await prisma.meetingKind.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeetingKindDeleteManyArgs>(args?: SelectSubset<T, MeetingKindDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeetingKinds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingKindUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MeetingKinds
     * const meetingKind = await prisma.meetingKind.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeetingKindUpdateManyArgs>(args: SelectSubset<T, MeetingKindUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MeetingKind.
     * @param {MeetingKindUpsertArgs} args - Arguments to update or create a MeetingKind.
     * @example
     * // Update or create a MeetingKind
     * const meetingKind = await prisma.meetingKind.upsert({
     *   create: {
     *     // ... data to create a MeetingKind
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MeetingKind we want to update
     *   }
     * })
     */
    upsert<T extends MeetingKindUpsertArgs>(args: SelectSubset<T, MeetingKindUpsertArgs<ExtArgs>>): Prisma__MeetingKindClient<$Result.GetResult<Prisma.$MeetingKindPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MeetingKinds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingKindCountArgs} args - Arguments to filter MeetingKinds to count.
     * @example
     * // Count the number of MeetingKinds
     * const count = await prisma.meetingKind.count({
     *   where: {
     *     // ... the filter for the MeetingKinds we want to count
     *   }
     * })
    **/
    count<T extends MeetingKindCountArgs>(
      args?: Subset<T, MeetingKindCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingKindCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MeetingKind.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingKindAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingKindAggregateArgs>(args: Subset<T, MeetingKindAggregateArgs>): Prisma.PrismaPromise<GetMeetingKindAggregateType<T>>

    /**
     * Group by MeetingKind.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingKindGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeetingKindGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingKindGroupByArgs['orderBy'] }
        : { orderBy?: MeetingKindGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeetingKindGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingKindGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MeetingKind model
   */
  readonly fields: MeetingKindFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MeetingKind.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingKindClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class_calls<T extends MeetingKind$class_callsArgs<ExtArgs> = {}>(args?: Subset<T, MeetingKind$class_callsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassCallPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MeetingKind model
   */ 
  interface MeetingKindFieldRefs {
    readonly meeting_kind_id: FieldRef<"MeetingKind", 'String'>
    readonly meeting_kind_name: FieldRef<"MeetingKind", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MeetingKind findUnique
   */
  export type MeetingKindFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingKind
     */
    select?: MeetingKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingKindInclude<ExtArgs> | null
    /**
     * Filter, which MeetingKind to fetch.
     */
    where: MeetingKindWhereUniqueInput
  }

  /**
   * MeetingKind findUniqueOrThrow
   */
  export type MeetingKindFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingKind
     */
    select?: MeetingKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingKindInclude<ExtArgs> | null
    /**
     * Filter, which MeetingKind to fetch.
     */
    where: MeetingKindWhereUniqueInput
  }

  /**
   * MeetingKind findFirst
   */
  export type MeetingKindFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingKind
     */
    select?: MeetingKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingKindInclude<ExtArgs> | null
    /**
     * Filter, which MeetingKind to fetch.
     */
    where?: MeetingKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingKinds to fetch.
     */
    orderBy?: MeetingKindOrderByWithRelationInput | MeetingKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeetingKinds.
     */
    cursor?: MeetingKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeetingKinds.
     */
    distinct?: MeetingKindScalarFieldEnum | MeetingKindScalarFieldEnum[]
  }

  /**
   * MeetingKind findFirstOrThrow
   */
  export type MeetingKindFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingKind
     */
    select?: MeetingKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingKindInclude<ExtArgs> | null
    /**
     * Filter, which MeetingKind to fetch.
     */
    where?: MeetingKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingKinds to fetch.
     */
    orderBy?: MeetingKindOrderByWithRelationInput | MeetingKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeetingKinds.
     */
    cursor?: MeetingKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeetingKinds.
     */
    distinct?: MeetingKindScalarFieldEnum | MeetingKindScalarFieldEnum[]
  }

  /**
   * MeetingKind findMany
   */
  export type MeetingKindFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingKind
     */
    select?: MeetingKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingKindInclude<ExtArgs> | null
    /**
     * Filter, which MeetingKinds to fetch.
     */
    where?: MeetingKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingKinds to fetch.
     */
    orderBy?: MeetingKindOrderByWithRelationInput | MeetingKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MeetingKinds.
     */
    cursor?: MeetingKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingKinds.
     */
    skip?: number
    distinct?: MeetingKindScalarFieldEnum | MeetingKindScalarFieldEnum[]
  }

  /**
   * MeetingKind create
   */
  export type MeetingKindCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingKind
     */
    select?: MeetingKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingKindInclude<ExtArgs> | null
    /**
     * The data needed to create a MeetingKind.
     */
    data: XOR<MeetingKindCreateInput, MeetingKindUncheckedCreateInput>
  }

  /**
   * MeetingKind createMany
   */
  export type MeetingKindCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MeetingKinds.
     */
    data: MeetingKindCreateManyInput | MeetingKindCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MeetingKind createManyAndReturn
   */
  export type MeetingKindCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingKind
     */
    select?: MeetingKindSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MeetingKinds.
     */
    data: MeetingKindCreateManyInput | MeetingKindCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MeetingKind update
   */
  export type MeetingKindUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingKind
     */
    select?: MeetingKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingKindInclude<ExtArgs> | null
    /**
     * The data needed to update a MeetingKind.
     */
    data: XOR<MeetingKindUpdateInput, MeetingKindUncheckedUpdateInput>
    /**
     * Choose, which MeetingKind to update.
     */
    where: MeetingKindWhereUniqueInput
  }

  /**
   * MeetingKind updateMany
   */
  export type MeetingKindUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MeetingKinds.
     */
    data: XOR<MeetingKindUpdateManyMutationInput, MeetingKindUncheckedUpdateManyInput>
    /**
     * Filter which MeetingKinds to update
     */
    where?: MeetingKindWhereInput
  }

  /**
   * MeetingKind upsert
   */
  export type MeetingKindUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingKind
     */
    select?: MeetingKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingKindInclude<ExtArgs> | null
    /**
     * The filter to search for the MeetingKind to update in case it exists.
     */
    where: MeetingKindWhereUniqueInput
    /**
     * In case the MeetingKind found by the `where` argument doesn't exist, create a new MeetingKind with this data.
     */
    create: XOR<MeetingKindCreateInput, MeetingKindUncheckedCreateInput>
    /**
     * In case the MeetingKind was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingKindUpdateInput, MeetingKindUncheckedUpdateInput>
  }

  /**
   * MeetingKind delete
   */
  export type MeetingKindDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingKind
     */
    select?: MeetingKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingKindInclude<ExtArgs> | null
    /**
     * Filter which MeetingKind to delete.
     */
    where: MeetingKindWhereUniqueInput
  }

  /**
   * MeetingKind deleteMany
   */
  export type MeetingKindDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeetingKinds to delete
     */
    where?: MeetingKindWhereInput
  }

  /**
   * MeetingKind.class_calls
   */
  export type MeetingKind$class_callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCall
     */
    select?: ClassCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassCallInclude<ExtArgs> | null
    where?: ClassCallWhereInput
    orderBy?: ClassCallOrderByWithRelationInput | ClassCallOrderByWithRelationInput[]
    cursor?: ClassCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassCallScalarFieldEnum | ClassCallScalarFieldEnum[]
  }

  /**
   * MeetingKind without action
   */
  export type MeetingKindDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingKind
     */
    select?: MeetingKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingKindInclude<ExtArgs> | null
  }


  /**
   * Model CourseStructure
   */

  export type AggregateCourseStructure = {
    _count: CourseStructureCountAggregateOutputType | null
    _avg: CourseStructureAvgAggregateOutputType | null
    _sum: CourseStructureSumAggregateOutputType | null
    _min: CourseStructureMinAggregateOutputType | null
    _max: CourseStructureMaxAggregateOutputType | null
  }

  export type CourseStructureAvgAggregateOutputType = {
    module_id: number | null
    section_id: number | null
    lesson_id: number | null
  }

  export type CourseStructureSumAggregateOutputType = {
    module_id: number | null
    section_id: number | null
    lesson_id: number | null
  }

  export type CourseStructureMinAggregateOutputType = {
    course_id: string | null
    module_id: number | null
    section_id: number | null
    lesson_id: number | null
  }

  export type CourseStructureMaxAggregateOutputType = {
    course_id: string | null
    module_id: number | null
    section_id: number | null
    lesson_id: number | null
  }

  export type CourseStructureCountAggregateOutputType = {
    course_id: number
    module_id: number
    section_id: number
    lesson_id: number
    _all: number
  }


  export type CourseStructureAvgAggregateInputType = {
    module_id?: true
    section_id?: true
    lesson_id?: true
  }

  export type CourseStructureSumAggregateInputType = {
    module_id?: true
    section_id?: true
    lesson_id?: true
  }

  export type CourseStructureMinAggregateInputType = {
    course_id?: true
    module_id?: true
    section_id?: true
    lesson_id?: true
  }

  export type CourseStructureMaxAggregateInputType = {
    course_id?: true
    module_id?: true
    section_id?: true
    lesson_id?: true
  }

  export type CourseStructureCountAggregateInputType = {
    course_id?: true
    module_id?: true
    section_id?: true
    lesson_id?: true
    _all?: true
  }

  export type CourseStructureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseStructure to aggregate.
     */
    where?: CourseStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseStructures to fetch.
     */
    orderBy?: CourseStructureOrderByWithRelationInput | CourseStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseStructures
    **/
    _count?: true | CourseStructureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseStructureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseStructureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseStructureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseStructureMaxAggregateInputType
  }

  export type GetCourseStructureAggregateType<T extends CourseStructureAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseStructure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseStructure[P]>
      : GetScalarType<T[P], AggregateCourseStructure[P]>
  }




  export type CourseStructureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseStructureWhereInput
    orderBy?: CourseStructureOrderByWithAggregationInput | CourseStructureOrderByWithAggregationInput[]
    by: CourseStructureScalarFieldEnum[] | CourseStructureScalarFieldEnum
    having?: CourseStructureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseStructureCountAggregateInputType | true
    _avg?: CourseStructureAvgAggregateInputType
    _sum?: CourseStructureSumAggregateInputType
    _min?: CourseStructureMinAggregateInputType
    _max?: CourseStructureMaxAggregateInputType
  }

  export type CourseStructureGroupByOutputType = {
    course_id: string
    module_id: number
    section_id: number
    lesson_id: number
    _count: CourseStructureCountAggregateOutputType | null
    _avg: CourseStructureAvgAggregateOutputType | null
    _sum: CourseStructureSumAggregateOutputType | null
    _min: CourseStructureMinAggregateOutputType | null
    _max: CourseStructureMaxAggregateOutputType | null
  }

  type GetCourseStructureGroupByPayload<T extends CourseStructureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseStructureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseStructureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseStructureGroupByOutputType[P]>
            : GetScalarType<T[P], CourseStructureGroupByOutputType[P]>
        }
      >
    >


  export type CourseStructureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    course_id?: boolean
    module_id?: boolean
    section_id?: boolean
    lesson_id?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseStructure"]>

  export type CourseStructureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    course_id?: boolean
    module_id?: boolean
    section_id?: boolean
    lesson_id?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseStructure"]>

  export type CourseStructureSelectScalar = {
    course_id?: boolean
    module_id?: boolean
    section_id?: boolean
    lesson_id?: boolean
  }

  export type CourseStructureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type CourseStructureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $CourseStructurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseStructure"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      module: Prisma.$ModulePayload<ExtArgs>
      section: Prisma.$SectionPayload<ExtArgs>
      lesson: Prisma.$LessonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      course_id: string
      module_id: number
      section_id: number
      lesson_id: number
    }, ExtArgs["result"]["courseStructure"]>
    composites: {}
  }

  type CourseStructureGetPayload<S extends boolean | null | undefined | CourseStructureDefaultArgs> = $Result.GetResult<Prisma.$CourseStructurePayload, S>

  type CourseStructureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseStructureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseStructureCountAggregateInputType | true
    }

  export interface CourseStructureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseStructure'], meta: { name: 'CourseStructure' } }
    /**
     * Find zero or one CourseStructure that matches the filter.
     * @param {CourseStructureFindUniqueArgs} args - Arguments to find a CourseStructure
     * @example
     * // Get one CourseStructure
     * const courseStructure = await prisma.courseStructure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseStructureFindUniqueArgs>(args: SelectSubset<T, CourseStructureFindUniqueArgs<ExtArgs>>): Prisma__CourseStructureClient<$Result.GetResult<Prisma.$CourseStructurePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseStructure that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseStructureFindUniqueOrThrowArgs} args - Arguments to find a CourseStructure
     * @example
     * // Get one CourseStructure
     * const courseStructure = await prisma.courseStructure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseStructureFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseStructureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseStructureClient<$Result.GetResult<Prisma.$CourseStructurePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseStructure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseStructureFindFirstArgs} args - Arguments to find a CourseStructure
     * @example
     * // Get one CourseStructure
     * const courseStructure = await prisma.courseStructure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseStructureFindFirstArgs>(args?: SelectSubset<T, CourseStructureFindFirstArgs<ExtArgs>>): Prisma__CourseStructureClient<$Result.GetResult<Prisma.$CourseStructurePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseStructure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseStructureFindFirstOrThrowArgs} args - Arguments to find a CourseStructure
     * @example
     * // Get one CourseStructure
     * const courseStructure = await prisma.courseStructure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseStructureFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseStructureFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseStructureClient<$Result.GetResult<Prisma.$CourseStructurePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseStructures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseStructureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseStructures
     * const courseStructures = await prisma.courseStructure.findMany()
     * 
     * // Get first 10 CourseStructures
     * const courseStructures = await prisma.courseStructure.findMany({ take: 10 })
     * 
     * // Only select the `course_id`
     * const courseStructureWithCourse_idOnly = await prisma.courseStructure.findMany({ select: { course_id: true } })
     * 
     */
    findMany<T extends CourseStructureFindManyArgs>(args?: SelectSubset<T, CourseStructureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseStructurePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseStructure.
     * @param {CourseStructureCreateArgs} args - Arguments to create a CourseStructure.
     * @example
     * // Create one CourseStructure
     * const CourseStructure = await prisma.courseStructure.create({
     *   data: {
     *     // ... data to create a CourseStructure
     *   }
     * })
     * 
     */
    create<T extends CourseStructureCreateArgs>(args: SelectSubset<T, CourseStructureCreateArgs<ExtArgs>>): Prisma__CourseStructureClient<$Result.GetResult<Prisma.$CourseStructurePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseStructures.
     * @param {CourseStructureCreateManyArgs} args - Arguments to create many CourseStructures.
     * @example
     * // Create many CourseStructures
     * const courseStructure = await prisma.courseStructure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseStructureCreateManyArgs>(args?: SelectSubset<T, CourseStructureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseStructures and returns the data saved in the database.
     * @param {CourseStructureCreateManyAndReturnArgs} args - Arguments to create many CourseStructures.
     * @example
     * // Create many CourseStructures
     * const courseStructure = await prisma.courseStructure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseStructures and only return the `course_id`
     * const courseStructureWithCourse_idOnly = await prisma.courseStructure.createManyAndReturn({ 
     *   select: { course_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseStructureCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseStructureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseStructurePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseStructure.
     * @param {CourseStructureDeleteArgs} args - Arguments to delete one CourseStructure.
     * @example
     * // Delete one CourseStructure
     * const CourseStructure = await prisma.courseStructure.delete({
     *   where: {
     *     // ... filter to delete one CourseStructure
     *   }
     * })
     * 
     */
    delete<T extends CourseStructureDeleteArgs>(args: SelectSubset<T, CourseStructureDeleteArgs<ExtArgs>>): Prisma__CourseStructureClient<$Result.GetResult<Prisma.$CourseStructurePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseStructure.
     * @param {CourseStructureUpdateArgs} args - Arguments to update one CourseStructure.
     * @example
     * // Update one CourseStructure
     * const courseStructure = await prisma.courseStructure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseStructureUpdateArgs>(args: SelectSubset<T, CourseStructureUpdateArgs<ExtArgs>>): Prisma__CourseStructureClient<$Result.GetResult<Prisma.$CourseStructurePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseStructures.
     * @param {CourseStructureDeleteManyArgs} args - Arguments to filter CourseStructures to delete.
     * @example
     * // Delete a few CourseStructures
     * const { count } = await prisma.courseStructure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseStructureDeleteManyArgs>(args?: SelectSubset<T, CourseStructureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseStructureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseStructures
     * const courseStructure = await prisma.courseStructure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseStructureUpdateManyArgs>(args: SelectSubset<T, CourseStructureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseStructure.
     * @param {CourseStructureUpsertArgs} args - Arguments to update or create a CourseStructure.
     * @example
     * // Update or create a CourseStructure
     * const courseStructure = await prisma.courseStructure.upsert({
     *   create: {
     *     // ... data to create a CourseStructure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseStructure we want to update
     *   }
     * })
     */
    upsert<T extends CourseStructureUpsertArgs>(args: SelectSubset<T, CourseStructureUpsertArgs<ExtArgs>>): Prisma__CourseStructureClient<$Result.GetResult<Prisma.$CourseStructurePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseStructureCountArgs} args - Arguments to filter CourseStructures to count.
     * @example
     * // Count the number of CourseStructures
     * const count = await prisma.courseStructure.count({
     *   where: {
     *     // ... the filter for the CourseStructures we want to count
     *   }
     * })
    **/
    count<T extends CourseStructureCountArgs>(
      args?: Subset<T, CourseStructureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseStructureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseStructureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseStructureAggregateArgs>(args: Subset<T, CourseStructureAggregateArgs>): Prisma.PrismaPromise<GetCourseStructureAggregateType<T>>

    /**
     * Group by CourseStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseStructureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseStructureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseStructureGroupByArgs['orderBy'] }
        : { orderBy?: CourseStructureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseStructureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseStructureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseStructure model
   */
  readonly fields: CourseStructureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseStructure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseStructureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseStructure model
   */ 
  interface CourseStructureFieldRefs {
    readonly course_id: FieldRef<"CourseStructure", 'String'>
    readonly module_id: FieldRef<"CourseStructure", 'Int'>
    readonly section_id: FieldRef<"CourseStructure", 'Int'>
    readonly lesson_id: FieldRef<"CourseStructure", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CourseStructure findUnique
   */
  export type CourseStructureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseStructure
     */
    select?: CourseStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseStructureInclude<ExtArgs> | null
    /**
     * Filter, which CourseStructure to fetch.
     */
    where: CourseStructureWhereUniqueInput
  }

  /**
   * CourseStructure findUniqueOrThrow
   */
  export type CourseStructureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseStructure
     */
    select?: CourseStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseStructureInclude<ExtArgs> | null
    /**
     * Filter, which CourseStructure to fetch.
     */
    where: CourseStructureWhereUniqueInput
  }

  /**
   * CourseStructure findFirst
   */
  export type CourseStructureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseStructure
     */
    select?: CourseStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseStructureInclude<ExtArgs> | null
    /**
     * Filter, which CourseStructure to fetch.
     */
    where?: CourseStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseStructures to fetch.
     */
    orderBy?: CourseStructureOrderByWithRelationInput | CourseStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseStructures.
     */
    cursor?: CourseStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseStructures.
     */
    distinct?: CourseStructureScalarFieldEnum | CourseStructureScalarFieldEnum[]
  }

  /**
   * CourseStructure findFirstOrThrow
   */
  export type CourseStructureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseStructure
     */
    select?: CourseStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseStructureInclude<ExtArgs> | null
    /**
     * Filter, which CourseStructure to fetch.
     */
    where?: CourseStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseStructures to fetch.
     */
    orderBy?: CourseStructureOrderByWithRelationInput | CourseStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseStructures.
     */
    cursor?: CourseStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseStructures.
     */
    distinct?: CourseStructureScalarFieldEnum | CourseStructureScalarFieldEnum[]
  }

  /**
   * CourseStructure findMany
   */
  export type CourseStructureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseStructure
     */
    select?: CourseStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseStructureInclude<ExtArgs> | null
    /**
     * Filter, which CourseStructures to fetch.
     */
    where?: CourseStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseStructures to fetch.
     */
    orderBy?: CourseStructureOrderByWithRelationInput | CourseStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseStructures.
     */
    cursor?: CourseStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseStructures.
     */
    skip?: number
    distinct?: CourseStructureScalarFieldEnum | CourseStructureScalarFieldEnum[]
  }

  /**
   * CourseStructure create
   */
  export type CourseStructureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseStructure
     */
    select?: CourseStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseStructureInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseStructure.
     */
    data: XOR<CourseStructureCreateInput, CourseStructureUncheckedCreateInput>
  }

  /**
   * CourseStructure createMany
   */
  export type CourseStructureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseStructures.
     */
    data: CourseStructureCreateManyInput | CourseStructureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseStructure createManyAndReturn
   */
  export type CourseStructureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseStructure
     */
    select?: CourseStructureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CourseStructures.
     */
    data: CourseStructureCreateManyInput | CourseStructureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseStructureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseStructure update
   */
  export type CourseStructureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseStructure
     */
    select?: CourseStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseStructureInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseStructure.
     */
    data: XOR<CourseStructureUpdateInput, CourseStructureUncheckedUpdateInput>
    /**
     * Choose, which CourseStructure to update.
     */
    where: CourseStructureWhereUniqueInput
  }

  /**
   * CourseStructure updateMany
   */
  export type CourseStructureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseStructures.
     */
    data: XOR<CourseStructureUpdateManyMutationInput, CourseStructureUncheckedUpdateManyInput>
    /**
     * Filter which CourseStructures to update
     */
    where?: CourseStructureWhereInput
  }

  /**
   * CourseStructure upsert
   */
  export type CourseStructureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseStructure
     */
    select?: CourseStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseStructureInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseStructure to update in case it exists.
     */
    where: CourseStructureWhereUniqueInput
    /**
     * In case the CourseStructure found by the `where` argument doesn't exist, create a new CourseStructure with this data.
     */
    create: XOR<CourseStructureCreateInput, CourseStructureUncheckedCreateInput>
    /**
     * In case the CourseStructure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseStructureUpdateInput, CourseStructureUncheckedUpdateInput>
  }

  /**
   * CourseStructure delete
   */
  export type CourseStructureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseStructure
     */
    select?: CourseStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseStructureInclude<ExtArgs> | null
    /**
     * Filter which CourseStructure to delete.
     */
    where: CourseStructureWhereUniqueInput
  }

  /**
   * CourseStructure deleteMany
   */
  export type CourseStructureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseStructures to delete
     */
    where?: CourseStructureWhereInput
  }

  /**
   * CourseStructure without action
   */
  export type CourseStructureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseStructure
     */
    select?: CourseStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseStructureInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassMinAggregateOutputType = {
    class_id: string | null
    class_code: string | null
    course_id: string | null
    start_date: Date | null
    end_date: Date | null
    tuition_lang_code: string | null
    time_of_day_id: string | null
    start_time_gmt3: string | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean | null
    classSizeClass_size_id: string | null
  }

  export type ClassMaxAggregateOutputType = {
    class_id: string | null
    class_code: string | null
    course_id: string | null
    start_date: Date | null
    end_date: Date | null
    tuition_lang_code: string | null
    time_of_day_id: string | null
    start_time_gmt3: string | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean | null
    classSizeClass_size_id: string | null
  }

  export type ClassCountAggregateOutputType = {
    class_id: number
    class_code: number
    course_id: number
    start_date: number
    end_date: number
    tuition_lang_code: number
    time_of_day_id: number
    start_time_gmt3: number
    created_date: number
    updated_date: number
    deleted: number
    classSizeClass_size_id: number
    _all: number
  }


  export type ClassMinAggregateInputType = {
    class_id?: true
    class_code?: true
    course_id?: true
    start_date?: true
    end_date?: true
    tuition_lang_code?: true
    time_of_day_id?: true
    start_time_gmt3?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    classSizeClass_size_id?: true
  }

  export type ClassMaxAggregateInputType = {
    class_id?: true
    class_code?: true
    course_id?: true
    start_date?: true
    end_date?: true
    tuition_lang_code?: true
    time_of_day_id?: true
    start_time_gmt3?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    classSizeClass_size_id?: true
  }

  export type ClassCountAggregateInputType = {
    class_id?: true
    class_code?: true
    course_id?: true
    start_date?: true
    end_date?: true
    tuition_lang_code?: true
    time_of_day_id?: true
    start_time_gmt3?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    classSizeClass_size_id?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    class_id: string
    class_code: string | null
    course_id: string
    start_date: Date
    end_date: Date | null
    tuition_lang_code: string
    time_of_day_id: string
    start_time_gmt3: string
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean
    classSizeClass_size_id: string
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    class_id?: boolean
    class_code?: boolean
    course_id?: boolean
    start_date?: boolean
    end_date?: boolean
    tuition_lang_code?: boolean
    time_of_day_id?: boolean
    start_time_gmt3?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    classSizeClass_size_id?: boolean
    class_size_id?: boolean | ClassSizeDefaultArgs<ExtArgs>
    is_instance_of_course?: boolean | CourseDefaultArgs<ExtArgs>
    time_of_day?: boolean | TimeOfDayDefaultArgs<ExtArgs>
    tuition_lang?: boolean | TuitionLangDefaultArgs<ExtArgs>
    mentor_classes?: boolean | Class$mentor_classesArgs<ExtArgs>
    students?: boolean | Class$studentsArgs<ExtArgs>
    booking_requests?: boolean | Class$booking_requestsArgs<ExtArgs>
    class_calls?: boolean | Class$class_callsArgs<ExtArgs>
    ClassTask?: boolean | Class$ClassTaskArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    class_id?: boolean
    class_code?: boolean
    course_id?: boolean
    start_date?: boolean
    end_date?: boolean
    tuition_lang_code?: boolean
    time_of_day_id?: boolean
    start_time_gmt3?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    classSizeClass_size_id?: boolean
    class_size_id?: boolean | ClassSizeDefaultArgs<ExtArgs>
    is_instance_of_course?: boolean | CourseDefaultArgs<ExtArgs>
    time_of_day?: boolean | TimeOfDayDefaultArgs<ExtArgs>
    tuition_lang?: boolean | TuitionLangDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    class_id?: boolean
    class_code?: boolean
    course_id?: boolean
    start_date?: boolean
    end_date?: boolean
    tuition_lang_code?: boolean
    time_of_day_id?: boolean
    start_time_gmt3?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    classSizeClass_size_id?: boolean
  }

  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class_size_id?: boolean | ClassSizeDefaultArgs<ExtArgs>
    is_instance_of_course?: boolean | CourseDefaultArgs<ExtArgs>
    time_of_day?: boolean | TimeOfDayDefaultArgs<ExtArgs>
    tuition_lang?: boolean | TuitionLangDefaultArgs<ExtArgs>
    mentor_classes?: boolean | Class$mentor_classesArgs<ExtArgs>
    students?: boolean | Class$studentsArgs<ExtArgs>
    booking_requests?: boolean | Class$booking_requestsArgs<ExtArgs>
    class_calls?: boolean | Class$class_callsArgs<ExtArgs>
    ClassTask?: boolean | Class$ClassTaskArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class_size_id?: boolean | ClassSizeDefaultArgs<ExtArgs>
    is_instance_of_course?: boolean | CourseDefaultArgs<ExtArgs>
    time_of_day?: boolean | TimeOfDayDefaultArgs<ExtArgs>
    tuition_lang?: boolean | TuitionLangDefaultArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      class_size_id: Prisma.$ClassSizePayload<ExtArgs>
      is_instance_of_course: Prisma.$CoursePayload<ExtArgs>
      time_of_day: Prisma.$TimeOfDayPayload<ExtArgs>
      tuition_lang: Prisma.$TuitionLangPayload<ExtArgs>
      mentor_classes: Prisma.$MentorsClassesPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      booking_requests: Prisma.$BookingRequestPayload<ExtArgs>[]
      class_calls: Prisma.$ClassCallPayload<ExtArgs>[]
      ClassTask: Prisma.$ClassTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      class_id: string
      class_code: string | null
      course_id: string
      start_date: Date
      end_date: Date | null
      tuition_lang_code: string
      time_of_day_id: string
      start_time_gmt3: string
      created_date: Date | null
      updated_date: Date | null
      deleted: boolean
      classSizeClass_size_id: string
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `class_id`
     * const classWithClass_idOnly = await prisma.class.findMany({ select: { class_id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `class_id`
     * const classWithClass_idOnly = await prisma.class.createManyAndReturn({ 
     *   select: { class_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class_size_id<T extends ClassSizeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassSizeDefaultArgs<ExtArgs>>): Prisma__ClassSizeClient<$Result.GetResult<Prisma.$ClassSizePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    is_instance_of_course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    time_of_day<T extends TimeOfDayDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TimeOfDayDefaultArgs<ExtArgs>>): Prisma__TimeOfDayClient<$Result.GetResult<Prisma.$TimeOfDayPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tuition_lang<T extends TuitionLangDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TuitionLangDefaultArgs<ExtArgs>>): Prisma__TuitionLangClient<$Result.GetResult<Prisma.$TuitionLangPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mentor_classes<T extends Class$mentor_classesArgs<ExtArgs> = {}>(args?: Subset<T, Class$mentor_classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorsClassesPayload<ExtArgs>, T, "findMany"> | Null>
    students<T extends Class$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Class$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany"> | Null>
    booking_requests<T extends Class$booking_requestsArgs<ExtArgs> = {}>(args?: Subset<T, Class$booking_requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findMany"> | Null>
    class_calls<T extends Class$class_callsArgs<ExtArgs> = {}>(args?: Subset<T, Class$class_callsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassCallPayload<ExtArgs>, T, "findMany"> | Null>
    ClassTask<T extends Class$ClassTaskArgs<ExtArgs> = {}>(args?: Subset<T, Class$ClassTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassTaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */ 
  interface ClassFieldRefs {
    readonly class_id: FieldRef<"Class", 'String'>
    readonly class_code: FieldRef<"Class", 'String'>
    readonly course_id: FieldRef<"Class", 'String'>
    readonly start_date: FieldRef<"Class", 'DateTime'>
    readonly end_date: FieldRef<"Class", 'DateTime'>
    readonly tuition_lang_code: FieldRef<"Class", 'String'>
    readonly time_of_day_id: FieldRef<"Class", 'String'>
    readonly start_time_gmt3: FieldRef<"Class", 'String'>
    readonly created_date: FieldRef<"Class", 'DateTime'>
    readonly updated_date: FieldRef<"Class", 'DateTime'>
    readonly deleted: FieldRef<"Class", 'Boolean'>
    readonly classSizeClass_size_id: FieldRef<"Class", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
  }

  /**
   * Class.mentor_classes
   */
  export type Class$mentor_classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorsClasses
     */
    select?: MentorsClassesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorsClassesInclude<ExtArgs> | null
    where?: MentorsClassesWhereInput
    orderBy?: MentorsClassesOrderByWithRelationInput | MentorsClassesOrderByWithRelationInput[]
    cursor?: MentorsClassesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorsClassesScalarFieldEnum | MentorsClassesScalarFieldEnum[]
  }

  /**
   * Class.students
   */
  export type Class$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Class.booking_requests
   */
  export type Class$booking_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    where?: BookingRequestWhereInput
    orderBy?: BookingRequestOrderByWithRelationInput | BookingRequestOrderByWithRelationInput[]
    cursor?: BookingRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingRequestScalarFieldEnum | BookingRequestScalarFieldEnum[]
  }

  /**
   * Class.class_calls
   */
  export type Class$class_callsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCall
     */
    select?: ClassCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassCallInclude<ExtArgs> | null
    where?: ClassCallWhereInput
    orderBy?: ClassCallOrderByWithRelationInput | ClassCallOrderByWithRelationInput[]
    cursor?: ClassCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassCallScalarFieldEnum | ClassCallScalarFieldEnum[]
  }

  /**
   * Class.ClassTask
   */
  export type Class$ClassTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassTask
     */
    select?: ClassTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTaskInclude<ExtArgs> | null
    where?: ClassTaskWhereInput
    orderBy?: ClassTaskOrderByWithRelationInput | ClassTaskOrderByWithRelationInput[]
    cursor?: ClassTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassTaskScalarFieldEnum | ClassTaskScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model ClassCall
   */

  export type AggregateClassCall = {
    _count: ClassCallCountAggregateOutputType | null
    _min: ClassCallMinAggregateOutputType | null
    _max: ClassCallMaxAggregateOutputType | null
  }

  export type ClassCallMinAggregateOutputType = {
    class_call_id: string | null
    class_id: string | null
    call_date: Date | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean | null
    meeting_kind_id: string | null
  }

  export type ClassCallMaxAggregateOutputType = {
    class_call_id: string | null
    class_id: string | null
    call_date: Date | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean | null
    meeting_kind_id: string | null
  }

  export type ClassCallCountAggregateOutputType = {
    class_call_id: number
    class_id: number
    call_date: number
    created_date: number
    updated_date: number
    deleted: number
    meeting_kind_id: number
    _all: number
  }


  export type ClassCallMinAggregateInputType = {
    class_call_id?: true
    class_id?: true
    call_date?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    meeting_kind_id?: true
  }

  export type ClassCallMaxAggregateInputType = {
    class_call_id?: true
    class_id?: true
    call_date?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    meeting_kind_id?: true
  }

  export type ClassCallCountAggregateInputType = {
    class_call_id?: true
    class_id?: true
    call_date?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    meeting_kind_id?: true
    _all?: true
  }

  export type ClassCallAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassCall to aggregate.
     */
    where?: ClassCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassCalls to fetch.
     */
    orderBy?: ClassCallOrderByWithRelationInput | ClassCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassCalls
    **/
    _count?: true | ClassCallCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassCallMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassCallMaxAggregateInputType
  }

  export type GetClassCallAggregateType<T extends ClassCallAggregateArgs> = {
        [P in keyof T & keyof AggregateClassCall]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassCall[P]>
      : GetScalarType<T[P], AggregateClassCall[P]>
  }




  export type ClassCallGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassCallWhereInput
    orderBy?: ClassCallOrderByWithAggregationInput | ClassCallOrderByWithAggregationInput[]
    by: ClassCallScalarFieldEnum[] | ClassCallScalarFieldEnum
    having?: ClassCallScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCallCountAggregateInputType | true
    _min?: ClassCallMinAggregateInputType
    _max?: ClassCallMaxAggregateInputType
  }

  export type ClassCallGroupByOutputType = {
    class_call_id: string
    class_id: string
    call_date: Date
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean
    meeting_kind_id: string
    _count: ClassCallCountAggregateOutputType | null
    _min: ClassCallMinAggregateOutputType | null
    _max: ClassCallMaxAggregateOutputType | null
  }

  type GetClassCallGroupByPayload<T extends ClassCallGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassCallGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassCallGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassCallGroupByOutputType[P]>
            : GetScalarType<T[P], ClassCallGroupByOutputType[P]>
        }
      >
    >


  export type ClassCallSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    class_call_id?: boolean
    class_id?: boolean
    call_date?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    meeting_kind_id?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    meeting_kind?: boolean | MeetingKindDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classCall"]>

  export type ClassCallSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    class_call_id?: boolean
    class_id?: boolean
    call_date?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    meeting_kind_id?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    meeting_kind?: boolean | MeetingKindDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classCall"]>

  export type ClassCallSelectScalar = {
    class_call_id?: boolean
    class_id?: boolean
    call_date?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    meeting_kind_id?: boolean
  }

  export type ClassCallInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    meeting_kind?: boolean | MeetingKindDefaultArgs<ExtArgs>
  }
  export type ClassCallIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    meeting_kind?: boolean | MeetingKindDefaultArgs<ExtArgs>
  }

  export type $ClassCallPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassCall"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
      meeting_kind: Prisma.$MeetingKindPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      class_call_id: string
      class_id: string
      call_date: Date
      created_date: Date | null
      updated_date: Date | null
      deleted: boolean
      meeting_kind_id: string
    }, ExtArgs["result"]["classCall"]>
    composites: {}
  }

  type ClassCallGetPayload<S extends boolean | null | undefined | ClassCallDefaultArgs> = $Result.GetResult<Prisma.$ClassCallPayload, S>

  type ClassCallCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassCallFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassCallCountAggregateInputType | true
    }

  export interface ClassCallDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassCall'], meta: { name: 'ClassCall' } }
    /**
     * Find zero or one ClassCall that matches the filter.
     * @param {ClassCallFindUniqueArgs} args - Arguments to find a ClassCall
     * @example
     * // Get one ClassCall
     * const classCall = await prisma.classCall.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassCallFindUniqueArgs>(args: SelectSubset<T, ClassCallFindUniqueArgs<ExtArgs>>): Prisma__ClassCallClient<$Result.GetResult<Prisma.$ClassCallPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClassCall that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassCallFindUniqueOrThrowArgs} args - Arguments to find a ClassCall
     * @example
     * // Get one ClassCall
     * const classCall = await prisma.classCall.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassCallFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassCallFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassCallClient<$Result.GetResult<Prisma.$ClassCallPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClassCall that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCallFindFirstArgs} args - Arguments to find a ClassCall
     * @example
     * // Get one ClassCall
     * const classCall = await prisma.classCall.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassCallFindFirstArgs>(args?: SelectSubset<T, ClassCallFindFirstArgs<ExtArgs>>): Prisma__ClassCallClient<$Result.GetResult<Prisma.$ClassCallPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClassCall that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCallFindFirstOrThrowArgs} args - Arguments to find a ClassCall
     * @example
     * // Get one ClassCall
     * const classCall = await prisma.classCall.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassCallFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassCallFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassCallClient<$Result.GetResult<Prisma.$ClassCallPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClassCalls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCallFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassCalls
     * const classCalls = await prisma.classCall.findMany()
     * 
     * // Get first 10 ClassCalls
     * const classCalls = await prisma.classCall.findMany({ take: 10 })
     * 
     * // Only select the `class_call_id`
     * const classCallWithClass_call_idOnly = await prisma.classCall.findMany({ select: { class_call_id: true } })
     * 
     */
    findMany<T extends ClassCallFindManyArgs>(args?: SelectSubset<T, ClassCallFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassCallPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClassCall.
     * @param {ClassCallCreateArgs} args - Arguments to create a ClassCall.
     * @example
     * // Create one ClassCall
     * const ClassCall = await prisma.classCall.create({
     *   data: {
     *     // ... data to create a ClassCall
     *   }
     * })
     * 
     */
    create<T extends ClassCallCreateArgs>(args: SelectSubset<T, ClassCallCreateArgs<ExtArgs>>): Prisma__ClassCallClient<$Result.GetResult<Prisma.$ClassCallPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClassCalls.
     * @param {ClassCallCreateManyArgs} args - Arguments to create many ClassCalls.
     * @example
     * // Create many ClassCalls
     * const classCall = await prisma.classCall.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCallCreateManyArgs>(args?: SelectSubset<T, ClassCallCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassCalls and returns the data saved in the database.
     * @param {ClassCallCreateManyAndReturnArgs} args - Arguments to create many ClassCalls.
     * @example
     * // Create many ClassCalls
     * const classCall = await prisma.classCall.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassCalls and only return the `class_call_id`
     * const classCallWithClass_call_idOnly = await prisma.classCall.createManyAndReturn({ 
     *   select: { class_call_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCallCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCallCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassCallPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClassCall.
     * @param {ClassCallDeleteArgs} args - Arguments to delete one ClassCall.
     * @example
     * // Delete one ClassCall
     * const ClassCall = await prisma.classCall.delete({
     *   where: {
     *     // ... filter to delete one ClassCall
     *   }
     * })
     * 
     */
    delete<T extends ClassCallDeleteArgs>(args: SelectSubset<T, ClassCallDeleteArgs<ExtArgs>>): Prisma__ClassCallClient<$Result.GetResult<Prisma.$ClassCallPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClassCall.
     * @param {ClassCallUpdateArgs} args - Arguments to update one ClassCall.
     * @example
     * // Update one ClassCall
     * const classCall = await prisma.classCall.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassCallUpdateArgs>(args: SelectSubset<T, ClassCallUpdateArgs<ExtArgs>>): Prisma__ClassCallClient<$Result.GetResult<Prisma.$ClassCallPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClassCalls.
     * @param {ClassCallDeleteManyArgs} args - Arguments to filter ClassCalls to delete.
     * @example
     * // Delete a few ClassCalls
     * const { count } = await prisma.classCall.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassCallDeleteManyArgs>(args?: SelectSubset<T, ClassCallDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCallUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassCalls
     * const classCall = await prisma.classCall.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassCallUpdateManyArgs>(args: SelectSubset<T, ClassCallUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassCall.
     * @param {ClassCallUpsertArgs} args - Arguments to update or create a ClassCall.
     * @example
     * // Update or create a ClassCall
     * const classCall = await prisma.classCall.upsert({
     *   create: {
     *     // ... data to create a ClassCall
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassCall we want to update
     *   }
     * })
     */
    upsert<T extends ClassCallUpsertArgs>(args: SelectSubset<T, ClassCallUpsertArgs<ExtArgs>>): Prisma__ClassCallClient<$Result.GetResult<Prisma.$ClassCallPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClassCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCallCountArgs} args - Arguments to filter ClassCalls to count.
     * @example
     * // Count the number of ClassCalls
     * const count = await prisma.classCall.count({
     *   where: {
     *     // ... the filter for the ClassCalls we want to count
     *   }
     * })
    **/
    count<T extends ClassCallCountArgs>(
      args?: Subset<T, ClassCallCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCallCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCallAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassCallAggregateArgs>(args: Subset<T, ClassCallAggregateArgs>): Prisma.PrismaPromise<GetClassCallAggregateType<T>>

    /**
     * Group by ClassCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCallGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassCallGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassCallGroupByArgs['orderBy'] }
        : { orderBy?: ClassCallGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassCallGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassCallGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassCall model
   */
  readonly fields: ClassCallFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassCall.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassCallClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    meeting_kind<T extends MeetingKindDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MeetingKindDefaultArgs<ExtArgs>>): Prisma__MeetingKindClient<$Result.GetResult<Prisma.$MeetingKindPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassCall model
   */ 
  interface ClassCallFieldRefs {
    readonly class_call_id: FieldRef<"ClassCall", 'String'>
    readonly class_id: FieldRef<"ClassCall", 'String'>
    readonly call_date: FieldRef<"ClassCall", 'DateTime'>
    readonly created_date: FieldRef<"ClassCall", 'DateTime'>
    readonly updated_date: FieldRef<"ClassCall", 'DateTime'>
    readonly deleted: FieldRef<"ClassCall", 'Boolean'>
    readonly meeting_kind_id: FieldRef<"ClassCall", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClassCall findUnique
   */
  export type ClassCallFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCall
     */
    select?: ClassCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassCallInclude<ExtArgs> | null
    /**
     * Filter, which ClassCall to fetch.
     */
    where: ClassCallWhereUniqueInput
  }

  /**
   * ClassCall findUniqueOrThrow
   */
  export type ClassCallFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCall
     */
    select?: ClassCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassCallInclude<ExtArgs> | null
    /**
     * Filter, which ClassCall to fetch.
     */
    where: ClassCallWhereUniqueInput
  }

  /**
   * ClassCall findFirst
   */
  export type ClassCallFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCall
     */
    select?: ClassCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassCallInclude<ExtArgs> | null
    /**
     * Filter, which ClassCall to fetch.
     */
    where?: ClassCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassCalls to fetch.
     */
    orderBy?: ClassCallOrderByWithRelationInput | ClassCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassCalls.
     */
    cursor?: ClassCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassCalls.
     */
    distinct?: ClassCallScalarFieldEnum | ClassCallScalarFieldEnum[]
  }

  /**
   * ClassCall findFirstOrThrow
   */
  export type ClassCallFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCall
     */
    select?: ClassCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassCallInclude<ExtArgs> | null
    /**
     * Filter, which ClassCall to fetch.
     */
    where?: ClassCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassCalls to fetch.
     */
    orderBy?: ClassCallOrderByWithRelationInput | ClassCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassCalls.
     */
    cursor?: ClassCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassCalls.
     */
    distinct?: ClassCallScalarFieldEnum | ClassCallScalarFieldEnum[]
  }

  /**
   * ClassCall findMany
   */
  export type ClassCallFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCall
     */
    select?: ClassCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassCallInclude<ExtArgs> | null
    /**
     * Filter, which ClassCalls to fetch.
     */
    where?: ClassCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassCalls to fetch.
     */
    orderBy?: ClassCallOrderByWithRelationInput | ClassCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassCalls.
     */
    cursor?: ClassCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassCalls.
     */
    skip?: number
    distinct?: ClassCallScalarFieldEnum | ClassCallScalarFieldEnum[]
  }

  /**
   * ClassCall create
   */
  export type ClassCallCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCall
     */
    select?: ClassCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassCallInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassCall.
     */
    data: XOR<ClassCallCreateInput, ClassCallUncheckedCreateInput>
  }

  /**
   * ClassCall createMany
   */
  export type ClassCallCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassCalls.
     */
    data: ClassCallCreateManyInput | ClassCallCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassCall createManyAndReturn
   */
  export type ClassCallCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCall
     */
    select?: ClassCallSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClassCalls.
     */
    data: ClassCallCreateManyInput | ClassCallCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassCallIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassCall update
   */
  export type ClassCallUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCall
     */
    select?: ClassCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassCallInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassCall.
     */
    data: XOR<ClassCallUpdateInput, ClassCallUncheckedUpdateInput>
    /**
     * Choose, which ClassCall to update.
     */
    where: ClassCallWhereUniqueInput
  }

  /**
   * ClassCall updateMany
   */
  export type ClassCallUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassCalls.
     */
    data: XOR<ClassCallUpdateManyMutationInput, ClassCallUncheckedUpdateManyInput>
    /**
     * Filter which ClassCalls to update
     */
    where?: ClassCallWhereInput
  }

  /**
   * ClassCall upsert
   */
  export type ClassCallUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCall
     */
    select?: ClassCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassCallInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassCall to update in case it exists.
     */
    where: ClassCallWhereUniqueInput
    /**
     * In case the ClassCall found by the `where` argument doesn't exist, create a new ClassCall with this data.
     */
    create: XOR<ClassCallCreateInput, ClassCallUncheckedCreateInput>
    /**
     * In case the ClassCall was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassCallUpdateInput, ClassCallUncheckedUpdateInput>
  }

  /**
   * ClassCall delete
   */
  export type ClassCallDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCall
     */
    select?: ClassCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassCallInclude<ExtArgs> | null
    /**
     * Filter which ClassCall to delete.
     */
    where: ClassCallWhereUniqueInput
  }

  /**
   * ClassCall deleteMany
   */
  export type ClassCallDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassCalls to delete
     */
    where?: ClassCallWhereInput
  }

  /**
   * ClassCall without action
   */
  export type ClassCallDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCall
     */
    select?: ClassCallSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassCallInclude<ExtArgs> | null
  }


  /**
   * Model ClassSize
   */

  export type AggregateClassSize = {
    _count: ClassSizeCountAggregateOutputType | null
    _min: ClassSizeMinAggregateOutputType | null
    _max: ClassSizeMaxAggregateOutputType | null
  }

  export type ClassSizeMinAggregateOutputType = {
    class_size_id: string | null
    class_size_name: $Enums.ClassSizesEnum | null
  }

  export type ClassSizeMaxAggregateOutputType = {
    class_size_id: string | null
    class_size_name: $Enums.ClassSizesEnum | null
  }

  export type ClassSizeCountAggregateOutputType = {
    class_size_id: number
    class_size_name: number
    _all: number
  }


  export type ClassSizeMinAggregateInputType = {
    class_size_id?: true
    class_size_name?: true
  }

  export type ClassSizeMaxAggregateInputType = {
    class_size_id?: true
    class_size_name?: true
  }

  export type ClassSizeCountAggregateInputType = {
    class_size_id?: true
    class_size_name?: true
    _all?: true
  }

  export type ClassSizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSize to aggregate.
     */
    where?: ClassSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSizes to fetch.
     */
    orderBy?: ClassSizeOrderByWithRelationInput | ClassSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassSizes
    **/
    _count?: true | ClassSizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassSizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassSizeMaxAggregateInputType
  }

  export type GetClassSizeAggregateType<T extends ClassSizeAggregateArgs> = {
        [P in keyof T & keyof AggregateClassSize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassSize[P]>
      : GetScalarType<T[P], AggregateClassSize[P]>
  }




  export type ClassSizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSizeWhereInput
    orderBy?: ClassSizeOrderByWithAggregationInput | ClassSizeOrderByWithAggregationInput[]
    by: ClassSizeScalarFieldEnum[] | ClassSizeScalarFieldEnum
    having?: ClassSizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassSizeCountAggregateInputType | true
    _min?: ClassSizeMinAggregateInputType
    _max?: ClassSizeMaxAggregateInputType
  }

  export type ClassSizeGroupByOutputType = {
    class_size_id: string
    class_size_name: $Enums.ClassSizesEnum
    _count: ClassSizeCountAggregateOutputType | null
    _min: ClassSizeMinAggregateOutputType | null
    _max: ClassSizeMaxAggregateOutputType | null
  }

  type GetClassSizeGroupByPayload<T extends ClassSizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassSizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassSizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassSizeGroupByOutputType[P]>
            : GetScalarType<T[P], ClassSizeGroupByOutputType[P]>
        }
      >
    >


  export type ClassSizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    class_size_id?: boolean
    class_size_name?: boolean
    classes?: boolean | ClassSize$classesArgs<ExtArgs>
    MentorPayModel?: boolean | ClassSize$MentorPayModelArgs<ExtArgs>
    _count?: boolean | ClassSizeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSize"]>

  export type ClassSizeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    class_size_id?: boolean
    class_size_name?: boolean
  }, ExtArgs["result"]["classSize"]>

  export type ClassSizeSelectScalar = {
    class_size_id?: boolean
    class_size_name?: boolean
  }

  export type ClassSizeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | ClassSize$classesArgs<ExtArgs>
    MentorPayModel?: boolean | ClassSize$MentorPayModelArgs<ExtArgs>
    _count?: boolean | ClassSizeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassSizeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClassSizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassSize"
    objects: {
      classes: Prisma.$ClassPayload<ExtArgs>[]
      MentorPayModel: Prisma.$MentorPayModelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      class_size_id: string
      class_size_name: $Enums.ClassSizesEnum
    }, ExtArgs["result"]["classSize"]>
    composites: {}
  }

  type ClassSizeGetPayload<S extends boolean | null | undefined | ClassSizeDefaultArgs> = $Result.GetResult<Prisma.$ClassSizePayload, S>

  type ClassSizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassSizeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassSizeCountAggregateInputType | true
    }

  export interface ClassSizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassSize'], meta: { name: 'ClassSize' } }
    /**
     * Find zero or one ClassSize that matches the filter.
     * @param {ClassSizeFindUniqueArgs} args - Arguments to find a ClassSize
     * @example
     * // Get one ClassSize
     * const classSize = await prisma.classSize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassSizeFindUniqueArgs>(args: SelectSubset<T, ClassSizeFindUniqueArgs<ExtArgs>>): Prisma__ClassSizeClient<$Result.GetResult<Prisma.$ClassSizePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClassSize that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassSizeFindUniqueOrThrowArgs} args - Arguments to find a ClassSize
     * @example
     * // Get one ClassSize
     * const classSize = await prisma.classSize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassSizeFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassSizeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassSizeClient<$Result.GetResult<Prisma.$ClassSizePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClassSize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSizeFindFirstArgs} args - Arguments to find a ClassSize
     * @example
     * // Get one ClassSize
     * const classSize = await prisma.classSize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassSizeFindFirstArgs>(args?: SelectSubset<T, ClassSizeFindFirstArgs<ExtArgs>>): Prisma__ClassSizeClient<$Result.GetResult<Prisma.$ClassSizePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClassSize that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSizeFindFirstOrThrowArgs} args - Arguments to find a ClassSize
     * @example
     * // Get one ClassSize
     * const classSize = await prisma.classSize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassSizeFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassSizeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassSizeClient<$Result.GetResult<Prisma.$ClassSizePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClassSizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSizeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassSizes
     * const classSizes = await prisma.classSize.findMany()
     * 
     * // Get first 10 ClassSizes
     * const classSizes = await prisma.classSize.findMany({ take: 10 })
     * 
     * // Only select the `class_size_id`
     * const classSizeWithClass_size_idOnly = await prisma.classSize.findMany({ select: { class_size_id: true } })
     * 
     */
    findMany<T extends ClassSizeFindManyArgs>(args?: SelectSubset<T, ClassSizeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSizePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClassSize.
     * @param {ClassSizeCreateArgs} args - Arguments to create a ClassSize.
     * @example
     * // Create one ClassSize
     * const ClassSize = await prisma.classSize.create({
     *   data: {
     *     // ... data to create a ClassSize
     *   }
     * })
     * 
     */
    create<T extends ClassSizeCreateArgs>(args: SelectSubset<T, ClassSizeCreateArgs<ExtArgs>>): Prisma__ClassSizeClient<$Result.GetResult<Prisma.$ClassSizePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClassSizes.
     * @param {ClassSizeCreateManyArgs} args - Arguments to create many ClassSizes.
     * @example
     * // Create many ClassSizes
     * const classSize = await prisma.classSize.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassSizeCreateManyArgs>(args?: SelectSubset<T, ClassSizeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassSizes and returns the data saved in the database.
     * @param {ClassSizeCreateManyAndReturnArgs} args - Arguments to create many ClassSizes.
     * @example
     * // Create many ClassSizes
     * const classSize = await prisma.classSize.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassSizes and only return the `class_size_id`
     * const classSizeWithClass_size_idOnly = await prisma.classSize.createManyAndReturn({ 
     *   select: { class_size_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassSizeCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassSizeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSizePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClassSize.
     * @param {ClassSizeDeleteArgs} args - Arguments to delete one ClassSize.
     * @example
     * // Delete one ClassSize
     * const ClassSize = await prisma.classSize.delete({
     *   where: {
     *     // ... filter to delete one ClassSize
     *   }
     * })
     * 
     */
    delete<T extends ClassSizeDeleteArgs>(args: SelectSubset<T, ClassSizeDeleteArgs<ExtArgs>>): Prisma__ClassSizeClient<$Result.GetResult<Prisma.$ClassSizePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClassSize.
     * @param {ClassSizeUpdateArgs} args - Arguments to update one ClassSize.
     * @example
     * // Update one ClassSize
     * const classSize = await prisma.classSize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassSizeUpdateArgs>(args: SelectSubset<T, ClassSizeUpdateArgs<ExtArgs>>): Prisma__ClassSizeClient<$Result.GetResult<Prisma.$ClassSizePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClassSizes.
     * @param {ClassSizeDeleteManyArgs} args - Arguments to filter ClassSizes to delete.
     * @example
     * // Delete a few ClassSizes
     * const { count } = await prisma.classSize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassSizeDeleteManyArgs>(args?: SelectSubset<T, ClassSizeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassSizes
     * const classSize = await prisma.classSize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassSizeUpdateManyArgs>(args: SelectSubset<T, ClassSizeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassSize.
     * @param {ClassSizeUpsertArgs} args - Arguments to update or create a ClassSize.
     * @example
     * // Update or create a ClassSize
     * const classSize = await prisma.classSize.upsert({
     *   create: {
     *     // ... data to create a ClassSize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassSize we want to update
     *   }
     * })
     */
    upsert<T extends ClassSizeUpsertArgs>(args: SelectSubset<T, ClassSizeUpsertArgs<ExtArgs>>): Prisma__ClassSizeClient<$Result.GetResult<Prisma.$ClassSizePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClassSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSizeCountArgs} args - Arguments to filter ClassSizes to count.
     * @example
     * // Count the number of ClassSizes
     * const count = await prisma.classSize.count({
     *   where: {
     *     // ... the filter for the ClassSizes we want to count
     *   }
     * })
    **/
    count<T extends ClassSizeCountArgs>(
      args?: Subset<T, ClassSizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassSizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassSizeAggregateArgs>(args: Subset<T, ClassSizeAggregateArgs>): Prisma.PrismaPromise<GetClassSizeAggregateType<T>>

    /**
     * Group by ClassSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassSizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassSizeGroupByArgs['orderBy'] }
        : { orderBy?: ClassSizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassSizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassSizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassSize model
   */
  readonly fields: ClassSizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassSize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassSizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends ClassSize$classesArgs<ExtArgs> = {}>(args?: Subset<T, ClassSize$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany"> | Null>
    MentorPayModel<T extends ClassSize$MentorPayModelArgs<ExtArgs> = {}>(args?: Subset<T, ClassSize$MentorPayModelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorPayModelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassSize model
   */ 
  interface ClassSizeFieldRefs {
    readonly class_size_id: FieldRef<"ClassSize", 'String'>
    readonly class_size_name: FieldRef<"ClassSize", 'ClassSizesEnum'>
  }
    

  // Custom InputTypes
  /**
   * ClassSize findUnique
   */
  export type ClassSizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSize
     */
    select?: ClassSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSizeInclude<ExtArgs> | null
    /**
     * Filter, which ClassSize to fetch.
     */
    where: ClassSizeWhereUniqueInput
  }

  /**
   * ClassSize findUniqueOrThrow
   */
  export type ClassSizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSize
     */
    select?: ClassSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSizeInclude<ExtArgs> | null
    /**
     * Filter, which ClassSize to fetch.
     */
    where: ClassSizeWhereUniqueInput
  }

  /**
   * ClassSize findFirst
   */
  export type ClassSizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSize
     */
    select?: ClassSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSizeInclude<ExtArgs> | null
    /**
     * Filter, which ClassSize to fetch.
     */
    where?: ClassSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSizes to fetch.
     */
    orderBy?: ClassSizeOrderByWithRelationInput | ClassSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSizes.
     */
    cursor?: ClassSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSizes.
     */
    distinct?: ClassSizeScalarFieldEnum | ClassSizeScalarFieldEnum[]
  }

  /**
   * ClassSize findFirstOrThrow
   */
  export type ClassSizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSize
     */
    select?: ClassSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSizeInclude<ExtArgs> | null
    /**
     * Filter, which ClassSize to fetch.
     */
    where?: ClassSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSizes to fetch.
     */
    orderBy?: ClassSizeOrderByWithRelationInput | ClassSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSizes.
     */
    cursor?: ClassSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSizes.
     */
    distinct?: ClassSizeScalarFieldEnum | ClassSizeScalarFieldEnum[]
  }

  /**
   * ClassSize findMany
   */
  export type ClassSizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSize
     */
    select?: ClassSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSizeInclude<ExtArgs> | null
    /**
     * Filter, which ClassSizes to fetch.
     */
    where?: ClassSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSizes to fetch.
     */
    orderBy?: ClassSizeOrderByWithRelationInput | ClassSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassSizes.
     */
    cursor?: ClassSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSizes.
     */
    skip?: number
    distinct?: ClassSizeScalarFieldEnum | ClassSizeScalarFieldEnum[]
  }

  /**
   * ClassSize create
   */
  export type ClassSizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSize
     */
    select?: ClassSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSizeInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassSize.
     */
    data: XOR<ClassSizeCreateInput, ClassSizeUncheckedCreateInput>
  }

  /**
   * ClassSize createMany
   */
  export type ClassSizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassSizes.
     */
    data: ClassSizeCreateManyInput | ClassSizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassSize createManyAndReturn
   */
  export type ClassSizeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSize
     */
    select?: ClassSizeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClassSizes.
     */
    data: ClassSizeCreateManyInput | ClassSizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassSize update
   */
  export type ClassSizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSize
     */
    select?: ClassSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSizeInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassSize.
     */
    data: XOR<ClassSizeUpdateInput, ClassSizeUncheckedUpdateInput>
    /**
     * Choose, which ClassSize to update.
     */
    where: ClassSizeWhereUniqueInput
  }

  /**
   * ClassSize updateMany
   */
  export type ClassSizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassSizes.
     */
    data: XOR<ClassSizeUpdateManyMutationInput, ClassSizeUncheckedUpdateManyInput>
    /**
     * Filter which ClassSizes to update
     */
    where?: ClassSizeWhereInput
  }

  /**
   * ClassSize upsert
   */
  export type ClassSizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSize
     */
    select?: ClassSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSizeInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassSize to update in case it exists.
     */
    where: ClassSizeWhereUniqueInput
    /**
     * In case the ClassSize found by the `where` argument doesn't exist, create a new ClassSize with this data.
     */
    create: XOR<ClassSizeCreateInput, ClassSizeUncheckedCreateInput>
    /**
     * In case the ClassSize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassSizeUpdateInput, ClassSizeUncheckedUpdateInput>
  }

  /**
   * ClassSize delete
   */
  export type ClassSizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSize
     */
    select?: ClassSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSizeInclude<ExtArgs> | null
    /**
     * Filter which ClassSize to delete.
     */
    where: ClassSizeWhereUniqueInput
  }

  /**
   * ClassSize deleteMany
   */
  export type ClassSizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSizes to delete
     */
    where?: ClassSizeWhereInput
  }

  /**
   * ClassSize.classes
   */
  export type ClassSize$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * ClassSize.MentorPayModel
   */
  export type ClassSize$MentorPayModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorPayModel
     */
    select?: MentorPayModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorPayModelInclude<ExtArgs> | null
    where?: MentorPayModelWhereInput
    orderBy?: MentorPayModelOrderByWithRelationInput | MentorPayModelOrderByWithRelationInput[]
    cursor?: MentorPayModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorPayModelScalarFieldEnum | MentorPayModelScalarFieldEnum[]
  }

  /**
   * ClassSize without action
   */
  export type ClassSizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSize
     */
    select?: ClassSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSizeInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseMinAggregateOutputType = {
    course_code: string | null
    course_name: string | null
    course_level_id: string | null
    created_date: Date | null
    subject_code: string | null
  }

  export type CourseMaxAggregateOutputType = {
    course_code: string | null
    course_name: string | null
    course_level_id: string | null
    created_date: Date | null
    subject_code: string | null
  }

  export type CourseCountAggregateOutputType = {
    course_code: number
    course_name: number
    course_level_id: number
    created_date: number
    subject_code: number
    _all: number
  }


  export type CourseMinAggregateInputType = {
    course_code?: true
    course_name?: true
    course_level_id?: true
    created_date?: true
    subject_code?: true
  }

  export type CourseMaxAggregateInputType = {
    course_code?: true
    course_name?: true
    course_level_id?: true
    created_date?: true
    subject_code?: true
  }

  export type CourseCountAggregateInputType = {
    course_code?: true
    course_name?: true
    course_level_id?: true
    created_date?: true
    subject_code?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    course_code: string
    course_name: string | null
    course_level_id: string
    created_date: Date | null
    subject_code: string
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    course_code?: boolean
    course_name?: boolean
    course_level_id?: boolean
    created_date?: boolean
    subject_code?: boolean
    course_level?: boolean | CourseLevelDefaultArgs<ExtArgs>
    course_advice?: boolean | Course$course_adviceArgs<ExtArgs>
    classes?: boolean | Course$classesArgs<ExtArgs>
    subject?: boolean | Course$subjectArgs<ExtArgs>
    CourseStructure?: boolean | Course$CourseStructureArgs<ExtArgs>
    CourseTask?: boolean | Course$CourseTaskArgs<ExtArgs>
    Module?: boolean | Course$ModuleArgs<ExtArgs>
    LessonCard?: boolean | Course$LessonCardArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    course_code?: boolean
    course_name?: boolean
    course_level_id?: boolean
    created_date?: boolean
    subject_code?: boolean
    course_level?: boolean | CourseLevelDefaultArgs<ExtArgs>
    subject?: boolean | Course$subjectArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    course_code?: boolean
    course_name?: boolean
    course_level_id?: boolean
    created_date?: boolean
    subject_code?: boolean
  }

  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course_level?: boolean | CourseLevelDefaultArgs<ExtArgs>
    course_advice?: boolean | Course$course_adviceArgs<ExtArgs>
    classes?: boolean | Course$classesArgs<ExtArgs>
    subject?: boolean | Course$subjectArgs<ExtArgs>
    CourseStructure?: boolean | Course$CourseStructureArgs<ExtArgs>
    CourseTask?: boolean | Course$CourseTaskArgs<ExtArgs>
    Module?: boolean | Course$ModuleArgs<ExtArgs>
    LessonCard?: boolean | Course$LessonCardArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course_level?: boolean | CourseLevelDefaultArgs<ExtArgs>
    subject?: boolean | Course$subjectArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      course_level: Prisma.$CourseLevelPayload<ExtArgs>
      course_advice: Prisma.$CourseAdvicePayload<ExtArgs>[]
      classes: Prisma.$ClassPayload<ExtArgs>[]
      subject: Prisma.$SubjectPayload<ExtArgs> | null
      CourseStructure: Prisma.$CourseStructurePayload<ExtArgs>[]
      CourseTask: Prisma.$CourseTaskPayload<ExtArgs>[]
      Module: Prisma.$ModulePayload<ExtArgs>[]
      LessonCard: Prisma.$LessonCardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      course_code: string
      course_name: string | null
      course_level_id: string
      created_date: Date | null
      subject_code: string
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `course_code`
     * const courseWithCourse_codeOnly = await prisma.course.findMany({ select: { course_code: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `course_code`
     * const courseWithCourse_codeOnly = await prisma.course.createManyAndReturn({ 
     *   select: { course_code: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course_level<T extends CourseLevelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseLevelDefaultArgs<ExtArgs>>): Prisma__CourseLevelClient<$Result.GetResult<Prisma.$CourseLevelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course_advice<T extends Course$course_adviceArgs<ExtArgs> = {}>(args?: Subset<T, Course$course_adviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseAdvicePayload<ExtArgs>, T, "findMany"> | Null>
    classes<T extends Course$classesArgs<ExtArgs> = {}>(args?: Subset<T, Course$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany"> | Null>
    subject<T extends Course$subjectArgs<ExtArgs> = {}>(args?: Subset<T, Course$subjectArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    CourseStructure<T extends Course$CourseStructureArgs<ExtArgs> = {}>(args?: Subset<T, Course$CourseStructureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseStructurePayload<ExtArgs>, T, "findMany"> | Null>
    CourseTask<T extends Course$CourseTaskArgs<ExtArgs> = {}>(args?: Subset<T, Course$CourseTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTaskPayload<ExtArgs>, T, "findMany"> | Null>
    Module<T extends Course$ModuleArgs<ExtArgs> = {}>(args?: Subset<T, Course$ModuleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany"> | Null>
    LessonCard<T extends Course$LessonCardArgs<ExtArgs> = {}>(args?: Subset<T, Course$LessonCardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCardPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */ 
  interface CourseFieldRefs {
    readonly course_code: FieldRef<"Course", 'String'>
    readonly course_name: FieldRef<"Course", 'String'>
    readonly course_level_id: FieldRef<"Course", 'String'>
    readonly created_date: FieldRef<"Course", 'DateTime'>
    readonly subject_code: FieldRef<"Course", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
  }

  /**
   * Course.course_advice
   */
  export type Course$course_adviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAdvice
     */
    select?: CourseAdviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdviceInclude<ExtArgs> | null
    where?: CourseAdviceWhereInput
    orderBy?: CourseAdviceOrderByWithRelationInput | CourseAdviceOrderByWithRelationInput[]
    cursor?: CourseAdviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseAdviceScalarFieldEnum | CourseAdviceScalarFieldEnum[]
  }

  /**
   * Course.classes
   */
  export type Course$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Course.subject
   */
  export type Course$subjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
  }

  /**
   * Course.CourseStructure
   */
  export type Course$CourseStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseStructure
     */
    select?: CourseStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseStructureInclude<ExtArgs> | null
    where?: CourseStructureWhereInput
    orderBy?: CourseStructureOrderByWithRelationInput | CourseStructureOrderByWithRelationInput[]
    cursor?: CourseStructureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseStructureScalarFieldEnum | CourseStructureScalarFieldEnum[]
  }

  /**
   * Course.CourseTask
   */
  export type Course$CourseTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTask
     */
    select?: CourseTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTaskInclude<ExtArgs> | null
    where?: CourseTaskWhereInput
    orderBy?: CourseTaskOrderByWithRelationInput | CourseTaskOrderByWithRelationInput[]
    cursor?: CourseTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseTaskScalarFieldEnum | CourseTaskScalarFieldEnum[]
  }

  /**
   * Course.Module
   */
  export type Course$ModuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Course.LessonCard
   */
  export type Course$LessonCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCard
     */
    select?: LessonCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCardInclude<ExtArgs> | null
    where?: LessonCardWhereInput
    orderBy?: LessonCardOrderByWithRelationInput | LessonCardOrderByWithRelationInput[]
    cursor?: LessonCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonCardScalarFieldEnum | LessonCardScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model CourseAdvice
   */

  export type AggregateCourseAdvice = {
    _count: CourseAdviceCountAggregateOutputType | null
    _min: CourseAdviceMinAggregateOutputType | null
    _max: CourseAdviceMaxAggregateOutputType | null
  }

  export type CourseAdviceMinAggregateOutputType = {
    advice_id: string | null
    course_code: string | null
    advice_text: string | null
    last_used_date: string | null
    created_date: string | null
  }

  export type CourseAdviceMaxAggregateOutputType = {
    advice_id: string | null
    course_code: string | null
    advice_text: string | null
    last_used_date: string | null
    created_date: string | null
  }

  export type CourseAdviceCountAggregateOutputType = {
    advice_id: number
    course_code: number
    advice_text: number
    last_used_date: number
    created_date: number
    _all: number
  }


  export type CourseAdviceMinAggregateInputType = {
    advice_id?: true
    course_code?: true
    advice_text?: true
    last_used_date?: true
    created_date?: true
  }

  export type CourseAdviceMaxAggregateInputType = {
    advice_id?: true
    course_code?: true
    advice_text?: true
    last_used_date?: true
    created_date?: true
  }

  export type CourseAdviceCountAggregateInputType = {
    advice_id?: true
    course_code?: true
    advice_text?: true
    last_used_date?: true
    created_date?: true
    _all?: true
  }

  export type CourseAdviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseAdvice to aggregate.
     */
    where?: CourseAdviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseAdvices to fetch.
     */
    orderBy?: CourseAdviceOrderByWithRelationInput | CourseAdviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseAdviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseAdvices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseAdvices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseAdvices
    **/
    _count?: true | CourseAdviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseAdviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseAdviceMaxAggregateInputType
  }

  export type GetCourseAdviceAggregateType<T extends CourseAdviceAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseAdvice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseAdvice[P]>
      : GetScalarType<T[P], AggregateCourseAdvice[P]>
  }




  export type CourseAdviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseAdviceWhereInput
    orderBy?: CourseAdviceOrderByWithAggregationInput | CourseAdviceOrderByWithAggregationInput[]
    by: CourseAdviceScalarFieldEnum[] | CourseAdviceScalarFieldEnum
    having?: CourseAdviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseAdviceCountAggregateInputType | true
    _min?: CourseAdviceMinAggregateInputType
    _max?: CourseAdviceMaxAggregateInputType
  }

  export type CourseAdviceGroupByOutputType = {
    advice_id: string
    course_code: string
    advice_text: string | null
    last_used_date: string | null
    created_date: string
    _count: CourseAdviceCountAggregateOutputType | null
    _min: CourseAdviceMinAggregateOutputType | null
    _max: CourseAdviceMaxAggregateOutputType | null
  }

  type GetCourseAdviceGroupByPayload<T extends CourseAdviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseAdviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseAdviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseAdviceGroupByOutputType[P]>
            : GetScalarType<T[P], CourseAdviceGroupByOutputType[P]>
        }
      >
    >


  export type CourseAdviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    advice_id?: boolean
    course_code?: boolean
    advice_text?: boolean
    last_used_date?: boolean
    created_date?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseAdvice"]>

  export type CourseAdviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    advice_id?: boolean
    course_code?: boolean
    advice_text?: boolean
    last_used_date?: boolean
    created_date?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseAdvice"]>

  export type CourseAdviceSelectScalar = {
    advice_id?: boolean
    course_code?: boolean
    advice_text?: boolean
    last_used_date?: boolean
    created_date?: boolean
  }

  export type CourseAdviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseAdviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CourseAdvicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseAdvice"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      advice_id: string
      course_code: string
      advice_text: string | null
      last_used_date: string | null
      created_date: string
    }, ExtArgs["result"]["courseAdvice"]>
    composites: {}
  }

  type CourseAdviceGetPayload<S extends boolean | null | undefined | CourseAdviceDefaultArgs> = $Result.GetResult<Prisma.$CourseAdvicePayload, S>

  type CourseAdviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseAdviceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseAdviceCountAggregateInputType | true
    }

  export interface CourseAdviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseAdvice'], meta: { name: 'CourseAdvice' } }
    /**
     * Find zero or one CourseAdvice that matches the filter.
     * @param {CourseAdviceFindUniqueArgs} args - Arguments to find a CourseAdvice
     * @example
     * // Get one CourseAdvice
     * const courseAdvice = await prisma.courseAdvice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseAdviceFindUniqueArgs>(args: SelectSubset<T, CourseAdviceFindUniqueArgs<ExtArgs>>): Prisma__CourseAdviceClient<$Result.GetResult<Prisma.$CourseAdvicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseAdvice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseAdviceFindUniqueOrThrowArgs} args - Arguments to find a CourseAdvice
     * @example
     * // Get one CourseAdvice
     * const courseAdvice = await prisma.courseAdvice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseAdviceFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseAdviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseAdviceClient<$Result.GetResult<Prisma.$CourseAdvicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseAdvice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAdviceFindFirstArgs} args - Arguments to find a CourseAdvice
     * @example
     * // Get one CourseAdvice
     * const courseAdvice = await prisma.courseAdvice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseAdviceFindFirstArgs>(args?: SelectSubset<T, CourseAdviceFindFirstArgs<ExtArgs>>): Prisma__CourseAdviceClient<$Result.GetResult<Prisma.$CourseAdvicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseAdvice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAdviceFindFirstOrThrowArgs} args - Arguments to find a CourseAdvice
     * @example
     * // Get one CourseAdvice
     * const courseAdvice = await prisma.courseAdvice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseAdviceFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseAdviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseAdviceClient<$Result.GetResult<Prisma.$CourseAdvicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseAdvices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAdviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseAdvices
     * const courseAdvices = await prisma.courseAdvice.findMany()
     * 
     * // Get first 10 CourseAdvices
     * const courseAdvices = await prisma.courseAdvice.findMany({ take: 10 })
     * 
     * // Only select the `advice_id`
     * const courseAdviceWithAdvice_idOnly = await prisma.courseAdvice.findMany({ select: { advice_id: true } })
     * 
     */
    findMany<T extends CourseAdviceFindManyArgs>(args?: SelectSubset<T, CourseAdviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseAdvicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseAdvice.
     * @param {CourseAdviceCreateArgs} args - Arguments to create a CourseAdvice.
     * @example
     * // Create one CourseAdvice
     * const CourseAdvice = await prisma.courseAdvice.create({
     *   data: {
     *     // ... data to create a CourseAdvice
     *   }
     * })
     * 
     */
    create<T extends CourseAdviceCreateArgs>(args: SelectSubset<T, CourseAdviceCreateArgs<ExtArgs>>): Prisma__CourseAdviceClient<$Result.GetResult<Prisma.$CourseAdvicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseAdvices.
     * @param {CourseAdviceCreateManyArgs} args - Arguments to create many CourseAdvices.
     * @example
     * // Create many CourseAdvices
     * const courseAdvice = await prisma.courseAdvice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseAdviceCreateManyArgs>(args?: SelectSubset<T, CourseAdviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseAdvices and returns the data saved in the database.
     * @param {CourseAdviceCreateManyAndReturnArgs} args - Arguments to create many CourseAdvices.
     * @example
     * // Create many CourseAdvices
     * const courseAdvice = await prisma.courseAdvice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseAdvices and only return the `advice_id`
     * const courseAdviceWithAdvice_idOnly = await prisma.courseAdvice.createManyAndReturn({ 
     *   select: { advice_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseAdviceCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseAdviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseAdvicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseAdvice.
     * @param {CourseAdviceDeleteArgs} args - Arguments to delete one CourseAdvice.
     * @example
     * // Delete one CourseAdvice
     * const CourseAdvice = await prisma.courseAdvice.delete({
     *   where: {
     *     // ... filter to delete one CourseAdvice
     *   }
     * })
     * 
     */
    delete<T extends CourseAdviceDeleteArgs>(args: SelectSubset<T, CourseAdviceDeleteArgs<ExtArgs>>): Prisma__CourseAdviceClient<$Result.GetResult<Prisma.$CourseAdvicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseAdvice.
     * @param {CourseAdviceUpdateArgs} args - Arguments to update one CourseAdvice.
     * @example
     * // Update one CourseAdvice
     * const courseAdvice = await prisma.courseAdvice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseAdviceUpdateArgs>(args: SelectSubset<T, CourseAdviceUpdateArgs<ExtArgs>>): Prisma__CourseAdviceClient<$Result.GetResult<Prisma.$CourseAdvicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseAdvices.
     * @param {CourseAdviceDeleteManyArgs} args - Arguments to filter CourseAdvices to delete.
     * @example
     * // Delete a few CourseAdvices
     * const { count } = await prisma.courseAdvice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseAdviceDeleteManyArgs>(args?: SelectSubset<T, CourseAdviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseAdvices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAdviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseAdvices
     * const courseAdvice = await prisma.courseAdvice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseAdviceUpdateManyArgs>(args: SelectSubset<T, CourseAdviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseAdvice.
     * @param {CourseAdviceUpsertArgs} args - Arguments to update or create a CourseAdvice.
     * @example
     * // Update or create a CourseAdvice
     * const courseAdvice = await prisma.courseAdvice.upsert({
     *   create: {
     *     // ... data to create a CourseAdvice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseAdvice we want to update
     *   }
     * })
     */
    upsert<T extends CourseAdviceUpsertArgs>(args: SelectSubset<T, CourseAdviceUpsertArgs<ExtArgs>>): Prisma__CourseAdviceClient<$Result.GetResult<Prisma.$CourseAdvicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseAdvices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAdviceCountArgs} args - Arguments to filter CourseAdvices to count.
     * @example
     * // Count the number of CourseAdvices
     * const count = await prisma.courseAdvice.count({
     *   where: {
     *     // ... the filter for the CourseAdvices we want to count
     *   }
     * })
    **/
    count<T extends CourseAdviceCountArgs>(
      args?: Subset<T, CourseAdviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseAdviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseAdvice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAdviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAdviceAggregateArgs>(args: Subset<T, CourseAdviceAggregateArgs>): Prisma.PrismaPromise<GetCourseAdviceAggregateType<T>>

    /**
     * Group by CourseAdvice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAdviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseAdviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseAdviceGroupByArgs['orderBy'] }
        : { orderBy?: CourseAdviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseAdviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseAdviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseAdvice model
   */
  readonly fields: CourseAdviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseAdvice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseAdviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseAdvice model
   */ 
  interface CourseAdviceFieldRefs {
    readonly advice_id: FieldRef<"CourseAdvice", 'String'>
    readonly course_code: FieldRef<"CourseAdvice", 'String'>
    readonly advice_text: FieldRef<"CourseAdvice", 'String'>
    readonly last_used_date: FieldRef<"CourseAdvice", 'String'>
    readonly created_date: FieldRef<"CourseAdvice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseAdvice findUnique
   */
  export type CourseAdviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAdvice
     */
    select?: CourseAdviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdviceInclude<ExtArgs> | null
    /**
     * Filter, which CourseAdvice to fetch.
     */
    where: CourseAdviceWhereUniqueInput
  }

  /**
   * CourseAdvice findUniqueOrThrow
   */
  export type CourseAdviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAdvice
     */
    select?: CourseAdviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdviceInclude<ExtArgs> | null
    /**
     * Filter, which CourseAdvice to fetch.
     */
    where: CourseAdviceWhereUniqueInput
  }

  /**
   * CourseAdvice findFirst
   */
  export type CourseAdviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAdvice
     */
    select?: CourseAdviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdviceInclude<ExtArgs> | null
    /**
     * Filter, which CourseAdvice to fetch.
     */
    where?: CourseAdviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseAdvices to fetch.
     */
    orderBy?: CourseAdviceOrderByWithRelationInput | CourseAdviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseAdvices.
     */
    cursor?: CourseAdviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseAdvices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseAdvices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseAdvices.
     */
    distinct?: CourseAdviceScalarFieldEnum | CourseAdviceScalarFieldEnum[]
  }

  /**
   * CourseAdvice findFirstOrThrow
   */
  export type CourseAdviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAdvice
     */
    select?: CourseAdviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdviceInclude<ExtArgs> | null
    /**
     * Filter, which CourseAdvice to fetch.
     */
    where?: CourseAdviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseAdvices to fetch.
     */
    orderBy?: CourseAdviceOrderByWithRelationInput | CourseAdviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseAdvices.
     */
    cursor?: CourseAdviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseAdvices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseAdvices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseAdvices.
     */
    distinct?: CourseAdviceScalarFieldEnum | CourseAdviceScalarFieldEnum[]
  }

  /**
   * CourseAdvice findMany
   */
  export type CourseAdviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAdvice
     */
    select?: CourseAdviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdviceInclude<ExtArgs> | null
    /**
     * Filter, which CourseAdvices to fetch.
     */
    where?: CourseAdviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseAdvices to fetch.
     */
    orderBy?: CourseAdviceOrderByWithRelationInput | CourseAdviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseAdvices.
     */
    cursor?: CourseAdviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseAdvices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseAdvices.
     */
    skip?: number
    distinct?: CourseAdviceScalarFieldEnum | CourseAdviceScalarFieldEnum[]
  }

  /**
   * CourseAdvice create
   */
  export type CourseAdviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAdvice
     */
    select?: CourseAdviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdviceInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseAdvice.
     */
    data: XOR<CourseAdviceCreateInput, CourseAdviceUncheckedCreateInput>
  }

  /**
   * CourseAdvice createMany
   */
  export type CourseAdviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseAdvices.
     */
    data: CourseAdviceCreateManyInput | CourseAdviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseAdvice createManyAndReturn
   */
  export type CourseAdviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAdvice
     */
    select?: CourseAdviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CourseAdvices.
     */
    data: CourseAdviceCreateManyInput | CourseAdviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseAdvice update
   */
  export type CourseAdviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAdvice
     */
    select?: CourseAdviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdviceInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseAdvice.
     */
    data: XOR<CourseAdviceUpdateInput, CourseAdviceUncheckedUpdateInput>
    /**
     * Choose, which CourseAdvice to update.
     */
    where: CourseAdviceWhereUniqueInput
  }

  /**
   * CourseAdvice updateMany
   */
  export type CourseAdviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseAdvices.
     */
    data: XOR<CourseAdviceUpdateManyMutationInput, CourseAdviceUncheckedUpdateManyInput>
    /**
     * Filter which CourseAdvices to update
     */
    where?: CourseAdviceWhereInput
  }

  /**
   * CourseAdvice upsert
   */
  export type CourseAdviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAdvice
     */
    select?: CourseAdviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdviceInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseAdvice to update in case it exists.
     */
    where: CourseAdviceWhereUniqueInput
    /**
     * In case the CourseAdvice found by the `where` argument doesn't exist, create a new CourseAdvice with this data.
     */
    create: XOR<CourseAdviceCreateInput, CourseAdviceUncheckedCreateInput>
    /**
     * In case the CourseAdvice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseAdviceUpdateInput, CourseAdviceUncheckedUpdateInput>
  }

  /**
   * CourseAdvice delete
   */
  export type CourseAdviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAdvice
     */
    select?: CourseAdviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdviceInclude<ExtArgs> | null
    /**
     * Filter which CourseAdvice to delete.
     */
    where: CourseAdviceWhereUniqueInput
  }

  /**
   * CourseAdvice deleteMany
   */
  export type CourseAdviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseAdvices to delete
     */
    where?: CourseAdviceWhereInput
  }

  /**
   * CourseAdvice without action
   */
  export type CourseAdviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseAdvice
     */
    select?: CourseAdviceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseAdviceInclude<ExtArgs> | null
  }


  /**
   * Model CourseTask
   */

  export type AggregateCourseTask = {
    _count: CourseTaskCountAggregateOutputType | null
    _avg: CourseTaskAvgAggregateOutputType | null
    _sum: CourseTaskSumAggregateOutputType | null
    _min: CourseTaskMinAggregateOutputType | null
    _max: CourseTaskMaxAggregateOutputType | null
  }

  export type CourseTaskAvgAggregateOutputType = {
    module_id: number | null
    section_id: number | null
    lesson_id: number | null
    task_id: number | null
  }

  export type CourseTaskSumAggregateOutputType = {
    module_id: number | null
    section_id: number | null
    lesson_id: number | null
    task_id: number | null
  }

  export type CourseTaskMinAggregateOutputType = {
    course_task_id: string | null
    course_id: string | null
    module_id: number | null
    section_id: number | null
    lesson_id: number | null
    task_id: number | null
    question: string | null
  }

  export type CourseTaskMaxAggregateOutputType = {
    course_task_id: string | null
    course_id: string | null
    module_id: number | null
    section_id: number | null
    lesson_id: number | null
    task_id: number | null
    question: string | null
  }

  export type CourseTaskCountAggregateOutputType = {
    course_task_id: number
    course_id: number
    module_id: number
    section_id: number
    lesson_id: number
    task_id: number
    question: number
    _all: number
  }


  export type CourseTaskAvgAggregateInputType = {
    module_id?: true
    section_id?: true
    lesson_id?: true
    task_id?: true
  }

  export type CourseTaskSumAggregateInputType = {
    module_id?: true
    section_id?: true
    lesson_id?: true
    task_id?: true
  }

  export type CourseTaskMinAggregateInputType = {
    course_task_id?: true
    course_id?: true
    module_id?: true
    section_id?: true
    lesson_id?: true
    task_id?: true
    question?: true
  }

  export type CourseTaskMaxAggregateInputType = {
    course_task_id?: true
    course_id?: true
    module_id?: true
    section_id?: true
    lesson_id?: true
    task_id?: true
    question?: true
  }

  export type CourseTaskCountAggregateInputType = {
    course_task_id?: true
    course_id?: true
    module_id?: true
    section_id?: true
    lesson_id?: true
    task_id?: true
    question?: true
    _all?: true
  }

  export type CourseTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseTask to aggregate.
     */
    where?: CourseTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTasks to fetch.
     */
    orderBy?: CourseTaskOrderByWithRelationInput | CourseTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseTasks
    **/
    _count?: true | CourseTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseTaskMaxAggregateInputType
  }

  export type GetCourseTaskAggregateType<T extends CourseTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseTask[P]>
      : GetScalarType<T[P], AggregateCourseTask[P]>
  }




  export type CourseTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseTaskWhereInput
    orderBy?: CourseTaskOrderByWithAggregationInput | CourseTaskOrderByWithAggregationInput[]
    by: CourseTaskScalarFieldEnum[] | CourseTaskScalarFieldEnum
    having?: CourseTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseTaskCountAggregateInputType | true
    _avg?: CourseTaskAvgAggregateInputType
    _sum?: CourseTaskSumAggregateInputType
    _min?: CourseTaskMinAggregateInputType
    _max?: CourseTaskMaxAggregateInputType
  }

  export type CourseTaskGroupByOutputType = {
    course_task_id: string
    course_id: string
    module_id: number
    section_id: number
    lesson_id: number
    task_id: number
    question: string
    _count: CourseTaskCountAggregateOutputType | null
    _avg: CourseTaskAvgAggregateOutputType | null
    _sum: CourseTaskSumAggregateOutputType | null
    _min: CourseTaskMinAggregateOutputType | null
    _max: CourseTaskMaxAggregateOutputType | null
  }

  type GetCourseTaskGroupByPayload<T extends CourseTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseTaskGroupByOutputType[P]>
            : GetScalarType<T[P], CourseTaskGroupByOutputType[P]>
        }
      >
    >


  export type CourseTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    course_task_id?: boolean
    course_id?: boolean
    module_id?: boolean
    section_id?: boolean
    lesson_id?: boolean
    task_id?: boolean
    question?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    ClassTask?: boolean | CourseTask$ClassTaskArgs<ExtArgs>
    _count?: boolean | CourseTaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseTask"]>

  export type CourseTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    course_task_id?: boolean
    course_id?: boolean
    module_id?: boolean
    section_id?: boolean
    lesson_id?: boolean
    task_id?: boolean
    question?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseTask"]>

  export type CourseTaskSelectScalar = {
    course_task_id?: boolean
    course_id?: boolean
    module_id?: boolean
    section_id?: boolean
    lesson_id?: boolean
    task_id?: boolean
    question?: boolean
  }

  export type CourseTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
    ClassTask?: boolean | CourseTask$ClassTaskArgs<ExtArgs>
    _count?: boolean | CourseTaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    section?: boolean | SectionDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $CourseTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseTask"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      module: Prisma.$ModulePayload<ExtArgs>
      section: Prisma.$SectionPayload<ExtArgs>
      lesson: Prisma.$LessonPayload<ExtArgs>
      task: Prisma.$TaskPayload<ExtArgs>
      ClassTask: Prisma.$ClassTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      course_task_id: string
      course_id: string
      module_id: number
      section_id: number
      lesson_id: number
      task_id: number
      question: string
    }, ExtArgs["result"]["courseTask"]>
    composites: {}
  }

  type CourseTaskGetPayload<S extends boolean | null | undefined | CourseTaskDefaultArgs> = $Result.GetResult<Prisma.$CourseTaskPayload, S>

  type CourseTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseTaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseTaskCountAggregateInputType | true
    }

  export interface CourseTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseTask'], meta: { name: 'CourseTask' } }
    /**
     * Find zero or one CourseTask that matches the filter.
     * @param {CourseTaskFindUniqueArgs} args - Arguments to find a CourseTask
     * @example
     * // Get one CourseTask
     * const courseTask = await prisma.courseTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseTaskFindUniqueArgs>(args: SelectSubset<T, CourseTaskFindUniqueArgs<ExtArgs>>): Prisma__CourseTaskClient<$Result.GetResult<Prisma.$CourseTaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseTask that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseTaskFindUniqueOrThrowArgs} args - Arguments to find a CourseTask
     * @example
     * // Get one CourseTask
     * const courseTask = await prisma.courseTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseTaskClient<$Result.GetResult<Prisma.$CourseTaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTaskFindFirstArgs} args - Arguments to find a CourseTask
     * @example
     * // Get one CourseTask
     * const courseTask = await prisma.courseTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseTaskFindFirstArgs>(args?: SelectSubset<T, CourseTaskFindFirstArgs<ExtArgs>>): Prisma__CourseTaskClient<$Result.GetResult<Prisma.$CourseTaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTaskFindFirstOrThrowArgs} args - Arguments to find a CourseTask
     * @example
     * // Get one CourseTask
     * const courseTask = await prisma.courseTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseTaskClient<$Result.GetResult<Prisma.$CourseTaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseTasks
     * const courseTasks = await prisma.courseTask.findMany()
     * 
     * // Get first 10 CourseTasks
     * const courseTasks = await prisma.courseTask.findMany({ take: 10 })
     * 
     * // Only select the `course_task_id`
     * const courseTaskWithCourse_task_idOnly = await prisma.courseTask.findMany({ select: { course_task_id: true } })
     * 
     */
    findMany<T extends CourseTaskFindManyArgs>(args?: SelectSubset<T, CourseTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseTask.
     * @param {CourseTaskCreateArgs} args - Arguments to create a CourseTask.
     * @example
     * // Create one CourseTask
     * const CourseTask = await prisma.courseTask.create({
     *   data: {
     *     // ... data to create a CourseTask
     *   }
     * })
     * 
     */
    create<T extends CourseTaskCreateArgs>(args: SelectSubset<T, CourseTaskCreateArgs<ExtArgs>>): Prisma__CourseTaskClient<$Result.GetResult<Prisma.$CourseTaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseTasks.
     * @param {CourseTaskCreateManyArgs} args - Arguments to create many CourseTasks.
     * @example
     * // Create many CourseTasks
     * const courseTask = await prisma.courseTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseTaskCreateManyArgs>(args?: SelectSubset<T, CourseTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseTasks and returns the data saved in the database.
     * @param {CourseTaskCreateManyAndReturnArgs} args - Arguments to create many CourseTasks.
     * @example
     * // Create many CourseTasks
     * const courseTask = await prisma.courseTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseTasks and only return the `course_task_id`
     * const courseTaskWithCourse_task_idOnly = await prisma.courseTask.createManyAndReturn({ 
     *   select: { course_task_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseTask.
     * @param {CourseTaskDeleteArgs} args - Arguments to delete one CourseTask.
     * @example
     * // Delete one CourseTask
     * const CourseTask = await prisma.courseTask.delete({
     *   where: {
     *     // ... filter to delete one CourseTask
     *   }
     * })
     * 
     */
    delete<T extends CourseTaskDeleteArgs>(args: SelectSubset<T, CourseTaskDeleteArgs<ExtArgs>>): Prisma__CourseTaskClient<$Result.GetResult<Prisma.$CourseTaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseTask.
     * @param {CourseTaskUpdateArgs} args - Arguments to update one CourseTask.
     * @example
     * // Update one CourseTask
     * const courseTask = await prisma.courseTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseTaskUpdateArgs>(args: SelectSubset<T, CourseTaskUpdateArgs<ExtArgs>>): Prisma__CourseTaskClient<$Result.GetResult<Prisma.$CourseTaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseTasks.
     * @param {CourseTaskDeleteManyArgs} args - Arguments to filter CourseTasks to delete.
     * @example
     * // Delete a few CourseTasks
     * const { count } = await prisma.courseTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseTaskDeleteManyArgs>(args?: SelectSubset<T, CourseTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseTasks
     * const courseTask = await prisma.courseTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseTaskUpdateManyArgs>(args: SelectSubset<T, CourseTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseTask.
     * @param {CourseTaskUpsertArgs} args - Arguments to update or create a CourseTask.
     * @example
     * // Update or create a CourseTask
     * const courseTask = await prisma.courseTask.upsert({
     *   create: {
     *     // ... data to create a CourseTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseTask we want to update
     *   }
     * })
     */
    upsert<T extends CourseTaskUpsertArgs>(args: SelectSubset<T, CourseTaskUpsertArgs<ExtArgs>>): Prisma__CourseTaskClient<$Result.GetResult<Prisma.$CourseTaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTaskCountArgs} args - Arguments to filter CourseTasks to count.
     * @example
     * // Count the number of CourseTasks
     * const count = await prisma.courseTask.count({
     *   where: {
     *     // ... the filter for the CourseTasks we want to count
     *   }
     * })
    **/
    count<T extends CourseTaskCountArgs>(
      args?: Subset<T, CourseTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseTaskAggregateArgs>(args: Subset<T, CourseTaskAggregateArgs>): Prisma.PrismaPromise<GetCourseTaskAggregateType<T>>

    /**
     * Group by CourseTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseTaskGroupByArgs['orderBy'] }
        : { orderBy?: CourseTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseTask model
   */
  readonly fields: CourseTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ClassTask<T extends CourseTask$ClassTaskArgs<ExtArgs> = {}>(args?: Subset<T, CourseTask$ClassTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassTaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseTask model
   */ 
  interface CourseTaskFieldRefs {
    readonly course_task_id: FieldRef<"CourseTask", 'String'>
    readonly course_id: FieldRef<"CourseTask", 'String'>
    readonly module_id: FieldRef<"CourseTask", 'Int'>
    readonly section_id: FieldRef<"CourseTask", 'Int'>
    readonly lesson_id: FieldRef<"CourseTask", 'Int'>
    readonly task_id: FieldRef<"CourseTask", 'Int'>
    readonly question: FieldRef<"CourseTask", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseTask findUnique
   */
  export type CourseTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTask
     */
    select?: CourseTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTaskInclude<ExtArgs> | null
    /**
     * Filter, which CourseTask to fetch.
     */
    where: CourseTaskWhereUniqueInput
  }

  /**
   * CourseTask findUniqueOrThrow
   */
  export type CourseTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTask
     */
    select?: CourseTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTaskInclude<ExtArgs> | null
    /**
     * Filter, which CourseTask to fetch.
     */
    where: CourseTaskWhereUniqueInput
  }

  /**
   * CourseTask findFirst
   */
  export type CourseTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTask
     */
    select?: CourseTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTaskInclude<ExtArgs> | null
    /**
     * Filter, which CourseTask to fetch.
     */
    where?: CourseTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTasks to fetch.
     */
    orderBy?: CourseTaskOrderByWithRelationInput | CourseTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseTasks.
     */
    cursor?: CourseTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseTasks.
     */
    distinct?: CourseTaskScalarFieldEnum | CourseTaskScalarFieldEnum[]
  }

  /**
   * CourseTask findFirstOrThrow
   */
  export type CourseTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTask
     */
    select?: CourseTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTaskInclude<ExtArgs> | null
    /**
     * Filter, which CourseTask to fetch.
     */
    where?: CourseTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTasks to fetch.
     */
    orderBy?: CourseTaskOrderByWithRelationInput | CourseTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseTasks.
     */
    cursor?: CourseTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseTasks.
     */
    distinct?: CourseTaskScalarFieldEnum | CourseTaskScalarFieldEnum[]
  }

  /**
   * CourseTask findMany
   */
  export type CourseTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTask
     */
    select?: CourseTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTaskInclude<ExtArgs> | null
    /**
     * Filter, which CourseTasks to fetch.
     */
    where?: CourseTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseTasks to fetch.
     */
    orderBy?: CourseTaskOrderByWithRelationInput | CourseTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseTasks.
     */
    cursor?: CourseTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseTasks.
     */
    skip?: number
    distinct?: CourseTaskScalarFieldEnum | CourseTaskScalarFieldEnum[]
  }

  /**
   * CourseTask create
   */
  export type CourseTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTask
     */
    select?: CourseTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseTask.
     */
    data: XOR<CourseTaskCreateInput, CourseTaskUncheckedCreateInput>
  }

  /**
   * CourseTask createMany
   */
  export type CourseTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseTasks.
     */
    data: CourseTaskCreateManyInput | CourseTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseTask createManyAndReturn
   */
  export type CourseTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTask
     */
    select?: CourseTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CourseTasks.
     */
    data: CourseTaskCreateManyInput | CourseTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseTask update
   */
  export type CourseTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTask
     */
    select?: CourseTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseTask.
     */
    data: XOR<CourseTaskUpdateInput, CourseTaskUncheckedUpdateInput>
    /**
     * Choose, which CourseTask to update.
     */
    where: CourseTaskWhereUniqueInput
  }

  /**
   * CourseTask updateMany
   */
  export type CourseTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseTasks.
     */
    data: XOR<CourseTaskUpdateManyMutationInput, CourseTaskUncheckedUpdateManyInput>
    /**
     * Filter which CourseTasks to update
     */
    where?: CourseTaskWhereInput
  }

  /**
   * CourseTask upsert
   */
  export type CourseTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTask
     */
    select?: CourseTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseTask to update in case it exists.
     */
    where: CourseTaskWhereUniqueInput
    /**
     * In case the CourseTask found by the `where` argument doesn't exist, create a new CourseTask with this data.
     */
    create: XOR<CourseTaskCreateInput, CourseTaskUncheckedCreateInput>
    /**
     * In case the CourseTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseTaskUpdateInput, CourseTaskUncheckedUpdateInput>
  }

  /**
   * CourseTask delete
   */
  export type CourseTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTask
     */
    select?: CourseTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTaskInclude<ExtArgs> | null
    /**
     * Filter which CourseTask to delete.
     */
    where: CourseTaskWhereUniqueInput
  }

  /**
   * CourseTask deleteMany
   */
  export type CourseTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseTasks to delete
     */
    where?: CourseTaskWhereInput
  }

  /**
   * CourseTask.ClassTask
   */
  export type CourseTask$ClassTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassTask
     */
    select?: ClassTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTaskInclude<ExtArgs> | null
    where?: ClassTaskWhereInput
    orderBy?: ClassTaskOrderByWithRelationInput | ClassTaskOrderByWithRelationInput[]
    cursor?: ClassTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassTaskScalarFieldEnum | ClassTaskScalarFieldEnum[]
  }

  /**
   * CourseTask without action
   */
  export type CourseTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTask
     */
    select?: CourseTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTaskInclude<ExtArgs> | null
  }


  /**
   * Model CourseLevel
   */

  export type AggregateCourseLevel = {
    _count: CourseLevelCountAggregateOutputType | null
    _min: CourseLevelMinAggregateOutputType | null
    _max: CourseLevelMaxAggregateOutputType | null
  }

  export type CourseLevelMinAggregateOutputType = {
    course_level_id: string | null
    course_level_name: string | null
  }

  export type CourseLevelMaxAggregateOutputType = {
    course_level_id: string | null
    course_level_name: string | null
  }

  export type CourseLevelCountAggregateOutputType = {
    course_level_id: number
    course_level_name: number
    _all: number
  }


  export type CourseLevelMinAggregateInputType = {
    course_level_id?: true
    course_level_name?: true
  }

  export type CourseLevelMaxAggregateInputType = {
    course_level_id?: true
    course_level_name?: true
  }

  export type CourseLevelCountAggregateInputType = {
    course_level_id?: true
    course_level_name?: true
    _all?: true
  }

  export type CourseLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseLevel to aggregate.
     */
    where?: CourseLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLevels to fetch.
     */
    orderBy?: CourseLevelOrderByWithRelationInput | CourseLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseLevels
    **/
    _count?: true | CourseLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseLevelMaxAggregateInputType
  }

  export type GetCourseLevelAggregateType<T extends CourseLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseLevel[P]>
      : GetScalarType<T[P], AggregateCourseLevel[P]>
  }




  export type CourseLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseLevelWhereInput
    orderBy?: CourseLevelOrderByWithAggregationInput | CourseLevelOrderByWithAggregationInput[]
    by: CourseLevelScalarFieldEnum[] | CourseLevelScalarFieldEnum
    having?: CourseLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseLevelCountAggregateInputType | true
    _min?: CourseLevelMinAggregateInputType
    _max?: CourseLevelMaxAggregateInputType
  }

  export type CourseLevelGroupByOutputType = {
    course_level_id: string
    course_level_name: string
    _count: CourseLevelCountAggregateOutputType | null
    _min: CourseLevelMinAggregateOutputType | null
    _max: CourseLevelMaxAggregateOutputType | null
  }

  type GetCourseLevelGroupByPayload<T extends CourseLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseLevelGroupByOutputType[P]>
            : GetScalarType<T[P], CourseLevelGroupByOutputType[P]>
        }
      >
    >


  export type CourseLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    course_level_id?: boolean
    course_level_name?: boolean
    course?: boolean | CourseLevel$courseArgs<ExtArgs>
    CourseLevelsPerSubject?: boolean | CourseLevel$CourseLevelsPerSubjectArgs<ExtArgs>
    _count?: boolean | CourseLevelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseLevel"]>

  export type CourseLevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    course_level_id?: boolean
    course_level_name?: boolean
  }, ExtArgs["result"]["courseLevel"]>

  export type CourseLevelSelectScalar = {
    course_level_id?: boolean
    course_level_name?: boolean
  }

  export type CourseLevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseLevel$courseArgs<ExtArgs>
    CourseLevelsPerSubject?: boolean | CourseLevel$CourseLevelsPerSubjectArgs<ExtArgs>
    _count?: boolean | CourseLevelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseLevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CourseLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseLevel"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>[]
      CourseLevelsPerSubject: Prisma.$CourseLevelsPerSubjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      course_level_id: string
      course_level_name: string
    }, ExtArgs["result"]["courseLevel"]>
    composites: {}
  }

  type CourseLevelGetPayload<S extends boolean | null | undefined | CourseLevelDefaultArgs> = $Result.GetResult<Prisma.$CourseLevelPayload, S>

  type CourseLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseLevelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseLevelCountAggregateInputType | true
    }

  export interface CourseLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseLevel'], meta: { name: 'CourseLevel' } }
    /**
     * Find zero or one CourseLevel that matches the filter.
     * @param {CourseLevelFindUniqueArgs} args - Arguments to find a CourseLevel
     * @example
     * // Get one CourseLevel
     * const courseLevel = await prisma.courseLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseLevelFindUniqueArgs>(args: SelectSubset<T, CourseLevelFindUniqueArgs<ExtArgs>>): Prisma__CourseLevelClient<$Result.GetResult<Prisma.$CourseLevelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseLevel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseLevelFindUniqueOrThrowArgs} args - Arguments to find a CourseLevel
     * @example
     * // Get one CourseLevel
     * const courseLevel = await prisma.courseLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseLevelFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseLevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseLevelClient<$Result.GetResult<Prisma.$CourseLevelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLevelFindFirstArgs} args - Arguments to find a CourseLevel
     * @example
     * // Get one CourseLevel
     * const courseLevel = await prisma.courseLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseLevelFindFirstArgs>(args?: SelectSubset<T, CourseLevelFindFirstArgs<ExtArgs>>): Prisma__CourseLevelClient<$Result.GetResult<Prisma.$CourseLevelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLevelFindFirstOrThrowArgs} args - Arguments to find a CourseLevel
     * @example
     * // Get one CourseLevel
     * const courseLevel = await prisma.courseLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseLevelFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseLevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseLevelClient<$Result.GetResult<Prisma.$CourseLevelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseLevels
     * const courseLevels = await prisma.courseLevel.findMany()
     * 
     * // Get first 10 CourseLevels
     * const courseLevels = await prisma.courseLevel.findMany({ take: 10 })
     * 
     * // Only select the `course_level_id`
     * const courseLevelWithCourse_level_idOnly = await prisma.courseLevel.findMany({ select: { course_level_id: true } })
     * 
     */
    findMany<T extends CourseLevelFindManyArgs>(args?: SelectSubset<T, CourseLevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLevelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseLevel.
     * @param {CourseLevelCreateArgs} args - Arguments to create a CourseLevel.
     * @example
     * // Create one CourseLevel
     * const CourseLevel = await prisma.courseLevel.create({
     *   data: {
     *     // ... data to create a CourseLevel
     *   }
     * })
     * 
     */
    create<T extends CourseLevelCreateArgs>(args: SelectSubset<T, CourseLevelCreateArgs<ExtArgs>>): Prisma__CourseLevelClient<$Result.GetResult<Prisma.$CourseLevelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseLevels.
     * @param {CourseLevelCreateManyArgs} args - Arguments to create many CourseLevels.
     * @example
     * // Create many CourseLevels
     * const courseLevel = await prisma.courseLevel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseLevelCreateManyArgs>(args?: SelectSubset<T, CourseLevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseLevels and returns the data saved in the database.
     * @param {CourseLevelCreateManyAndReturnArgs} args - Arguments to create many CourseLevels.
     * @example
     * // Create many CourseLevels
     * const courseLevel = await prisma.courseLevel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseLevels and only return the `course_level_id`
     * const courseLevelWithCourse_level_idOnly = await prisma.courseLevel.createManyAndReturn({ 
     *   select: { course_level_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseLevelCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseLevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLevelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseLevel.
     * @param {CourseLevelDeleteArgs} args - Arguments to delete one CourseLevel.
     * @example
     * // Delete one CourseLevel
     * const CourseLevel = await prisma.courseLevel.delete({
     *   where: {
     *     // ... filter to delete one CourseLevel
     *   }
     * })
     * 
     */
    delete<T extends CourseLevelDeleteArgs>(args: SelectSubset<T, CourseLevelDeleteArgs<ExtArgs>>): Prisma__CourseLevelClient<$Result.GetResult<Prisma.$CourseLevelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseLevel.
     * @param {CourseLevelUpdateArgs} args - Arguments to update one CourseLevel.
     * @example
     * // Update one CourseLevel
     * const courseLevel = await prisma.courseLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseLevelUpdateArgs>(args: SelectSubset<T, CourseLevelUpdateArgs<ExtArgs>>): Prisma__CourseLevelClient<$Result.GetResult<Prisma.$CourseLevelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseLevels.
     * @param {CourseLevelDeleteManyArgs} args - Arguments to filter CourseLevels to delete.
     * @example
     * // Delete a few CourseLevels
     * const { count } = await prisma.courseLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseLevelDeleteManyArgs>(args?: SelectSubset<T, CourseLevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseLevels
     * const courseLevel = await prisma.courseLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseLevelUpdateManyArgs>(args: SelectSubset<T, CourseLevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseLevel.
     * @param {CourseLevelUpsertArgs} args - Arguments to update or create a CourseLevel.
     * @example
     * // Update or create a CourseLevel
     * const courseLevel = await prisma.courseLevel.upsert({
     *   create: {
     *     // ... data to create a CourseLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseLevel we want to update
     *   }
     * })
     */
    upsert<T extends CourseLevelUpsertArgs>(args: SelectSubset<T, CourseLevelUpsertArgs<ExtArgs>>): Prisma__CourseLevelClient<$Result.GetResult<Prisma.$CourseLevelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLevelCountArgs} args - Arguments to filter CourseLevels to count.
     * @example
     * // Count the number of CourseLevels
     * const count = await prisma.courseLevel.count({
     *   where: {
     *     // ... the filter for the CourseLevels we want to count
     *   }
     * })
    **/
    count<T extends CourseLevelCountArgs>(
      args?: Subset<T, CourseLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseLevelAggregateArgs>(args: Subset<T, CourseLevelAggregateArgs>): Prisma.PrismaPromise<GetCourseLevelAggregateType<T>>

    /**
     * Group by CourseLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseLevelGroupByArgs['orderBy'] }
        : { orderBy?: CourseLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseLevel model
   */
  readonly fields: CourseLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseLevel$courseArgs<ExtArgs> = {}>(args?: Subset<T, CourseLevel$courseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany"> | Null>
    CourseLevelsPerSubject<T extends CourseLevel$CourseLevelsPerSubjectArgs<ExtArgs> = {}>(args?: Subset<T, CourseLevel$CourseLevelsPerSubjectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLevelsPerSubjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseLevel model
   */ 
  interface CourseLevelFieldRefs {
    readonly course_level_id: FieldRef<"CourseLevel", 'String'>
    readonly course_level_name: FieldRef<"CourseLevel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseLevel findUnique
   */
  export type CourseLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevel
     */
    select?: CourseLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelInclude<ExtArgs> | null
    /**
     * Filter, which CourseLevel to fetch.
     */
    where: CourseLevelWhereUniqueInput
  }

  /**
   * CourseLevel findUniqueOrThrow
   */
  export type CourseLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevel
     */
    select?: CourseLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelInclude<ExtArgs> | null
    /**
     * Filter, which CourseLevel to fetch.
     */
    where: CourseLevelWhereUniqueInput
  }

  /**
   * CourseLevel findFirst
   */
  export type CourseLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevel
     */
    select?: CourseLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelInclude<ExtArgs> | null
    /**
     * Filter, which CourseLevel to fetch.
     */
    where?: CourseLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLevels to fetch.
     */
    orderBy?: CourseLevelOrderByWithRelationInput | CourseLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseLevels.
     */
    cursor?: CourseLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseLevels.
     */
    distinct?: CourseLevelScalarFieldEnum | CourseLevelScalarFieldEnum[]
  }

  /**
   * CourseLevel findFirstOrThrow
   */
  export type CourseLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevel
     */
    select?: CourseLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelInclude<ExtArgs> | null
    /**
     * Filter, which CourseLevel to fetch.
     */
    where?: CourseLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLevels to fetch.
     */
    orderBy?: CourseLevelOrderByWithRelationInput | CourseLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseLevels.
     */
    cursor?: CourseLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseLevels.
     */
    distinct?: CourseLevelScalarFieldEnum | CourseLevelScalarFieldEnum[]
  }

  /**
   * CourseLevel findMany
   */
  export type CourseLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevel
     */
    select?: CourseLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelInclude<ExtArgs> | null
    /**
     * Filter, which CourseLevels to fetch.
     */
    where?: CourseLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLevels to fetch.
     */
    orderBy?: CourseLevelOrderByWithRelationInput | CourseLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseLevels.
     */
    cursor?: CourseLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLevels.
     */
    skip?: number
    distinct?: CourseLevelScalarFieldEnum | CourseLevelScalarFieldEnum[]
  }

  /**
   * CourseLevel create
   */
  export type CourseLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevel
     */
    select?: CourseLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseLevel.
     */
    data: XOR<CourseLevelCreateInput, CourseLevelUncheckedCreateInput>
  }

  /**
   * CourseLevel createMany
   */
  export type CourseLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseLevels.
     */
    data: CourseLevelCreateManyInput | CourseLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseLevel createManyAndReturn
   */
  export type CourseLevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevel
     */
    select?: CourseLevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CourseLevels.
     */
    data: CourseLevelCreateManyInput | CourseLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseLevel update
   */
  export type CourseLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevel
     */
    select?: CourseLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseLevel.
     */
    data: XOR<CourseLevelUpdateInput, CourseLevelUncheckedUpdateInput>
    /**
     * Choose, which CourseLevel to update.
     */
    where: CourseLevelWhereUniqueInput
  }

  /**
   * CourseLevel updateMany
   */
  export type CourseLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseLevels.
     */
    data: XOR<CourseLevelUpdateManyMutationInput, CourseLevelUncheckedUpdateManyInput>
    /**
     * Filter which CourseLevels to update
     */
    where?: CourseLevelWhereInput
  }

  /**
   * CourseLevel upsert
   */
  export type CourseLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevel
     */
    select?: CourseLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseLevel to update in case it exists.
     */
    where: CourseLevelWhereUniqueInput
    /**
     * In case the CourseLevel found by the `where` argument doesn't exist, create a new CourseLevel with this data.
     */
    create: XOR<CourseLevelCreateInput, CourseLevelUncheckedCreateInput>
    /**
     * In case the CourseLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseLevelUpdateInput, CourseLevelUncheckedUpdateInput>
  }

  /**
   * CourseLevel delete
   */
  export type CourseLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevel
     */
    select?: CourseLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelInclude<ExtArgs> | null
    /**
     * Filter which CourseLevel to delete.
     */
    where: CourseLevelWhereUniqueInput
  }

  /**
   * CourseLevel deleteMany
   */
  export type CourseLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseLevels to delete
     */
    where?: CourseLevelWhereInput
  }

  /**
   * CourseLevel.course
   */
  export type CourseLevel$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * CourseLevel.CourseLevelsPerSubject
   */
  export type CourseLevel$CourseLevelsPerSubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevelsPerSubject
     */
    select?: CourseLevelsPerSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelsPerSubjectInclude<ExtArgs> | null
    where?: CourseLevelsPerSubjectWhereInput
    orderBy?: CourseLevelsPerSubjectOrderByWithRelationInput | CourseLevelsPerSubjectOrderByWithRelationInput[]
    cursor?: CourseLevelsPerSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseLevelsPerSubjectScalarFieldEnum | CourseLevelsPerSubjectScalarFieldEnum[]
  }

  /**
   * CourseLevel without action
   */
  export type CourseLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevel
     */
    select?: CourseLevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelInclude<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectMinAggregateOutputType = {
    subject_code: string | null
    subject_name: string | null
  }

  export type SubjectMaxAggregateOutputType = {
    subject_code: string | null
    subject_name: string | null
  }

  export type SubjectCountAggregateOutputType = {
    subject_code: number
    subject_name: number
    _all: number
  }


  export type SubjectMinAggregateInputType = {
    subject_code?: true
    subject_name?: true
  }

  export type SubjectMaxAggregateInputType = {
    subject_code?: true
    subject_name?: true
  }

  export type SubjectCountAggregateInputType = {
    subject_code?: true
    subject_name?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    subject_code: string
    subject_name: string
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subject_code?: boolean
    subject_name?: boolean
    Course?: boolean | Subject$CourseArgs<ExtArgs>
    CourseLevelsPerSubject?: boolean | Subject$CourseLevelsPerSubjectArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subject_code?: boolean
    subject_name?: boolean
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectScalar = {
    subject_code?: boolean
    subject_name?: boolean
  }

  export type SubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Course?: boolean | Subject$CourseArgs<ExtArgs>
    CourseLevelsPerSubject?: boolean | Subject$CourseLevelsPerSubjectArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {
      Course: Prisma.$CoursePayload<ExtArgs>[]
      CourseLevelsPerSubject: Prisma.$CourseLevelsPerSubjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      subject_code: string
      subject_name: string
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `subject_code`
     * const subjectWithSubject_codeOnly = await prisma.subject.findMany({ select: { subject_code: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {SubjectCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subjects and only return the `subject_code`
     * const subjectWithSubject_codeOnly = await prisma.subject.createManyAndReturn({ 
     *   select: { subject_code: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Course<T extends Subject$CourseArgs<ExtArgs> = {}>(args?: Subset<T, Subject$CourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany"> | Null>
    CourseLevelsPerSubject<T extends Subject$CourseLevelsPerSubjectArgs<ExtArgs> = {}>(args?: Subset<T, Subject$CourseLevelsPerSubjectArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLevelsPerSubjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */ 
  interface SubjectFieldRefs {
    readonly subject_code: FieldRef<"Subject", 'String'>
    readonly subject_name: FieldRef<"Subject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subject createManyAndReturn
   */
  export type SubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
  }

  /**
   * Subject.Course
   */
  export type Subject$CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Subject.CourseLevelsPerSubject
   */
  export type Subject$CourseLevelsPerSubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevelsPerSubject
     */
    select?: CourseLevelsPerSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelsPerSubjectInclude<ExtArgs> | null
    where?: CourseLevelsPerSubjectWhereInput
    orderBy?: CourseLevelsPerSubjectOrderByWithRelationInput | CourseLevelsPerSubjectOrderByWithRelationInput[]
    cursor?: CourseLevelsPerSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseLevelsPerSubjectScalarFieldEnum | CourseLevelsPerSubjectScalarFieldEnum[]
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
  }


  /**
   * Model CourseLevelsPerSubject
   */

  export type AggregateCourseLevelsPerSubject = {
    _count: CourseLevelsPerSubjectCountAggregateOutputType | null
    _min: CourseLevelsPerSubjectMinAggregateOutputType | null
    _max: CourseLevelsPerSubjectMaxAggregateOutputType | null
  }

  export type CourseLevelsPerSubjectMinAggregateOutputType = {
    course_level_id: string | null
    subject_code: string | null
  }

  export type CourseLevelsPerSubjectMaxAggregateOutputType = {
    course_level_id: string | null
    subject_code: string | null
  }

  export type CourseLevelsPerSubjectCountAggregateOutputType = {
    course_level_id: number
    subject_code: number
    _all: number
  }


  export type CourseLevelsPerSubjectMinAggregateInputType = {
    course_level_id?: true
    subject_code?: true
  }

  export type CourseLevelsPerSubjectMaxAggregateInputType = {
    course_level_id?: true
    subject_code?: true
  }

  export type CourseLevelsPerSubjectCountAggregateInputType = {
    course_level_id?: true
    subject_code?: true
    _all?: true
  }

  export type CourseLevelsPerSubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseLevelsPerSubject to aggregate.
     */
    where?: CourseLevelsPerSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLevelsPerSubjects to fetch.
     */
    orderBy?: CourseLevelsPerSubjectOrderByWithRelationInput | CourseLevelsPerSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseLevelsPerSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLevelsPerSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLevelsPerSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseLevelsPerSubjects
    **/
    _count?: true | CourseLevelsPerSubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseLevelsPerSubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseLevelsPerSubjectMaxAggregateInputType
  }

  export type GetCourseLevelsPerSubjectAggregateType<T extends CourseLevelsPerSubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseLevelsPerSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseLevelsPerSubject[P]>
      : GetScalarType<T[P], AggregateCourseLevelsPerSubject[P]>
  }




  export type CourseLevelsPerSubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseLevelsPerSubjectWhereInput
    orderBy?: CourseLevelsPerSubjectOrderByWithAggregationInput | CourseLevelsPerSubjectOrderByWithAggregationInput[]
    by: CourseLevelsPerSubjectScalarFieldEnum[] | CourseLevelsPerSubjectScalarFieldEnum
    having?: CourseLevelsPerSubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseLevelsPerSubjectCountAggregateInputType | true
    _min?: CourseLevelsPerSubjectMinAggregateInputType
    _max?: CourseLevelsPerSubjectMaxAggregateInputType
  }

  export type CourseLevelsPerSubjectGroupByOutputType = {
    course_level_id: string
    subject_code: string
    _count: CourseLevelsPerSubjectCountAggregateOutputType | null
    _min: CourseLevelsPerSubjectMinAggregateOutputType | null
    _max: CourseLevelsPerSubjectMaxAggregateOutputType | null
  }

  type GetCourseLevelsPerSubjectGroupByPayload<T extends CourseLevelsPerSubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseLevelsPerSubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseLevelsPerSubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseLevelsPerSubjectGroupByOutputType[P]>
            : GetScalarType<T[P], CourseLevelsPerSubjectGroupByOutputType[P]>
        }
      >
    >


  export type CourseLevelsPerSubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    course_level_id?: boolean
    subject_code?: boolean
    course_level?: boolean | CourseLevelDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseLevelsPerSubject"]>

  export type CourseLevelsPerSubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    course_level_id?: boolean
    subject_code?: boolean
    course_level?: boolean | CourseLevelDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseLevelsPerSubject"]>

  export type CourseLevelsPerSubjectSelectScalar = {
    course_level_id?: boolean
    subject_code?: boolean
  }

  export type CourseLevelsPerSubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course_level?: boolean | CourseLevelDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type CourseLevelsPerSubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course_level?: boolean | CourseLevelDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $CourseLevelsPerSubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseLevelsPerSubject"
    objects: {
      course_level: Prisma.$CourseLevelPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      course_level_id: string
      subject_code: string
    }, ExtArgs["result"]["courseLevelsPerSubject"]>
    composites: {}
  }

  type CourseLevelsPerSubjectGetPayload<S extends boolean | null | undefined | CourseLevelsPerSubjectDefaultArgs> = $Result.GetResult<Prisma.$CourseLevelsPerSubjectPayload, S>

  type CourseLevelsPerSubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseLevelsPerSubjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseLevelsPerSubjectCountAggregateInputType | true
    }

  export interface CourseLevelsPerSubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseLevelsPerSubject'], meta: { name: 'CourseLevelsPerSubject' } }
    /**
     * Find zero or one CourseLevelsPerSubject that matches the filter.
     * @param {CourseLevelsPerSubjectFindUniqueArgs} args - Arguments to find a CourseLevelsPerSubject
     * @example
     * // Get one CourseLevelsPerSubject
     * const courseLevelsPerSubject = await prisma.courseLevelsPerSubject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseLevelsPerSubjectFindUniqueArgs>(args: SelectSubset<T, CourseLevelsPerSubjectFindUniqueArgs<ExtArgs>>): Prisma__CourseLevelsPerSubjectClient<$Result.GetResult<Prisma.$CourseLevelsPerSubjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseLevelsPerSubject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseLevelsPerSubjectFindUniqueOrThrowArgs} args - Arguments to find a CourseLevelsPerSubject
     * @example
     * // Get one CourseLevelsPerSubject
     * const courseLevelsPerSubject = await prisma.courseLevelsPerSubject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseLevelsPerSubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseLevelsPerSubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseLevelsPerSubjectClient<$Result.GetResult<Prisma.$CourseLevelsPerSubjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseLevelsPerSubject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLevelsPerSubjectFindFirstArgs} args - Arguments to find a CourseLevelsPerSubject
     * @example
     * // Get one CourseLevelsPerSubject
     * const courseLevelsPerSubject = await prisma.courseLevelsPerSubject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseLevelsPerSubjectFindFirstArgs>(args?: SelectSubset<T, CourseLevelsPerSubjectFindFirstArgs<ExtArgs>>): Prisma__CourseLevelsPerSubjectClient<$Result.GetResult<Prisma.$CourseLevelsPerSubjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseLevelsPerSubject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLevelsPerSubjectFindFirstOrThrowArgs} args - Arguments to find a CourseLevelsPerSubject
     * @example
     * // Get one CourseLevelsPerSubject
     * const courseLevelsPerSubject = await prisma.courseLevelsPerSubject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseLevelsPerSubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseLevelsPerSubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseLevelsPerSubjectClient<$Result.GetResult<Prisma.$CourseLevelsPerSubjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseLevelsPerSubjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLevelsPerSubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseLevelsPerSubjects
     * const courseLevelsPerSubjects = await prisma.courseLevelsPerSubject.findMany()
     * 
     * // Get first 10 CourseLevelsPerSubjects
     * const courseLevelsPerSubjects = await prisma.courseLevelsPerSubject.findMany({ take: 10 })
     * 
     * // Only select the `course_level_id`
     * const courseLevelsPerSubjectWithCourse_level_idOnly = await prisma.courseLevelsPerSubject.findMany({ select: { course_level_id: true } })
     * 
     */
    findMany<T extends CourseLevelsPerSubjectFindManyArgs>(args?: SelectSubset<T, CourseLevelsPerSubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLevelsPerSubjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseLevelsPerSubject.
     * @param {CourseLevelsPerSubjectCreateArgs} args - Arguments to create a CourseLevelsPerSubject.
     * @example
     * // Create one CourseLevelsPerSubject
     * const CourseLevelsPerSubject = await prisma.courseLevelsPerSubject.create({
     *   data: {
     *     // ... data to create a CourseLevelsPerSubject
     *   }
     * })
     * 
     */
    create<T extends CourseLevelsPerSubjectCreateArgs>(args: SelectSubset<T, CourseLevelsPerSubjectCreateArgs<ExtArgs>>): Prisma__CourseLevelsPerSubjectClient<$Result.GetResult<Prisma.$CourseLevelsPerSubjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseLevelsPerSubjects.
     * @param {CourseLevelsPerSubjectCreateManyArgs} args - Arguments to create many CourseLevelsPerSubjects.
     * @example
     * // Create many CourseLevelsPerSubjects
     * const courseLevelsPerSubject = await prisma.courseLevelsPerSubject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseLevelsPerSubjectCreateManyArgs>(args?: SelectSubset<T, CourseLevelsPerSubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseLevelsPerSubjects and returns the data saved in the database.
     * @param {CourseLevelsPerSubjectCreateManyAndReturnArgs} args - Arguments to create many CourseLevelsPerSubjects.
     * @example
     * // Create many CourseLevelsPerSubjects
     * const courseLevelsPerSubject = await prisma.courseLevelsPerSubject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseLevelsPerSubjects and only return the `course_level_id`
     * const courseLevelsPerSubjectWithCourse_level_idOnly = await prisma.courseLevelsPerSubject.createManyAndReturn({ 
     *   select: { course_level_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseLevelsPerSubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseLevelsPerSubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseLevelsPerSubjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseLevelsPerSubject.
     * @param {CourseLevelsPerSubjectDeleteArgs} args - Arguments to delete one CourseLevelsPerSubject.
     * @example
     * // Delete one CourseLevelsPerSubject
     * const CourseLevelsPerSubject = await prisma.courseLevelsPerSubject.delete({
     *   where: {
     *     // ... filter to delete one CourseLevelsPerSubject
     *   }
     * })
     * 
     */
    delete<T extends CourseLevelsPerSubjectDeleteArgs>(args: SelectSubset<T, CourseLevelsPerSubjectDeleteArgs<ExtArgs>>): Prisma__CourseLevelsPerSubjectClient<$Result.GetResult<Prisma.$CourseLevelsPerSubjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseLevelsPerSubject.
     * @param {CourseLevelsPerSubjectUpdateArgs} args - Arguments to update one CourseLevelsPerSubject.
     * @example
     * // Update one CourseLevelsPerSubject
     * const courseLevelsPerSubject = await prisma.courseLevelsPerSubject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseLevelsPerSubjectUpdateArgs>(args: SelectSubset<T, CourseLevelsPerSubjectUpdateArgs<ExtArgs>>): Prisma__CourseLevelsPerSubjectClient<$Result.GetResult<Prisma.$CourseLevelsPerSubjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseLevelsPerSubjects.
     * @param {CourseLevelsPerSubjectDeleteManyArgs} args - Arguments to filter CourseLevelsPerSubjects to delete.
     * @example
     * // Delete a few CourseLevelsPerSubjects
     * const { count } = await prisma.courseLevelsPerSubject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseLevelsPerSubjectDeleteManyArgs>(args?: SelectSubset<T, CourseLevelsPerSubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseLevelsPerSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLevelsPerSubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseLevelsPerSubjects
     * const courseLevelsPerSubject = await prisma.courseLevelsPerSubject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseLevelsPerSubjectUpdateManyArgs>(args: SelectSubset<T, CourseLevelsPerSubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseLevelsPerSubject.
     * @param {CourseLevelsPerSubjectUpsertArgs} args - Arguments to update or create a CourseLevelsPerSubject.
     * @example
     * // Update or create a CourseLevelsPerSubject
     * const courseLevelsPerSubject = await prisma.courseLevelsPerSubject.upsert({
     *   create: {
     *     // ... data to create a CourseLevelsPerSubject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseLevelsPerSubject we want to update
     *   }
     * })
     */
    upsert<T extends CourseLevelsPerSubjectUpsertArgs>(args: SelectSubset<T, CourseLevelsPerSubjectUpsertArgs<ExtArgs>>): Prisma__CourseLevelsPerSubjectClient<$Result.GetResult<Prisma.$CourseLevelsPerSubjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseLevelsPerSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLevelsPerSubjectCountArgs} args - Arguments to filter CourseLevelsPerSubjects to count.
     * @example
     * // Count the number of CourseLevelsPerSubjects
     * const count = await prisma.courseLevelsPerSubject.count({
     *   where: {
     *     // ... the filter for the CourseLevelsPerSubjects we want to count
     *   }
     * })
    **/
    count<T extends CourseLevelsPerSubjectCountArgs>(
      args?: Subset<T, CourseLevelsPerSubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseLevelsPerSubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseLevelsPerSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLevelsPerSubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseLevelsPerSubjectAggregateArgs>(args: Subset<T, CourseLevelsPerSubjectAggregateArgs>): Prisma.PrismaPromise<GetCourseLevelsPerSubjectAggregateType<T>>

    /**
     * Group by CourseLevelsPerSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseLevelsPerSubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseLevelsPerSubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseLevelsPerSubjectGroupByArgs['orderBy'] }
        : { orderBy?: CourseLevelsPerSubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseLevelsPerSubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseLevelsPerSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseLevelsPerSubject model
   */
  readonly fields: CourseLevelsPerSubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseLevelsPerSubject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseLevelsPerSubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course_level<T extends CourseLevelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseLevelDefaultArgs<ExtArgs>>): Prisma__CourseLevelClient<$Result.GetResult<Prisma.$CourseLevelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseLevelsPerSubject model
   */ 
  interface CourseLevelsPerSubjectFieldRefs {
    readonly course_level_id: FieldRef<"CourseLevelsPerSubject", 'String'>
    readonly subject_code: FieldRef<"CourseLevelsPerSubject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseLevelsPerSubject findUnique
   */
  export type CourseLevelsPerSubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevelsPerSubject
     */
    select?: CourseLevelsPerSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelsPerSubjectInclude<ExtArgs> | null
    /**
     * Filter, which CourseLevelsPerSubject to fetch.
     */
    where: CourseLevelsPerSubjectWhereUniqueInput
  }

  /**
   * CourseLevelsPerSubject findUniqueOrThrow
   */
  export type CourseLevelsPerSubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevelsPerSubject
     */
    select?: CourseLevelsPerSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelsPerSubjectInclude<ExtArgs> | null
    /**
     * Filter, which CourseLevelsPerSubject to fetch.
     */
    where: CourseLevelsPerSubjectWhereUniqueInput
  }

  /**
   * CourseLevelsPerSubject findFirst
   */
  export type CourseLevelsPerSubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevelsPerSubject
     */
    select?: CourseLevelsPerSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelsPerSubjectInclude<ExtArgs> | null
    /**
     * Filter, which CourseLevelsPerSubject to fetch.
     */
    where?: CourseLevelsPerSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLevelsPerSubjects to fetch.
     */
    orderBy?: CourseLevelsPerSubjectOrderByWithRelationInput | CourseLevelsPerSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseLevelsPerSubjects.
     */
    cursor?: CourseLevelsPerSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLevelsPerSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLevelsPerSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseLevelsPerSubjects.
     */
    distinct?: CourseLevelsPerSubjectScalarFieldEnum | CourseLevelsPerSubjectScalarFieldEnum[]
  }

  /**
   * CourseLevelsPerSubject findFirstOrThrow
   */
  export type CourseLevelsPerSubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevelsPerSubject
     */
    select?: CourseLevelsPerSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelsPerSubjectInclude<ExtArgs> | null
    /**
     * Filter, which CourseLevelsPerSubject to fetch.
     */
    where?: CourseLevelsPerSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLevelsPerSubjects to fetch.
     */
    orderBy?: CourseLevelsPerSubjectOrderByWithRelationInput | CourseLevelsPerSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseLevelsPerSubjects.
     */
    cursor?: CourseLevelsPerSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLevelsPerSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLevelsPerSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseLevelsPerSubjects.
     */
    distinct?: CourseLevelsPerSubjectScalarFieldEnum | CourseLevelsPerSubjectScalarFieldEnum[]
  }

  /**
   * CourseLevelsPerSubject findMany
   */
  export type CourseLevelsPerSubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevelsPerSubject
     */
    select?: CourseLevelsPerSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelsPerSubjectInclude<ExtArgs> | null
    /**
     * Filter, which CourseLevelsPerSubjects to fetch.
     */
    where?: CourseLevelsPerSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseLevelsPerSubjects to fetch.
     */
    orderBy?: CourseLevelsPerSubjectOrderByWithRelationInput | CourseLevelsPerSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseLevelsPerSubjects.
     */
    cursor?: CourseLevelsPerSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseLevelsPerSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseLevelsPerSubjects.
     */
    skip?: number
    distinct?: CourseLevelsPerSubjectScalarFieldEnum | CourseLevelsPerSubjectScalarFieldEnum[]
  }

  /**
   * CourseLevelsPerSubject create
   */
  export type CourseLevelsPerSubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevelsPerSubject
     */
    select?: CourseLevelsPerSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelsPerSubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseLevelsPerSubject.
     */
    data: XOR<CourseLevelsPerSubjectCreateInput, CourseLevelsPerSubjectUncheckedCreateInput>
  }

  /**
   * CourseLevelsPerSubject createMany
   */
  export type CourseLevelsPerSubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseLevelsPerSubjects.
     */
    data: CourseLevelsPerSubjectCreateManyInput | CourseLevelsPerSubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseLevelsPerSubject createManyAndReturn
   */
  export type CourseLevelsPerSubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevelsPerSubject
     */
    select?: CourseLevelsPerSubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CourseLevelsPerSubjects.
     */
    data: CourseLevelsPerSubjectCreateManyInput | CourseLevelsPerSubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelsPerSubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseLevelsPerSubject update
   */
  export type CourseLevelsPerSubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevelsPerSubject
     */
    select?: CourseLevelsPerSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelsPerSubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseLevelsPerSubject.
     */
    data: XOR<CourseLevelsPerSubjectUpdateInput, CourseLevelsPerSubjectUncheckedUpdateInput>
    /**
     * Choose, which CourseLevelsPerSubject to update.
     */
    where: CourseLevelsPerSubjectWhereUniqueInput
  }

  /**
   * CourseLevelsPerSubject updateMany
   */
  export type CourseLevelsPerSubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseLevelsPerSubjects.
     */
    data: XOR<CourseLevelsPerSubjectUpdateManyMutationInput, CourseLevelsPerSubjectUncheckedUpdateManyInput>
    /**
     * Filter which CourseLevelsPerSubjects to update
     */
    where?: CourseLevelsPerSubjectWhereInput
  }

  /**
   * CourseLevelsPerSubject upsert
   */
  export type CourseLevelsPerSubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevelsPerSubject
     */
    select?: CourseLevelsPerSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelsPerSubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseLevelsPerSubject to update in case it exists.
     */
    where: CourseLevelsPerSubjectWhereUniqueInput
    /**
     * In case the CourseLevelsPerSubject found by the `where` argument doesn't exist, create a new CourseLevelsPerSubject with this data.
     */
    create: XOR<CourseLevelsPerSubjectCreateInput, CourseLevelsPerSubjectUncheckedCreateInput>
    /**
     * In case the CourseLevelsPerSubject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseLevelsPerSubjectUpdateInput, CourseLevelsPerSubjectUncheckedUpdateInput>
  }

  /**
   * CourseLevelsPerSubject delete
   */
  export type CourseLevelsPerSubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevelsPerSubject
     */
    select?: CourseLevelsPerSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelsPerSubjectInclude<ExtArgs> | null
    /**
     * Filter which CourseLevelsPerSubject to delete.
     */
    where: CourseLevelsPerSubjectWhereUniqueInput
  }

  /**
   * CourseLevelsPerSubject deleteMany
   */
  export type CourseLevelsPerSubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseLevelsPerSubjects to delete
     */
    where?: CourseLevelsPerSubjectWhereInput
  }

  /**
   * CourseLevelsPerSubject without action
   */
  export type CourseLevelsPerSubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseLevelsPerSubject
     */
    select?: CourseLevelsPerSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseLevelsPerSubjectInclude<ExtArgs> | null
  }


  /**
   * Model Lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonAvgAggregateOutputType = {
    lesson_id: number | null
    lesson_order: number | null
    section_id: number | null
    moduleModule_id: number | null
  }

  export type LessonSumAggregateOutputType = {
    lesson_id: number | null
    lesson_order: number | null
    section_id: number | null
    moduleModule_id: number | null
  }

  export type LessonMinAggregateOutputType = {
    lesson_id: number | null
    lesson_name: string | null
    lesson_description: string | null
    lesson_order: number | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean | null
    section_id: number | null
    moduleModule_id: number | null
  }

  export type LessonMaxAggregateOutputType = {
    lesson_id: number | null
    lesson_name: string | null
    lesson_description: string | null
    lesson_order: number | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean | null
    section_id: number | null
    moduleModule_id: number | null
  }

  export type LessonCountAggregateOutputType = {
    lesson_id: number
    lesson_name: number
    lesson_description: number
    lesson_order: number
    created_date: number
    updated_date: number
    deleted: number
    section_id: number
    moduleModule_id: number
    _all: number
  }


  export type LessonAvgAggregateInputType = {
    lesson_id?: true
    lesson_order?: true
    section_id?: true
    moduleModule_id?: true
  }

  export type LessonSumAggregateInputType = {
    lesson_id?: true
    lesson_order?: true
    section_id?: true
    moduleModule_id?: true
  }

  export type LessonMinAggregateInputType = {
    lesson_id?: true
    lesson_name?: true
    lesson_description?: true
    lesson_order?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    section_id?: true
    moduleModule_id?: true
  }

  export type LessonMaxAggregateInputType = {
    lesson_id?: true
    lesson_name?: true
    lesson_description?: true
    lesson_order?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    section_id?: true
    moduleModule_id?: true
  }

  export type LessonCountAggregateInputType = {
    lesson_id?: true
    lesson_name?: true
    lesson_description?: true
    lesson_order?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    section_id?: true
    moduleModule_id?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithAggregationInput | LessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _avg?: LessonAvgAggregateInputType
    _sum?: LessonSumAggregateInputType
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    lesson_id: number
    lesson_name: string
    lesson_description: string | null
    lesson_order: number
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean
    section_id: number
    moduleModule_id: number | null
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lesson_id?: boolean
    lesson_name?: boolean
    lesson_description?: boolean
    lesson_order?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    section_id?: boolean
    moduleModule_id?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
    tasks?: boolean | Lesson$tasksArgs<ExtArgs>
    CourseStructure?: boolean | Lesson$CourseStructureArgs<ExtArgs>
    CourseTask?: boolean | Lesson$CourseTaskArgs<ExtArgs>
    Module?: boolean | Lesson$ModuleArgs<ExtArgs>
    LessonCard?: boolean | Lesson$LessonCardArgs<ExtArgs>
    UserCard?: boolean | Lesson$UserCardArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lesson_id?: boolean
    lesson_name?: boolean
    lesson_description?: boolean
    lesson_order?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    section_id?: boolean
    moduleModule_id?: boolean
    section?: boolean | SectionDefaultArgs<ExtArgs>
    Module?: boolean | Lesson$ModuleArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    lesson_id?: boolean
    lesson_name?: boolean
    lesson_description?: boolean
    lesson_order?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    section_id?: boolean
    moduleModule_id?: boolean
  }

  export type LessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
    tasks?: boolean | Lesson$tasksArgs<ExtArgs>
    CourseStructure?: boolean | Lesson$CourseStructureArgs<ExtArgs>
    CourseTask?: boolean | Lesson$CourseTaskArgs<ExtArgs>
    Module?: boolean | Lesson$ModuleArgs<ExtArgs>
    LessonCard?: boolean | Lesson$LessonCardArgs<ExtArgs>
    UserCard?: boolean | Lesson$UserCardArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | SectionDefaultArgs<ExtArgs>
    Module?: boolean | Lesson$ModuleArgs<ExtArgs>
  }

  export type $LessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lesson"
    objects: {
      section: Prisma.$SectionPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      CourseStructure: Prisma.$CourseStructurePayload<ExtArgs>[]
      CourseTask: Prisma.$CourseTaskPayload<ExtArgs>[]
      Module: Prisma.$ModulePayload<ExtArgs> | null
      LessonCard: Prisma.$LessonCardPayload<ExtArgs>[]
      UserCard: Prisma.$UserCardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      lesson_id: number
      lesson_name: string
      lesson_description: string | null
      lesson_order: number
      created_date: Date | null
      updated_date: Date | null
      deleted: boolean
      section_id: number
      moduleModule_id: number | null
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }

  type LessonGetPayload<S extends boolean | null | undefined | LessonDefaultArgs> = $Result.GetResult<Prisma.$LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LessonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonFindUniqueArgs>(args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lesson that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonFindFirstArgs>(args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `lesson_id`
     * const lessonWithLesson_idOnly = await prisma.lesson.findMany({ select: { lesson_id: true } })
     * 
     */
    findMany<T extends LessonFindManyArgs>(args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
     */
    create<T extends LessonCreateArgs>(args: SelectSubset<T, LessonCreateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lessons.
     * @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCreateManyArgs>(args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `lesson_id`
     * const lessonWithLesson_idOnly = await prisma.lesson.createManyAndReturn({ 
     *   select: { lesson_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
     */
    delete<T extends LessonDeleteArgs>(args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonUpdateArgs>(args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonDeleteManyArgs>(args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonUpdateManyArgs>(args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
     */
    upsert<T extends LessonUpsertArgs>(args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lesson model
   */
  readonly fields: LessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends SectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionDefaultArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tasks<T extends Lesson$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    CourseStructure<T extends Lesson$CourseStructureArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$CourseStructureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseStructurePayload<ExtArgs>, T, "findMany"> | Null>
    CourseTask<T extends Lesson$CourseTaskArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$CourseTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTaskPayload<ExtArgs>, T, "findMany"> | Null>
    Module<T extends Lesson$ModuleArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$ModuleArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    LessonCard<T extends Lesson$LessonCardArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$LessonCardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCardPayload<ExtArgs>, T, "findMany"> | Null>
    UserCard<T extends Lesson$UserCardArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$UserCardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lesson model
   */ 
  interface LessonFieldRefs {
    readonly lesson_id: FieldRef<"Lesson", 'Int'>
    readonly lesson_name: FieldRef<"Lesson", 'String'>
    readonly lesson_description: FieldRef<"Lesson", 'String'>
    readonly lesson_order: FieldRef<"Lesson", 'Int'>
    readonly created_date: FieldRef<"Lesson", 'DateTime'>
    readonly updated_date: FieldRef<"Lesson", 'DateTime'>
    readonly deleted: FieldRef<"Lesson", 'Boolean'>
    readonly section_id: FieldRef<"Lesson", 'Int'>
    readonly moduleModule_id: FieldRef<"Lesson", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Lesson findUnique
   */
  export type LessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findFirst
   */
  export type LessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }

  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lesson createManyAndReturn
   */
  export type LessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
  }

  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }

  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
  }

  /**
   * Lesson.tasks
   */
  export type Lesson$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Lesson.CourseStructure
   */
  export type Lesson$CourseStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseStructure
     */
    select?: CourseStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseStructureInclude<ExtArgs> | null
    where?: CourseStructureWhereInput
    orderBy?: CourseStructureOrderByWithRelationInput | CourseStructureOrderByWithRelationInput[]
    cursor?: CourseStructureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseStructureScalarFieldEnum | CourseStructureScalarFieldEnum[]
  }

  /**
   * Lesson.CourseTask
   */
  export type Lesson$CourseTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTask
     */
    select?: CourseTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTaskInclude<ExtArgs> | null
    where?: CourseTaskWhereInput
    orderBy?: CourseTaskOrderByWithRelationInput | CourseTaskOrderByWithRelationInput[]
    cursor?: CourseTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseTaskScalarFieldEnum | CourseTaskScalarFieldEnum[]
  }

  /**
   * Lesson.Module
   */
  export type Lesson$ModuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
  }

  /**
   * Lesson.LessonCard
   */
  export type Lesson$LessonCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCard
     */
    select?: LessonCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCardInclude<ExtArgs> | null
    where?: LessonCardWhereInput
    orderBy?: LessonCardOrderByWithRelationInput | LessonCardOrderByWithRelationInput[]
    cursor?: LessonCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonCardScalarFieldEnum | LessonCardScalarFieldEnum[]
  }

  /**
   * Lesson.UserCard
   */
  export type Lesson$UserCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    where?: UserCardWhereInput
    orderBy?: UserCardOrderByWithRelationInput | UserCardOrderByWithRelationInput[]
    cursor?: UserCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCardScalarFieldEnum | UserCardScalarFieldEnum[]
  }

  /**
   * Lesson without action
   */
  export type LessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
  }


  /**
   * Model Mentor
   */

  export type AggregateMentor = {
    _count: MentorCountAggregateOutputType | null
    _min: MentorMinAggregateOutputType | null
    _max: MentorMaxAggregateOutputType | null
  }

  export type MentorMinAggregateOutputType = {
    mentor_id: string | null
    user_id: string | null
    mentor_description_en: string | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean | null
  }

  export type MentorMaxAggregateOutputType = {
    mentor_id: string | null
    user_id: string | null
    mentor_description_en: string | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean | null
  }

  export type MentorCountAggregateOutputType = {
    mentor_id: number
    user_id: number
    mentor_description_en: number
    created_date: number
    updated_date: number
    deleted: number
    _all: number
  }


  export type MentorMinAggregateInputType = {
    mentor_id?: true
    user_id?: true
    mentor_description_en?: true
    created_date?: true
    updated_date?: true
    deleted?: true
  }

  export type MentorMaxAggregateInputType = {
    mentor_id?: true
    user_id?: true
    mentor_description_en?: true
    created_date?: true
    updated_date?: true
    deleted?: true
  }

  export type MentorCountAggregateInputType = {
    mentor_id?: true
    user_id?: true
    mentor_description_en?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    _all?: true
  }

  export type MentorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mentor to aggregate.
     */
    where?: MentorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentors to fetch.
     */
    orderBy?: MentorOrderByWithRelationInput | MentorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mentors
    **/
    _count?: true | MentorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorMaxAggregateInputType
  }

  export type GetMentorAggregateType<T extends MentorAggregateArgs> = {
        [P in keyof T & keyof AggregateMentor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentor[P]>
      : GetScalarType<T[P], AggregateMentor[P]>
  }




  export type MentorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorWhereInput
    orderBy?: MentorOrderByWithAggregationInput | MentorOrderByWithAggregationInput[]
    by: MentorScalarFieldEnum[] | MentorScalarFieldEnum
    having?: MentorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorCountAggregateInputType | true
    _min?: MentorMinAggregateInputType
    _max?: MentorMaxAggregateInputType
  }

  export type MentorGroupByOutputType = {
    mentor_id: string
    user_id: string
    mentor_description_en: string | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean
    _count: MentorCountAggregateOutputType | null
    _min: MentorMinAggregateOutputType | null
    _max: MentorMaxAggregateOutputType | null
  }

  type GetMentorGroupByPayload<T extends MentorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorGroupByOutputType[P]>
            : GetScalarType<T[P], MentorGroupByOutputType[P]>
        }
      >
    >


  export type MentorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mentor_id?: boolean
    user_id?: boolean
    mentor_description_en?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    mentor_classes?: boolean | Mentor$mentor_classesArgs<ExtArgs>
    MentorPayModel?: boolean | Mentor$MentorPayModelArgs<ExtArgs>
    _count?: boolean | MentorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentor"]>

  export type MentorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mentor_id?: boolean
    user_id?: boolean
    mentor_description_en?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentor"]>

  export type MentorSelectScalar = {
    mentor_id?: boolean
    user_id?: boolean
    mentor_description_en?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
  }

  export type MentorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    mentor_classes?: boolean | Mentor$mentor_classesArgs<ExtArgs>
    MentorPayModel?: boolean | Mentor$MentorPayModelArgs<ExtArgs>
    _count?: boolean | MentorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MentorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MentorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mentor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      mentor_classes: Prisma.$MentorsClassesPayload<ExtArgs>[]
      MentorPayModel: Prisma.$MentorPayModelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      mentor_id: string
      user_id: string
      mentor_description_en: string | null
      created_date: Date | null
      updated_date: Date | null
      deleted: boolean
    }, ExtArgs["result"]["mentor"]>
    composites: {}
  }

  type MentorGetPayload<S extends boolean | null | undefined | MentorDefaultArgs> = $Result.GetResult<Prisma.$MentorPayload, S>

  type MentorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MentorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MentorCountAggregateInputType | true
    }

  export interface MentorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mentor'], meta: { name: 'Mentor' } }
    /**
     * Find zero or one Mentor that matches the filter.
     * @param {MentorFindUniqueArgs} args - Arguments to find a Mentor
     * @example
     * // Get one Mentor
     * const mentor = await prisma.mentor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorFindUniqueArgs>(args: SelectSubset<T, MentorFindUniqueArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mentor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MentorFindUniqueOrThrowArgs} args - Arguments to find a Mentor
     * @example
     * // Get one Mentor
     * const mentor = await prisma.mentor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorFindUniqueOrThrowArgs>(args: SelectSubset<T, MentorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mentor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorFindFirstArgs} args - Arguments to find a Mentor
     * @example
     * // Get one Mentor
     * const mentor = await prisma.mentor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorFindFirstArgs>(args?: SelectSubset<T, MentorFindFirstArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mentor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorFindFirstOrThrowArgs} args - Arguments to find a Mentor
     * @example
     * // Get one Mentor
     * const mentor = await prisma.mentor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorFindFirstOrThrowArgs>(args?: SelectSubset<T, MentorFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mentors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mentors
     * const mentors = await prisma.mentor.findMany()
     * 
     * // Get first 10 Mentors
     * const mentors = await prisma.mentor.findMany({ take: 10 })
     * 
     * // Only select the `mentor_id`
     * const mentorWithMentor_idOnly = await prisma.mentor.findMany({ select: { mentor_id: true } })
     * 
     */
    findMany<T extends MentorFindManyArgs>(args?: SelectSubset<T, MentorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mentor.
     * @param {MentorCreateArgs} args - Arguments to create a Mentor.
     * @example
     * // Create one Mentor
     * const Mentor = await prisma.mentor.create({
     *   data: {
     *     // ... data to create a Mentor
     *   }
     * })
     * 
     */
    create<T extends MentorCreateArgs>(args: SelectSubset<T, MentorCreateArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mentors.
     * @param {MentorCreateManyArgs} args - Arguments to create many Mentors.
     * @example
     * // Create many Mentors
     * const mentor = await prisma.mentor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentorCreateManyArgs>(args?: SelectSubset<T, MentorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mentors and returns the data saved in the database.
     * @param {MentorCreateManyAndReturnArgs} args - Arguments to create many Mentors.
     * @example
     * // Create many Mentors
     * const mentor = await prisma.mentor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mentors and only return the `mentor_id`
     * const mentorWithMentor_idOnly = await prisma.mentor.createManyAndReturn({ 
     *   select: { mentor_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentorCreateManyAndReturnArgs>(args?: SelectSubset<T, MentorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Mentor.
     * @param {MentorDeleteArgs} args - Arguments to delete one Mentor.
     * @example
     * // Delete one Mentor
     * const Mentor = await prisma.mentor.delete({
     *   where: {
     *     // ... filter to delete one Mentor
     *   }
     * })
     * 
     */
    delete<T extends MentorDeleteArgs>(args: SelectSubset<T, MentorDeleteArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mentor.
     * @param {MentorUpdateArgs} args - Arguments to update one Mentor.
     * @example
     * // Update one Mentor
     * const mentor = await prisma.mentor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentorUpdateArgs>(args: SelectSubset<T, MentorUpdateArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mentors.
     * @param {MentorDeleteManyArgs} args - Arguments to filter Mentors to delete.
     * @example
     * // Delete a few Mentors
     * const { count } = await prisma.mentor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentorDeleteManyArgs>(args?: SelectSubset<T, MentorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mentors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mentors
     * const mentor = await prisma.mentor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentorUpdateManyArgs>(args: SelectSubset<T, MentorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mentor.
     * @param {MentorUpsertArgs} args - Arguments to update or create a Mentor.
     * @example
     * // Update or create a Mentor
     * const mentor = await prisma.mentor.upsert({
     *   create: {
     *     // ... data to create a Mentor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mentor we want to update
     *   }
     * })
     */
    upsert<T extends MentorUpsertArgs>(args: SelectSubset<T, MentorUpsertArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Mentors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorCountArgs} args - Arguments to filter Mentors to count.
     * @example
     * // Count the number of Mentors
     * const count = await prisma.mentor.count({
     *   where: {
     *     // ... the filter for the Mentors we want to count
     *   }
     * })
    **/
    count<T extends MentorCountArgs>(
      args?: Subset<T, MentorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mentor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorAggregateArgs>(args: Subset<T, MentorAggregateArgs>): Prisma.PrismaPromise<GetMentorAggregateType<T>>

    /**
     * Group by Mentor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorGroupByArgs['orderBy'] }
        : { orderBy?: MentorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mentor model
   */
  readonly fields: MentorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mentor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mentor_classes<T extends Mentor$mentor_classesArgs<ExtArgs> = {}>(args?: Subset<T, Mentor$mentor_classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorsClassesPayload<ExtArgs>, T, "findMany"> | Null>
    MentorPayModel<T extends Mentor$MentorPayModelArgs<ExtArgs> = {}>(args?: Subset<T, Mentor$MentorPayModelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorPayModelPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mentor model
   */ 
  interface MentorFieldRefs {
    readonly mentor_id: FieldRef<"Mentor", 'String'>
    readonly user_id: FieldRef<"Mentor", 'String'>
    readonly mentor_description_en: FieldRef<"Mentor", 'String'>
    readonly created_date: FieldRef<"Mentor", 'DateTime'>
    readonly updated_date: FieldRef<"Mentor", 'DateTime'>
    readonly deleted: FieldRef<"Mentor", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Mentor findUnique
   */
  export type MentorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * Filter, which Mentor to fetch.
     */
    where: MentorWhereUniqueInput
  }

  /**
   * Mentor findUniqueOrThrow
   */
  export type MentorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * Filter, which Mentor to fetch.
     */
    where: MentorWhereUniqueInput
  }

  /**
   * Mentor findFirst
   */
  export type MentorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * Filter, which Mentor to fetch.
     */
    where?: MentorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentors to fetch.
     */
    orderBy?: MentorOrderByWithRelationInput | MentorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentors.
     */
    cursor?: MentorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentors.
     */
    distinct?: MentorScalarFieldEnum | MentorScalarFieldEnum[]
  }

  /**
   * Mentor findFirstOrThrow
   */
  export type MentorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * Filter, which Mentor to fetch.
     */
    where?: MentorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentors to fetch.
     */
    orderBy?: MentorOrderByWithRelationInput | MentorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentors.
     */
    cursor?: MentorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentors.
     */
    distinct?: MentorScalarFieldEnum | MentorScalarFieldEnum[]
  }

  /**
   * Mentor findMany
   */
  export type MentorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * Filter, which Mentors to fetch.
     */
    where?: MentorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentors to fetch.
     */
    orderBy?: MentorOrderByWithRelationInput | MentorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mentors.
     */
    cursor?: MentorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentors.
     */
    skip?: number
    distinct?: MentorScalarFieldEnum | MentorScalarFieldEnum[]
  }

  /**
   * Mentor create
   */
  export type MentorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * The data needed to create a Mentor.
     */
    data: XOR<MentorCreateInput, MentorUncheckedCreateInput>
  }

  /**
   * Mentor createMany
   */
  export type MentorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mentors.
     */
    data: MentorCreateManyInput | MentorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mentor createManyAndReturn
   */
  export type MentorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Mentors.
     */
    data: MentorCreateManyInput | MentorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mentor update
   */
  export type MentorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * The data needed to update a Mentor.
     */
    data: XOR<MentorUpdateInput, MentorUncheckedUpdateInput>
    /**
     * Choose, which Mentor to update.
     */
    where: MentorWhereUniqueInput
  }

  /**
   * Mentor updateMany
   */
  export type MentorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mentors.
     */
    data: XOR<MentorUpdateManyMutationInput, MentorUncheckedUpdateManyInput>
    /**
     * Filter which Mentors to update
     */
    where?: MentorWhereInput
  }

  /**
   * Mentor upsert
   */
  export type MentorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * The filter to search for the Mentor to update in case it exists.
     */
    where: MentorWhereUniqueInput
    /**
     * In case the Mentor found by the `where` argument doesn't exist, create a new Mentor with this data.
     */
    create: XOR<MentorCreateInput, MentorUncheckedCreateInput>
    /**
     * In case the Mentor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentorUpdateInput, MentorUncheckedUpdateInput>
  }

  /**
   * Mentor delete
   */
  export type MentorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
    /**
     * Filter which Mentor to delete.
     */
    where: MentorWhereUniqueInput
  }

  /**
   * Mentor deleteMany
   */
  export type MentorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mentors to delete
     */
    where?: MentorWhereInput
  }

  /**
   * Mentor.mentor_classes
   */
  export type Mentor$mentor_classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorsClasses
     */
    select?: MentorsClassesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorsClassesInclude<ExtArgs> | null
    where?: MentorsClassesWhereInput
    orderBy?: MentorsClassesOrderByWithRelationInput | MentorsClassesOrderByWithRelationInput[]
    cursor?: MentorsClassesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorsClassesScalarFieldEnum | MentorsClassesScalarFieldEnum[]
  }

  /**
   * Mentor.MentorPayModel
   */
  export type Mentor$MentorPayModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorPayModel
     */
    select?: MentorPayModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorPayModelInclude<ExtArgs> | null
    where?: MentorPayModelWhereInput
    orderBy?: MentorPayModelOrderByWithRelationInput | MentorPayModelOrderByWithRelationInput[]
    cursor?: MentorPayModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorPayModelScalarFieldEnum | MentorPayModelScalarFieldEnum[]
  }

  /**
   * Mentor without action
   */
  export type MentorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentor
     */
    select?: MentorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorInclude<ExtArgs> | null
  }


  /**
   * Model MentorsClasses
   */

  export type AggregateMentorsClasses = {
    _count: MentorsClassesCountAggregateOutputType | null
    _min: MentorsClassesMinAggregateOutputType | null
    _max: MentorsClassesMaxAggregateOutputType | null
  }

  export type MentorsClassesMinAggregateOutputType = {
    mentor_id: string | null
    class_id: string | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean | null
  }

  export type MentorsClassesMaxAggregateOutputType = {
    mentor_id: string | null
    class_id: string | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean | null
  }

  export type MentorsClassesCountAggregateOutputType = {
    mentor_id: number
    class_id: number
    created_date: number
    updated_date: number
    deleted: number
    _all: number
  }


  export type MentorsClassesMinAggregateInputType = {
    mentor_id?: true
    class_id?: true
    created_date?: true
    updated_date?: true
    deleted?: true
  }

  export type MentorsClassesMaxAggregateInputType = {
    mentor_id?: true
    class_id?: true
    created_date?: true
    updated_date?: true
    deleted?: true
  }

  export type MentorsClassesCountAggregateInputType = {
    mentor_id?: true
    class_id?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    _all?: true
  }

  export type MentorsClassesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorsClasses to aggregate.
     */
    where?: MentorsClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorsClasses to fetch.
     */
    orderBy?: MentorsClassesOrderByWithRelationInput | MentorsClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentorsClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorsClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorsClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MentorsClasses
    **/
    _count?: true | MentorsClassesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorsClassesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorsClassesMaxAggregateInputType
  }

  export type GetMentorsClassesAggregateType<T extends MentorsClassesAggregateArgs> = {
        [P in keyof T & keyof AggregateMentorsClasses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentorsClasses[P]>
      : GetScalarType<T[P], AggregateMentorsClasses[P]>
  }




  export type MentorsClassesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorsClassesWhereInput
    orderBy?: MentorsClassesOrderByWithAggregationInput | MentorsClassesOrderByWithAggregationInput[]
    by: MentorsClassesScalarFieldEnum[] | MentorsClassesScalarFieldEnum
    having?: MentorsClassesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorsClassesCountAggregateInputType | true
    _min?: MentorsClassesMinAggregateInputType
    _max?: MentorsClassesMaxAggregateInputType
  }

  export type MentorsClassesGroupByOutputType = {
    mentor_id: string
    class_id: string
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean
    _count: MentorsClassesCountAggregateOutputType | null
    _min: MentorsClassesMinAggregateOutputType | null
    _max: MentorsClassesMaxAggregateOutputType | null
  }

  type GetMentorsClassesGroupByPayload<T extends MentorsClassesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorsClassesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorsClassesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorsClassesGroupByOutputType[P]>
            : GetScalarType<T[P], MentorsClassesGroupByOutputType[P]>
        }
      >
    >


  export type MentorsClassesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mentor_id?: boolean
    class_id?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    mentor?: boolean | MentorDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorsClasses"]>

  export type MentorsClassesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mentor_id?: boolean
    class_id?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    mentor?: boolean | MentorDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorsClasses"]>

  export type MentorsClassesSelectScalar = {
    mentor_id?: boolean
    class_id?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
  }

  export type MentorsClassesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentor?: boolean | MentorDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type MentorsClassesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentor?: boolean | MentorDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $MentorsClassesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MentorsClasses"
    objects: {
      mentor: Prisma.$MentorPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      mentor_id: string
      class_id: string
      created_date: Date | null
      updated_date: Date | null
      deleted: boolean
    }, ExtArgs["result"]["mentorsClasses"]>
    composites: {}
  }

  type MentorsClassesGetPayload<S extends boolean | null | undefined | MentorsClassesDefaultArgs> = $Result.GetResult<Prisma.$MentorsClassesPayload, S>

  type MentorsClassesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MentorsClassesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MentorsClassesCountAggregateInputType | true
    }

  export interface MentorsClassesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MentorsClasses'], meta: { name: 'MentorsClasses' } }
    /**
     * Find zero or one MentorsClasses that matches the filter.
     * @param {MentorsClassesFindUniqueArgs} args - Arguments to find a MentorsClasses
     * @example
     * // Get one MentorsClasses
     * const mentorsClasses = await prisma.mentorsClasses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorsClassesFindUniqueArgs>(args: SelectSubset<T, MentorsClassesFindUniqueArgs<ExtArgs>>): Prisma__MentorsClassesClient<$Result.GetResult<Prisma.$MentorsClassesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MentorsClasses that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MentorsClassesFindUniqueOrThrowArgs} args - Arguments to find a MentorsClasses
     * @example
     * // Get one MentorsClasses
     * const mentorsClasses = await prisma.mentorsClasses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorsClassesFindUniqueOrThrowArgs>(args: SelectSubset<T, MentorsClassesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentorsClassesClient<$Result.GetResult<Prisma.$MentorsClassesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MentorsClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorsClassesFindFirstArgs} args - Arguments to find a MentorsClasses
     * @example
     * // Get one MentorsClasses
     * const mentorsClasses = await prisma.mentorsClasses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorsClassesFindFirstArgs>(args?: SelectSubset<T, MentorsClassesFindFirstArgs<ExtArgs>>): Prisma__MentorsClassesClient<$Result.GetResult<Prisma.$MentorsClassesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MentorsClasses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorsClassesFindFirstOrThrowArgs} args - Arguments to find a MentorsClasses
     * @example
     * // Get one MentorsClasses
     * const mentorsClasses = await prisma.mentorsClasses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorsClassesFindFirstOrThrowArgs>(args?: SelectSubset<T, MentorsClassesFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentorsClassesClient<$Result.GetResult<Prisma.$MentorsClassesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MentorsClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorsClassesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MentorsClasses
     * const mentorsClasses = await prisma.mentorsClasses.findMany()
     * 
     * // Get first 10 MentorsClasses
     * const mentorsClasses = await prisma.mentorsClasses.findMany({ take: 10 })
     * 
     * // Only select the `mentor_id`
     * const mentorsClassesWithMentor_idOnly = await prisma.mentorsClasses.findMany({ select: { mentor_id: true } })
     * 
     */
    findMany<T extends MentorsClassesFindManyArgs>(args?: SelectSubset<T, MentorsClassesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorsClassesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MentorsClasses.
     * @param {MentorsClassesCreateArgs} args - Arguments to create a MentorsClasses.
     * @example
     * // Create one MentorsClasses
     * const MentorsClasses = await prisma.mentorsClasses.create({
     *   data: {
     *     // ... data to create a MentorsClasses
     *   }
     * })
     * 
     */
    create<T extends MentorsClassesCreateArgs>(args: SelectSubset<T, MentorsClassesCreateArgs<ExtArgs>>): Prisma__MentorsClassesClient<$Result.GetResult<Prisma.$MentorsClassesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MentorsClasses.
     * @param {MentorsClassesCreateManyArgs} args - Arguments to create many MentorsClasses.
     * @example
     * // Create many MentorsClasses
     * const mentorsClasses = await prisma.mentorsClasses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentorsClassesCreateManyArgs>(args?: SelectSubset<T, MentorsClassesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MentorsClasses and returns the data saved in the database.
     * @param {MentorsClassesCreateManyAndReturnArgs} args - Arguments to create many MentorsClasses.
     * @example
     * // Create many MentorsClasses
     * const mentorsClasses = await prisma.mentorsClasses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MentorsClasses and only return the `mentor_id`
     * const mentorsClassesWithMentor_idOnly = await prisma.mentorsClasses.createManyAndReturn({ 
     *   select: { mentor_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentorsClassesCreateManyAndReturnArgs>(args?: SelectSubset<T, MentorsClassesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorsClassesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MentorsClasses.
     * @param {MentorsClassesDeleteArgs} args - Arguments to delete one MentorsClasses.
     * @example
     * // Delete one MentorsClasses
     * const MentorsClasses = await prisma.mentorsClasses.delete({
     *   where: {
     *     // ... filter to delete one MentorsClasses
     *   }
     * })
     * 
     */
    delete<T extends MentorsClassesDeleteArgs>(args: SelectSubset<T, MentorsClassesDeleteArgs<ExtArgs>>): Prisma__MentorsClassesClient<$Result.GetResult<Prisma.$MentorsClassesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MentorsClasses.
     * @param {MentorsClassesUpdateArgs} args - Arguments to update one MentorsClasses.
     * @example
     * // Update one MentorsClasses
     * const mentorsClasses = await prisma.mentorsClasses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentorsClassesUpdateArgs>(args: SelectSubset<T, MentorsClassesUpdateArgs<ExtArgs>>): Prisma__MentorsClassesClient<$Result.GetResult<Prisma.$MentorsClassesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MentorsClasses.
     * @param {MentorsClassesDeleteManyArgs} args - Arguments to filter MentorsClasses to delete.
     * @example
     * // Delete a few MentorsClasses
     * const { count } = await prisma.mentorsClasses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentorsClassesDeleteManyArgs>(args?: SelectSubset<T, MentorsClassesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorsClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorsClassesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MentorsClasses
     * const mentorsClasses = await prisma.mentorsClasses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentorsClassesUpdateManyArgs>(args: SelectSubset<T, MentorsClassesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MentorsClasses.
     * @param {MentorsClassesUpsertArgs} args - Arguments to update or create a MentorsClasses.
     * @example
     * // Update or create a MentorsClasses
     * const mentorsClasses = await prisma.mentorsClasses.upsert({
     *   create: {
     *     // ... data to create a MentorsClasses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MentorsClasses we want to update
     *   }
     * })
     */
    upsert<T extends MentorsClassesUpsertArgs>(args: SelectSubset<T, MentorsClassesUpsertArgs<ExtArgs>>): Prisma__MentorsClassesClient<$Result.GetResult<Prisma.$MentorsClassesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MentorsClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorsClassesCountArgs} args - Arguments to filter MentorsClasses to count.
     * @example
     * // Count the number of MentorsClasses
     * const count = await prisma.mentorsClasses.count({
     *   where: {
     *     // ... the filter for the MentorsClasses we want to count
     *   }
     * })
    **/
    count<T extends MentorsClassesCountArgs>(
      args?: Subset<T, MentorsClassesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorsClassesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MentorsClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorsClassesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorsClassesAggregateArgs>(args: Subset<T, MentorsClassesAggregateArgs>): Prisma.PrismaPromise<GetMentorsClassesAggregateType<T>>

    /**
     * Group by MentorsClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorsClassesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentorsClassesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorsClassesGroupByArgs['orderBy'] }
        : { orderBy?: MentorsClassesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentorsClassesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorsClassesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MentorsClasses model
   */
  readonly fields: MentorsClassesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MentorsClasses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorsClassesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentor<T extends MentorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MentorDefaultArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MentorsClasses model
   */ 
  interface MentorsClassesFieldRefs {
    readonly mentor_id: FieldRef<"MentorsClasses", 'String'>
    readonly class_id: FieldRef<"MentorsClasses", 'String'>
    readonly created_date: FieldRef<"MentorsClasses", 'DateTime'>
    readonly updated_date: FieldRef<"MentorsClasses", 'DateTime'>
    readonly deleted: FieldRef<"MentorsClasses", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * MentorsClasses findUnique
   */
  export type MentorsClassesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorsClasses
     */
    select?: MentorsClassesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorsClassesInclude<ExtArgs> | null
    /**
     * Filter, which MentorsClasses to fetch.
     */
    where: MentorsClassesWhereUniqueInput
  }

  /**
   * MentorsClasses findUniqueOrThrow
   */
  export type MentorsClassesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorsClasses
     */
    select?: MentorsClassesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorsClassesInclude<ExtArgs> | null
    /**
     * Filter, which MentorsClasses to fetch.
     */
    where: MentorsClassesWhereUniqueInput
  }

  /**
   * MentorsClasses findFirst
   */
  export type MentorsClassesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorsClasses
     */
    select?: MentorsClassesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorsClassesInclude<ExtArgs> | null
    /**
     * Filter, which MentorsClasses to fetch.
     */
    where?: MentorsClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorsClasses to fetch.
     */
    orderBy?: MentorsClassesOrderByWithRelationInput | MentorsClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorsClasses.
     */
    cursor?: MentorsClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorsClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorsClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorsClasses.
     */
    distinct?: MentorsClassesScalarFieldEnum | MentorsClassesScalarFieldEnum[]
  }

  /**
   * MentorsClasses findFirstOrThrow
   */
  export type MentorsClassesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorsClasses
     */
    select?: MentorsClassesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorsClassesInclude<ExtArgs> | null
    /**
     * Filter, which MentorsClasses to fetch.
     */
    where?: MentorsClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorsClasses to fetch.
     */
    orderBy?: MentorsClassesOrderByWithRelationInput | MentorsClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorsClasses.
     */
    cursor?: MentorsClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorsClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorsClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorsClasses.
     */
    distinct?: MentorsClassesScalarFieldEnum | MentorsClassesScalarFieldEnum[]
  }

  /**
   * MentorsClasses findMany
   */
  export type MentorsClassesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorsClasses
     */
    select?: MentorsClassesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorsClassesInclude<ExtArgs> | null
    /**
     * Filter, which MentorsClasses to fetch.
     */
    where?: MentorsClassesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorsClasses to fetch.
     */
    orderBy?: MentorsClassesOrderByWithRelationInput | MentorsClassesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MentorsClasses.
     */
    cursor?: MentorsClassesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorsClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorsClasses.
     */
    skip?: number
    distinct?: MentorsClassesScalarFieldEnum | MentorsClassesScalarFieldEnum[]
  }

  /**
   * MentorsClasses create
   */
  export type MentorsClassesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorsClasses
     */
    select?: MentorsClassesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorsClassesInclude<ExtArgs> | null
    /**
     * The data needed to create a MentorsClasses.
     */
    data: XOR<MentorsClassesCreateInput, MentorsClassesUncheckedCreateInput>
  }

  /**
   * MentorsClasses createMany
   */
  export type MentorsClassesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MentorsClasses.
     */
    data: MentorsClassesCreateManyInput | MentorsClassesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MentorsClasses createManyAndReturn
   */
  export type MentorsClassesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorsClasses
     */
    select?: MentorsClassesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MentorsClasses.
     */
    data: MentorsClassesCreateManyInput | MentorsClassesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorsClassesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorsClasses update
   */
  export type MentorsClassesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorsClasses
     */
    select?: MentorsClassesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorsClassesInclude<ExtArgs> | null
    /**
     * The data needed to update a MentorsClasses.
     */
    data: XOR<MentorsClassesUpdateInput, MentorsClassesUncheckedUpdateInput>
    /**
     * Choose, which MentorsClasses to update.
     */
    where: MentorsClassesWhereUniqueInput
  }

  /**
   * MentorsClasses updateMany
   */
  export type MentorsClassesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MentorsClasses.
     */
    data: XOR<MentorsClassesUpdateManyMutationInput, MentorsClassesUncheckedUpdateManyInput>
    /**
     * Filter which MentorsClasses to update
     */
    where?: MentorsClassesWhereInput
  }

  /**
   * MentorsClasses upsert
   */
  export type MentorsClassesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorsClasses
     */
    select?: MentorsClassesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorsClassesInclude<ExtArgs> | null
    /**
     * The filter to search for the MentorsClasses to update in case it exists.
     */
    where: MentorsClassesWhereUniqueInput
    /**
     * In case the MentorsClasses found by the `where` argument doesn't exist, create a new MentorsClasses with this data.
     */
    create: XOR<MentorsClassesCreateInput, MentorsClassesUncheckedCreateInput>
    /**
     * In case the MentorsClasses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentorsClassesUpdateInput, MentorsClassesUncheckedUpdateInput>
  }

  /**
   * MentorsClasses delete
   */
  export type MentorsClassesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorsClasses
     */
    select?: MentorsClassesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorsClassesInclude<ExtArgs> | null
    /**
     * Filter which MentorsClasses to delete.
     */
    where: MentorsClassesWhereUniqueInput
  }

  /**
   * MentorsClasses deleteMany
   */
  export type MentorsClassesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorsClasses to delete
     */
    where?: MentorsClassesWhereInput
  }

  /**
   * MentorsClasses without action
   */
  export type MentorsClassesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorsClasses
     */
    select?: MentorsClassesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorsClassesInclude<ExtArgs> | null
  }


  /**
   * Model MentorPayModel
   */

  export type AggregateMentorPayModel = {
    _count: MentorPayModelCountAggregateOutputType | null
    _avg: MentorPayModelAvgAggregateOutputType | null
    _sum: MentorPayModelSumAggregateOutputType | null
    _min: MentorPayModelMinAggregateOutputType | null
    _max: MentorPayModelMaxAggregateOutputType | null
  }

  export type MentorPayModelAvgAggregateOutputType = {
    pay_rate_per_hour: number | null
  }

  export type MentorPayModelSumAggregateOutputType = {
    pay_rate_per_hour: number | null
  }

  export type MentorPayModelMinAggregateOutputType = {
    mentor_id: string | null
    class_size_id: string | null
    start_date: Date | null
    pay_rate_per_hour: number | null
    created_date: Date | null
    end_date: Date | null
    deleted: boolean | null
  }

  export type MentorPayModelMaxAggregateOutputType = {
    mentor_id: string | null
    class_size_id: string | null
    start_date: Date | null
    pay_rate_per_hour: number | null
    created_date: Date | null
    end_date: Date | null
    deleted: boolean | null
  }

  export type MentorPayModelCountAggregateOutputType = {
    mentor_id: number
    class_size_id: number
    start_date: number
    pay_rate_per_hour: number
    created_date: number
    end_date: number
    deleted: number
    _all: number
  }


  export type MentorPayModelAvgAggregateInputType = {
    pay_rate_per_hour?: true
  }

  export type MentorPayModelSumAggregateInputType = {
    pay_rate_per_hour?: true
  }

  export type MentorPayModelMinAggregateInputType = {
    mentor_id?: true
    class_size_id?: true
    start_date?: true
    pay_rate_per_hour?: true
    created_date?: true
    end_date?: true
    deleted?: true
  }

  export type MentorPayModelMaxAggregateInputType = {
    mentor_id?: true
    class_size_id?: true
    start_date?: true
    pay_rate_per_hour?: true
    created_date?: true
    end_date?: true
    deleted?: true
  }

  export type MentorPayModelCountAggregateInputType = {
    mentor_id?: true
    class_size_id?: true
    start_date?: true
    pay_rate_per_hour?: true
    created_date?: true
    end_date?: true
    deleted?: true
    _all?: true
  }

  export type MentorPayModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorPayModel to aggregate.
     */
    where?: MentorPayModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorPayModels to fetch.
     */
    orderBy?: MentorPayModelOrderByWithRelationInput | MentorPayModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentorPayModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorPayModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorPayModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MentorPayModels
    **/
    _count?: true | MentorPayModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MentorPayModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MentorPayModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorPayModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorPayModelMaxAggregateInputType
  }

  export type GetMentorPayModelAggregateType<T extends MentorPayModelAggregateArgs> = {
        [P in keyof T & keyof AggregateMentorPayModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentorPayModel[P]>
      : GetScalarType<T[P], AggregateMentorPayModel[P]>
  }




  export type MentorPayModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorPayModelWhereInput
    orderBy?: MentorPayModelOrderByWithAggregationInput | MentorPayModelOrderByWithAggregationInput[]
    by: MentorPayModelScalarFieldEnum[] | MentorPayModelScalarFieldEnum
    having?: MentorPayModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorPayModelCountAggregateInputType | true
    _avg?: MentorPayModelAvgAggregateInputType
    _sum?: MentorPayModelSumAggregateInputType
    _min?: MentorPayModelMinAggregateInputType
    _max?: MentorPayModelMaxAggregateInputType
  }

  export type MentorPayModelGroupByOutputType = {
    mentor_id: string
    class_size_id: string
    start_date: Date
    pay_rate_per_hour: number
    created_date: Date | null
    end_date: Date | null
    deleted: boolean
    _count: MentorPayModelCountAggregateOutputType | null
    _avg: MentorPayModelAvgAggregateOutputType | null
    _sum: MentorPayModelSumAggregateOutputType | null
    _min: MentorPayModelMinAggregateOutputType | null
    _max: MentorPayModelMaxAggregateOutputType | null
  }

  type GetMentorPayModelGroupByPayload<T extends MentorPayModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorPayModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorPayModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorPayModelGroupByOutputType[P]>
            : GetScalarType<T[P], MentorPayModelGroupByOutputType[P]>
        }
      >
    >


  export type MentorPayModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mentor_id?: boolean
    class_size_id?: boolean
    start_date?: boolean
    pay_rate_per_hour?: boolean
    created_date?: boolean
    end_date?: boolean
    deleted?: boolean
    mentor?: boolean | MentorDefaultArgs<ExtArgs>
    class_size?: boolean | ClassSizeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorPayModel"]>

  export type MentorPayModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mentor_id?: boolean
    class_size_id?: boolean
    start_date?: boolean
    pay_rate_per_hour?: boolean
    created_date?: boolean
    end_date?: boolean
    deleted?: boolean
    mentor?: boolean | MentorDefaultArgs<ExtArgs>
    class_size?: boolean | ClassSizeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorPayModel"]>

  export type MentorPayModelSelectScalar = {
    mentor_id?: boolean
    class_size_id?: boolean
    start_date?: boolean
    pay_rate_per_hour?: boolean
    created_date?: boolean
    end_date?: boolean
    deleted?: boolean
  }

  export type MentorPayModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentor?: boolean | MentorDefaultArgs<ExtArgs>
    class_size?: boolean | ClassSizeDefaultArgs<ExtArgs>
  }
  export type MentorPayModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentor?: boolean | MentorDefaultArgs<ExtArgs>
    class_size?: boolean | ClassSizeDefaultArgs<ExtArgs>
  }

  export type $MentorPayModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MentorPayModel"
    objects: {
      mentor: Prisma.$MentorPayload<ExtArgs>
      class_size: Prisma.$ClassSizePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      mentor_id: string
      class_size_id: string
      start_date: Date
      /**
       * in USD
       */
      pay_rate_per_hour: number
      created_date: Date | null
      end_date: Date | null
      deleted: boolean
    }, ExtArgs["result"]["mentorPayModel"]>
    composites: {}
  }

  type MentorPayModelGetPayload<S extends boolean | null | undefined | MentorPayModelDefaultArgs> = $Result.GetResult<Prisma.$MentorPayModelPayload, S>

  type MentorPayModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MentorPayModelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MentorPayModelCountAggregateInputType | true
    }

  export interface MentorPayModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MentorPayModel'], meta: { name: 'MentorPayModel' } }
    /**
     * Find zero or one MentorPayModel that matches the filter.
     * @param {MentorPayModelFindUniqueArgs} args - Arguments to find a MentorPayModel
     * @example
     * // Get one MentorPayModel
     * const mentorPayModel = await prisma.mentorPayModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorPayModelFindUniqueArgs>(args: SelectSubset<T, MentorPayModelFindUniqueArgs<ExtArgs>>): Prisma__MentorPayModelClient<$Result.GetResult<Prisma.$MentorPayModelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MentorPayModel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MentorPayModelFindUniqueOrThrowArgs} args - Arguments to find a MentorPayModel
     * @example
     * // Get one MentorPayModel
     * const mentorPayModel = await prisma.mentorPayModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorPayModelFindUniqueOrThrowArgs>(args: SelectSubset<T, MentorPayModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentorPayModelClient<$Result.GetResult<Prisma.$MentorPayModelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MentorPayModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorPayModelFindFirstArgs} args - Arguments to find a MentorPayModel
     * @example
     * // Get one MentorPayModel
     * const mentorPayModel = await prisma.mentorPayModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorPayModelFindFirstArgs>(args?: SelectSubset<T, MentorPayModelFindFirstArgs<ExtArgs>>): Prisma__MentorPayModelClient<$Result.GetResult<Prisma.$MentorPayModelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MentorPayModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorPayModelFindFirstOrThrowArgs} args - Arguments to find a MentorPayModel
     * @example
     * // Get one MentorPayModel
     * const mentorPayModel = await prisma.mentorPayModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorPayModelFindFirstOrThrowArgs>(args?: SelectSubset<T, MentorPayModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentorPayModelClient<$Result.GetResult<Prisma.$MentorPayModelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MentorPayModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorPayModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MentorPayModels
     * const mentorPayModels = await prisma.mentorPayModel.findMany()
     * 
     * // Get first 10 MentorPayModels
     * const mentorPayModels = await prisma.mentorPayModel.findMany({ take: 10 })
     * 
     * // Only select the `mentor_id`
     * const mentorPayModelWithMentor_idOnly = await prisma.mentorPayModel.findMany({ select: { mentor_id: true } })
     * 
     */
    findMany<T extends MentorPayModelFindManyArgs>(args?: SelectSubset<T, MentorPayModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorPayModelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MentorPayModel.
     * @param {MentorPayModelCreateArgs} args - Arguments to create a MentorPayModel.
     * @example
     * // Create one MentorPayModel
     * const MentorPayModel = await prisma.mentorPayModel.create({
     *   data: {
     *     // ... data to create a MentorPayModel
     *   }
     * })
     * 
     */
    create<T extends MentorPayModelCreateArgs>(args: SelectSubset<T, MentorPayModelCreateArgs<ExtArgs>>): Prisma__MentorPayModelClient<$Result.GetResult<Prisma.$MentorPayModelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MentorPayModels.
     * @param {MentorPayModelCreateManyArgs} args - Arguments to create many MentorPayModels.
     * @example
     * // Create many MentorPayModels
     * const mentorPayModel = await prisma.mentorPayModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentorPayModelCreateManyArgs>(args?: SelectSubset<T, MentorPayModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MentorPayModels and returns the data saved in the database.
     * @param {MentorPayModelCreateManyAndReturnArgs} args - Arguments to create many MentorPayModels.
     * @example
     * // Create many MentorPayModels
     * const mentorPayModel = await prisma.mentorPayModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MentorPayModels and only return the `mentor_id`
     * const mentorPayModelWithMentor_idOnly = await prisma.mentorPayModel.createManyAndReturn({ 
     *   select: { mentor_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentorPayModelCreateManyAndReturnArgs>(args?: SelectSubset<T, MentorPayModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorPayModelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MentorPayModel.
     * @param {MentorPayModelDeleteArgs} args - Arguments to delete one MentorPayModel.
     * @example
     * // Delete one MentorPayModel
     * const MentorPayModel = await prisma.mentorPayModel.delete({
     *   where: {
     *     // ... filter to delete one MentorPayModel
     *   }
     * })
     * 
     */
    delete<T extends MentorPayModelDeleteArgs>(args: SelectSubset<T, MentorPayModelDeleteArgs<ExtArgs>>): Prisma__MentorPayModelClient<$Result.GetResult<Prisma.$MentorPayModelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MentorPayModel.
     * @param {MentorPayModelUpdateArgs} args - Arguments to update one MentorPayModel.
     * @example
     * // Update one MentorPayModel
     * const mentorPayModel = await prisma.mentorPayModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentorPayModelUpdateArgs>(args: SelectSubset<T, MentorPayModelUpdateArgs<ExtArgs>>): Prisma__MentorPayModelClient<$Result.GetResult<Prisma.$MentorPayModelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MentorPayModels.
     * @param {MentorPayModelDeleteManyArgs} args - Arguments to filter MentorPayModels to delete.
     * @example
     * // Delete a few MentorPayModels
     * const { count } = await prisma.mentorPayModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentorPayModelDeleteManyArgs>(args?: SelectSubset<T, MentorPayModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorPayModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorPayModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MentorPayModels
     * const mentorPayModel = await prisma.mentorPayModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentorPayModelUpdateManyArgs>(args: SelectSubset<T, MentorPayModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MentorPayModel.
     * @param {MentorPayModelUpsertArgs} args - Arguments to update or create a MentorPayModel.
     * @example
     * // Update or create a MentorPayModel
     * const mentorPayModel = await prisma.mentorPayModel.upsert({
     *   create: {
     *     // ... data to create a MentorPayModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MentorPayModel we want to update
     *   }
     * })
     */
    upsert<T extends MentorPayModelUpsertArgs>(args: SelectSubset<T, MentorPayModelUpsertArgs<ExtArgs>>): Prisma__MentorPayModelClient<$Result.GetResult<Prisma.$MentorPayModelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MentorPayModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorPayModelCountArgs} args - Arguments to filter MentorPayModels to count.
     * @example
     * // Count the number of MentorPayModels
     * const count = await prisma.mentorPayModel.count({
     *   where: {
     *     // ... the filter for the MentorPayModels we want to count
     *   }
     * })
    **/
    count<T extends MentorPayModelCountArgs>(
      args?: Subset<T, MentorPayModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorPayModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MentorPayModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorPayModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorPayModelAggregateArgs>(args: Subset<T, MentorPayModelAggregateArgs>): Prisma.PrismaPromise<GetMentorPayModelAggregateType<T>>

    /**
     * Group by MentorPayModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorPayModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentorPayModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorPayModelGroupByArgs['orderBy'] }
        : { orderBy?: MentorPayModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentorPayModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorPayModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MentorPayModel model
   */
  readonly fields: MentorPayModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MentorPayModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorPayModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentor<T extends MentorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MentorDefaultArgs<ExtArgs>>): Prisma__MentorClient<$Result.GetResult<Prisma.$MentorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class_size<T extends ClassSizeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassSizeDefaultArgs<ExtArgs>>): Prisma__ClassSizeClient<$Result.GetResult<Prisma.$ClassSizePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MentorPayModel model
   */ 
  interface MentorPayModelFieldRefs {
    readonly mentor_id: FieldRef<"MentorPayModel", 'String'>
    readonly class_size_id: FieldRef<"MentorPayModel", 'String'>
    readonly start_date: FieldRef<"MentorPayModel", 'DateTime'>
    readonly pay_rate_per_hour: FieldRef<"MentorPayModel", 'Float'>
    readonly created_date: FieldRef<"MentorPayModel", 'DateTime'>
    readonly end_date: FieldRef<"MentorPayModel", 'DateTime'>
    readonly deleted: FieldRef<"MentorPayModel", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * MentorPayModel findUnique
   */
  export type MentorPayModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorPayModel
     */
    select?: MentorPayModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorPayModelInclude<ExtArgs> | null
    /**
     * Filter, which MentorPayModel to fetch.
     */
    where: MentorPayModelWhereUniqueInput
  }

  /**
   * MentorPayModel findUniqueOrThrow
   */
  export type MentorPayModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorPayModel
     */
    select?: MentorPayModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorPayModelInclude<ExtArgs> | null
    /**
     * Filter, which MentorPayModel to fetch.
     */
    where: MentorPayModelWhereUniqueInput
  }

  /**
   * MentorPayModel findFirst
   */
  export type MentorPayModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorPayModel
     */
    select?: MentorPayModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorPayModelInclude<ExtArgs> | null
    /**
     * Filter, which MentorPayModel to fetch.
     */
    where?: MentorPayModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorPayModels to fetch.
     */
    orderBy?: MentorPayModelOrderByWithRelationInput | MentorPayModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorPayModels.
     */
    cursor?: MentorPayModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorPayModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorPayModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorPayModels.
     */
    distinct?: MentorPayModelScalarFieldEnum | MentorPayModelScalarFieldEnum[]
  }

  /**
   * MentorPayModel findFirstOrThrow
   */
  export type MentorPayModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorPayModel
     */
    select?: MentorPayModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorPayModelInclude<ExtArgs> | null
    /**
     * Filter, which MentorPayModel to fetch.
     */
    where?: MentorPayModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorPayModels to fetch.
     */
    orderBy?: MentorPayModelOrderByWithRelationInput | MentorPayModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorPayModels.
     */
    cursor?: MentorPayModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorPayModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorPayModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorPayModels.
     */
    distinct?: MentorPayModelScalarFieldEnum | MentorPayModelScalarFieldEnum[]
  }

  /**
   * MentorPayModel findMany
   */
  export type MentorPayModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorPayModel
     */
    select?: MentorPayModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorPayModelInclude<ExtArgs> | null
    /**
     * Filter, which MentorPayModels to fetch.
     */
    where?: MentorPayModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorPayModels to fetch.
     */
    orderBy?: MentorPayModelOrderByWithRelationInput | MentorPayModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MentorPayModels.
     */
    cursor?: MentorPayModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorPayModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorPayModels.
     */
    skip?: number
    distinct?: MentorPayModelScalarFieldEnum | MentorPayModelScalarFieldEnum[]
  }

  /**
   * MentorPayModel create
   */
  export type MentorPayModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorPayModel
     */
    select?: MentorPayModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorPayModelInclude<ExtArgs> | null
    /**
     * The data needed to create a MentorPayModel.
     */
    data: XOR<MentorPayModelCreateInput, MentorPayModelUncheckedCreateInput>
  }

  /**
   * MentorPayModel createMany
   */
  export type MentorPayModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MentorPayModels.
     */
    data: MentorPayModelCreateManyInput | MentorPayModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MentorPayModel createManyAndReturn
   */
  export type MentorPayModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorPayModel
     */
    select?: MentorPayModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MentorPayModels.
     */
    data: MentorPayModelCreateManyInput | MentorPayModelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorPayModelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorPayModel update
   */
  export type MentorPayModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorPayModel
     */
    select?: MentorPayModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorPayModelInclude<ExtArgs> | null
    /**
     * The data needed to update a MentorPayModel.
     */
    data: XOR<MentorPayModelUpdateInput, MentorPayModelUncheckedUpdateInput>
    /**
     * Choose, which MentorPayModel to update.
     */
    where: MentorPayModelWhereUniqueInput
  }

  /**
   * MentorPayModel updateMany
   */
  export type MentorPayModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MentorPayModels.
     */
    data: XOR<MentorPayModelUpdateManyMutationInput, MentorPayModelUncheckedUpdateManyInput>
    /**
     * Filter which MentorPayModels to update
     */
    where?: MentorPayModelWhereInput
  }

  /**
   * MentorPayModel upsert
   */
  export type MentorPayModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorPayModel
     */
    select?: MentorPayModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorPayModelInclude<ExtArgs> | null
    /**
     * The filter to search for the MentorPayModel to update in case it exists.
     */
    where: MentorPayModelWhereUniqueInput
    /**
     * In case the MentorPayModel found by the `where` argument doesn't exist, create a new MentorPayModel with this data.
     */
    create: XOR<MentorPayModelCreateInput, MentorPayModelUncheckedCreateInput>
    /**
     * In case the MentorPayModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentorPayModelUpdateInput, MentorPayModelUncheckedUpdateInput>
  }

  /**
   * MentorPayModel delete
   */
  export type MentorPayModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorPayModel
     */
    select?: MentorPayModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorPayModelInclude<ExtArgs> | null
    /**
     * Filter which MentorPayModel to delete.
     */
    where: MentorPayModelWhereUniqueInput
  }

  /**
   * MentorPayModel deleteMany
   */
  export type MentorPayModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorPayModels to delete
     */
    where?: MentorPayModelWhereInput
  }

  /**
   * MentorPayModel without action
   */
  export type MentorPayModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorPayModel
     */
    select?: MentorPayModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorPayModelInclude<ExtArgs> | null
  }


  /**
   * Model Module
   */

  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleAvgAggregateOutputType = {
    module_id: number | null
    module_order: number | null
  }

  export type ModuleSumAggregateOutputType = {
    module_id: number | null
    module_order: number | null
  }

  export type ModuleMinAggregateOutputType = {
    module_id: number | null
    module_name: string | null
    module_description: string | null
    module_order: number | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean | null
    course_id: string | null
  }

  export type ModuleMaxAggregateOutputType = {
    module_id: number | null
    module_name: string | null
    module_description: string | null
    module_order: number | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean | null
    course_id: string | null
  }

  export type ModuleCountAggregateOutputType = {
    module_id: number
    module_name: number
    module_description: number
    module_order: number
    created_date: number
    updated_date: number
    deleted: number
    course_id: number
    _all: number
  }


  export type ModuleAvgAggregateInputType = {
    module_id?: true
    module_order?: true
  }

  export type ModuleSumAggregateInputType = {
    module_id?: true
    module_order?: true
  }

  export type ModuleMinAggregateInputType = {
    module_id?: true
    module_name?: true
    module_description?: true
    module_order?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    course_id?: true
  }

  export type ModuleMaxAggregateInputType = {
    module_id?: true
    module_name?: true
    module_description?: true
    module_order?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    course_id?: true
  }

  export type ModuleCountAggregateInputType = {
    module_id?: true
    module_name?: true
    module_description?: true
    module_order?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    course_id?: true
    _all?: true
  }

  export type ModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Module to aggregate.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithAggregationInput | ModuleOrderByWithAggregationInput[]
    by: ModuleScalarFieldEnum[] | ModuleScalarFieldEnum
    having?: ModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _avg?: ModuleAvgAggregateInputType
    _sum?: ModuleSumAggregateInputType
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }

  export type ModuleGroupByOutputType = {
    module_id: number
    module_name: string
    module_description: string | null
    module_order: number
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean
    course_id: string
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    module_id?: boolean
    module_name?: boolean
    module_description?: boolean
    module_order?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    course_id?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    sections?: boolean | Module$sectionsArgs<ExtArgs>
    lessons?: boolean | Module$lessonsArgs<ExtArgs>
    CourseStructure?: boolean | Module$CourseStructureArgs<ExtArgs>
    CourseTask?: boolean | Module$CourseTaskArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    module_id?: boolean
    module_name?: boolean
    module_description?: boolean
    module_order?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    course_id?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectScalar = {
    module_id?: boolean
    module_name?: boolean
    module_description?: boolean
    module_order?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    course_id?: boolean
  }

  export type ModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    sections?: boolean | Module$sectionsArgs<ExtArgs>
    lessons?: boolean | Module$lessonsArgs<ExtArgs>
    CourseStructure?: boolean | Module$CourseStructureArgs<ExtArgs>
    CourseTask?: boolean | Module$CourseTaskArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $ModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Module"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      sections: Prisma.$SectionPayload<ExtArgs>[]
      lessons: Prisma.$LessonPayload<ExtArgs>[]
      CourseStructure: Prisma.$CourseStructurePayload<ExtArgs>[]
      CourseTask: Prisma.$CourseTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      module_id: number
      module_name: string
      module_description: string | null
      module_order: number
      created_date: Date | null
      updated_date: Date | null
      deleted: boolean
      course_id: string
    }, ExtArgs["result"]["module"]>
    composites: {}
  }

  type ModuleGetPayload<S extends boolean | null | undefined | ModuleDefaultArgs> = $Result.GetResult<Prisma.$ModulePayload, S>

  type ModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModuleCountAggregateInputType | true
    }

  export interface ModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Module'], meta: { name: 'Module' } }
    /**
     * Find zero or one Module that matches the filter.
     * @param {ModuleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleFindUniqueArgs>(args: SelectSubset<T, ModuleFindUniqueArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Module that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModuleFindUniqueOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleFindFirstArgs>(args?: SelectSubset<T, ModuleFindFirstArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Module that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `module_id`
     * const moduleWithModule_idOnly = await prisma.module.findMany({ select: { module_id: true } })
     * 
     */
    findMany<T extends ModuleFindManyArgs>(args?: SelectSubset<T, ModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Module.
     * @param {ModuleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
     */
    create<T extends ModuleCreateArgs>(args: SelectSubset<T, ModuleCreateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Modules.
     * @param {ModuleCreateManyArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleCreateManyArgs>(args?: SelectSubset<T, ModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modules and returns the data saved in the database.
     * @param {ModuleCreateManyAndReturnArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modules and only return the `module_id`
     * const moduleWithModule_idOnly = await prisma.module.createManyAndReturn({ 
     *   select: { module_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Module.
     * @param {ModuleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
     */
    delete<T extends ModuleDeleteArgs>(args: SelectSubset<T, ModuleDeleteArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Module.
     * @param {ModuleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleUpdateArgs>(args: SelectSubset<T, ModuleUpdateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Modules.
     * @param {ModuleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleDeleteManyArgs>(args?: SelectSubset<T, ModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleUpdateManyArgs>(args: SelectSubset<T, ModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Module.
     * @param {ModuleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
     */
    upsert<T extends ModuleUpsertArgs>(args: SelectSubset<T, ModuleUpsertArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends ModuleCountArgs>(
      args?: Subset<T, ModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): Prisma.PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Module model
   */
  readonly fields: ModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sections<T extends Module$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, Module$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany"> | Null>
    lessons<T extends Module$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Module$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany"> | Null>
    CourseStructure<T extends Module$CourseStructureArgs<ExtArgs> = {}>(args?: Subset<T, Module$CourseStructureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseStructurePayload<ExtArgs>, T, "findMany"> | Null>
    CourseTask<T extends Module$CourseTaskArgs<ExtArgs> = {}>(args?: Subset<T, Module$CourseTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Module model
   */ 
  interface ModuleFieldRefs {
    readonly module_id: FieldRef<"Module", 'Int'>
    readonly module_name: FieldRef<"Module", 'String'>
    readonly module_description: FieldRef<"Module", 'String'>
    readonly module_order: FieldRef<"Module", 'Int'>
    readonly created_date: FieldRef<"Module", 'DateTime'>
    readonly updated_date: FieldRef<"Module", 'DateTime'>
    readonly deleted: FieldRef<"Module", 'Boolean'>
    readonly course_id: FieldRef<"Module", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Module findUnique
   */
  export type ModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findUniqueOrThrow
   */
  export type ModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findFirst
   */
  export type ModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findFirstOrThrow
   */
  export type ModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findMany
   */
  export type ModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Modules to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module create
   */
  export type ModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Module.
     */
    data: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
  }

  /**
   * Module createMany
   */
  export type ModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Module createManyAndReturn
   */
  export type ModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module update
   */
  export type ModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Module.
     */
    data: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
    /**
     * Choose, which Module to update.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module updateMany
   */
  export type ModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
  }

  /**
   * Module upsert
   */
  export type ModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Module to update in case it exists.
     */
    where: ModuleWhereUniqueInput
    /**
     * In case the Module found by the `where` argument doesn't exist, create a new Module with this data.
     */
    create: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
    /**
     * In case the Module was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
  }

  /**
   * Module delete
   */
  export type ModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter which Module to delete.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module deleteMany
   */
  export type ModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modules to delete
     */
    where?: ModuleWhereInput
  }

  /**
   * Module.sections
   */
  export type Module$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Module.lessons
   */
  export type Module$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Module.CourseStructure
   */
  export type Module$CourseStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseStructure
     */
    select?: CourseStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseStructureInclude<ExtArgs> | null
    where?: CourseStructureWhereInput
    orderBy?: CourseStructureOrderByWithRelationInput | CourseStructureOrderByWithRelationInput[]
    cursor?: CourseStructureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseStructureScalarFieldEnum | CourseStructureScalarFieldEnum[]
  }

  /**
   * Module.CourseTask
   */
  export type Module$CourseTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTask
     */
    select?: CourseTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTaskInclude<ExtArgs> | null
    where?: CourseTaskWhereInput
    orderBy?: CourseTaskOrderByWithRelationInput | CourseTaskOrderByWithRelationInput[]
    cursor?: CourseTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseTaskScalarFieldEnum | CourseTaskScalarFieldEnum[]
  }

  /**
   * Module without action
   */
  export type ModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
  }


  /**
   * Model Section
   */

  export type AggregateSection = {
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  export type SectionAvgAggregateOutputType = {
    section_id: number | null
    section_order: number | null
    module_id: number | null
  }

  export type SectionSumAggregateOutputType = {
    section_id: number | null
    section_order: number | null
    module_id: number | null
  }

  export type SectionMinAggregateOutputType = {
    section_id: number | null
    section_name: string | null
    section_description: string | null
    section_order: number | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean | null
    module_id: number | null
  }

  export type SectionMaxAggregateOutputType = {
    section_id: number | null
    section_name: string | null
    section_description: string | null
    section_order: number | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean | null
    module_id: number | null
  }

  export type SectionCountAggregateOutputType = {
    section_id: number
    section_name: number
    section_description: number
    section_order: number
    created_date: number
    updated_date: number
    deleted: number
    module_id: number
    _all: number
  }


  export type SectionAvgAggregateInputType = {
    section_id?: true
    section_order?: true
    module_id?: true
  }

  export type SectionSumAggregateInputType = {
    section_id?: true
    section_order?: true
    module_id?: true
  }

  export type SectionMinAggregateInputType = {
    section_id?: true
    section_name?: true
    section_description?: true
    section_order?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    module_id?: true
  }

  export type SectionMaxAggregateInputType = {
    section_id?: true
    section_name?: true
    section_description?: true
    section_order?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    module_id?: true
  }

  export type SectionCountAggregateInputType = {
    section_id?: true
    section_name?: true
    section_description?: true
    section_order?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    module_id?: true
    _all?: true
  }

  export type SectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Section to aggregate.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sections
    **/
    _count?: true | SectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionMaxAggregateInputType
  }

  export type GetSectionAggregateType<T extends SectionAggregateArgs> = {
        [P in keyof T & keyof AggregateSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSection[P]>
      : GetScalarType<T[P], AggregateSection[P]>
  }




  export type SectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithAggregationInput | SectionOrderByWithAggregationInput[]
    by: SectionScalarFieldEnum[] | SectionScalarFieldEnum
    having?: SectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionCountAggregateInputType | true
    _avg?: SectionAvgAggregateInputType
    _sum?: SectionSumAggregateInputType
    _min?: SectionMinAggregateInputType
    _max?: SectionMaxAggregateInputType
  }

  export type SectionGroupByOutputType = {
    section_id: number
    section_name: string
    section_description: string | null
    section_order: number
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean
    module_id: number
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  type GetSectionGroupByPayload<T extends SectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionGroupByOutputType[P]>
            : GetScalarType<T[P], SectionGroupByOutputType[P]>
        }
      >
    >


  export type SectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    section_id?: boolean
    section_name?: boolean
    section_description?: boolean
    section_order?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    module_id?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    CourseStructure?: boolean | Section$CourseStructureArgs<ExtArgs>
    CourseTask?: boolean | Section$CourseTaskArgs<ExtArgs>
    Lesson?: boolean | Section$LessonArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    section_id?: boolean
    section_name?: boolean
    section_description?: boolean
    section_order?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    module_id?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>

  export type SectionSelectScalar = {
    section_id?: boolean
    section_name?: boolean
    section_description?: boolean
    section_order?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    module_id?: boolean
  }

  export type SectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    CourseStructure?: boolean | Section$CourseStructureArgs<ExtArgs>
    CourseTask?: boolean | Section$CourseTaskArgs<ExtArgs>
    Lesson?: boolean | Section$LessonArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }

  export type $SectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Section"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      CourseStructure: Prisma.$CourseStructurePayload<ExtArgs>[]
      CourseTask: Prisma.$CourseTaskPayload<ExtArgs>[]
      Lesson: Prisma.$LessonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      section_id: number
      section_name: string
      section_description: string | null
      section_order: number
      created_date: Date | null
      updated_date: Date | null
      deleted: boolean
      module_id: number
    }, ExtArgs["result"]["section"]>
    composites: {}
  }

  type SectionGetPayload<S extends boolean | null | undefined | SectionDefaultArgs> = $Result.GetResult<Prisma.$SectionPayload, S>

  type SectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SectionCountAggregateInputType | true
    }

  export interface SectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Section'], meta: { name: 'Section' } }
    /**
     * Find zero or one Section that matches the filter.
     * @param {SectionFindUniqueArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionFindUniqueArgs>(args: SelectSubset<T, SectionFindUniqueArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Section that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SectionFindUniqueOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionFindUniqueOrThrowArgs>(args: SelectSubset<T, SectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Section that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionFindFirstArgs>(args?: SelectSubset<T, SectionFindFirstArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Section that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionFindFirstOrThrowArgs>(args?: SelectSubset<T, SectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sections
     * const sections = await prisma.section.findMany()
     * 
     * // Get first 10 Sections
     * const sections = await prisma.section.findMany({ take: 10 })
     * 
     * // Only select the `section_id`
     * const sectionWithSection_idOnly = await prisma.section.findMany({ select: { section_id: true } })
     * 
     */
    findMany<T extends SectionFindManyArgs>(args?: SelectSubset<T, SectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Section.
     * @param {SectionCreateArgs} args - Arguments to create a Section.
     * @example
     * // Create one Section
     * const Section = await prisma.section.create({
     *   data: {
     *     // ... data to create a Section
     *   }
     * })
     * 
     */
    create<T extends SectionCreateArgs>(args: SelectSubset<T, SectionCreateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sections.
     * @param {SectionCreateManyArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectionCreateManyArgs>(args?: SelectSubset<T, SectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sections and returns the data saved in the database.
     * @param {SectionCreateManyAndReturnArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sections and only return the `section_id`
     * const sectionWithSection_idOnly = await prisma.section.createManyAndReturn({ 
     *   select: { section_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SectionCreateManyAndReturnArgs>(args?: SelectSubset<T, SectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Section.
     * @param {SectionDeleteArgs} args - Arguments to delete one Section.
     * @example
     * // Delete one Section
     * const Section = await prisma.section.delete({
     *   where: {
     *     // ... filter to delete one Section
     *   }
     * })
     * 
     */
    delete<T extends SectionDeleteArgs>(args: SelectSubset<T, SectionDeleteArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Section.
     * @param {SectionUpdateArgs} args - Arguments to update one Section.
     * @example
     * // Update one Section
     * const section = await prisma.section.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectionUpdateArgs>(args: SelectSubset<T, SectionUpdateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sections.
     * @param {SectionDeleteManyArgs} args - Arguments to filter Sections to delete.
     * @example
     * // Delete a few Sections
     * const { count } = await prisma.section.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectionDeleteManyArgs>(args?: SelectSubset<T, SectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectionUpdateManyArgs>(args: SelectSubset<T, SectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Section.
     * @param {SectionUpsertArgs} args - Arguments to update or create a Section.
     * @example
     * // Update or create a Section
     * const section = await prisma.section.upsert({
     *   create: {
     *     // ... data to create a Section
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Section we want to update
     *   }
     * })
     */
    upsert<T extends SectionUpsertArgs>(args: SelectSubset<T, SectionUpsertArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionCountArgs} args - Arguments to filter Sections to count.
     * @example
     * // Count the number of Sections
     * const count = await prisma.section.count({
     *   where: {
     *     // ... the filter for the Sections we want to count
     *   }
     * })
    **/
    count<T extends SectionCountArgs>(
      args?: Subset<T, SectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionAggregateArgs>(args: Subset<T, SectionAggregateArgs>): Prisma.PrismaPromise<GetSectionAggregateType<T>>

    /**
     * Group by Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionGroupByArgs['orderBy'] }
        : { orderBy?: SectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Section model
   */
  readonly fields: SectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Section.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    CourseStructure<T extends Section$CourseStructureArgs<ExtArgs> = {}>(args?: Subset<T, Section$CourseStructureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseStructurePayload<ExtArgs>, T, "findMany"> | Null>
    CourseTask<T extends Section$CourseTaskArgs<ExtArgs> = {}>(args?: Subset<T, Section$CourseTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTaskPayload<ExtArgs>, T, "findMany"> | Null>
    Lesson<T extends Section$LessonArgs<ExtArgs> = {}>(args?: Subset<T, Section$LessonArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Section model
   */ 
  interface SectionFieldRefs {
    readonly section_id: FieldRef<"Section", 'Int'>
    readonly section_name: FieldRef<"Section", 'String'>
    readonly section_description: FieldRef<"Section", 'String'>
    readonly section_order: FieldRef<"Section", 'Int'>
    readonly created_date: FieldRef<"Section", 'DateTime'>
    readonly updated_date: FieldRef<"Section", 'DateTime'>
    readonly deleted: FieldRef<"Section", 'Boolean'>
    readonly module_id: FieldRef<"Section", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Section findUnique
   */
  export type SectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findUniqueOrThrow
   */
  export type SectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findFirst
   */
  export type SectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findFirstOrThrow
   */
  export type SectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findMany
   */
  export type SectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Sections to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section create
   */
  export type SectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Section.
     */
    data: XOR<SectionCreateInput, SectionUncheckedCreateInput>
  }

  /**
   * Section createMany
   */
  export type SectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Section createManyAndReturn
   */
  export type SectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Section update
   */
  export type SectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Section.
     */
    data: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
    /**
     * Choose, which Section to update.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section updateMany
   */
  export type SectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
  }

  /**
   * Section upsert
   */
  export type SectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Section to update in case it exists.
     */
    where: SectionWhereUniqueInput
    /**
     * In case the Section found by the `where` argument doesn't exist, create a new Section with this data.
     */
    create: XOR<SectionCreateInput, SectionUncheckedCreateInput>
    /**
     * In case the Section was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
  }

  /**
   * Section delete
   */
  export type SectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter which Section to delete.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section deleteMany
   */
  export type SectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sections to delete
     */
    where?: SectionWhereInput
  }

  /**
   * Section.CourseStructure
   */
  export type Section$CourseStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseStructure
     */
    select?: CourseStructureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseStructureInclude<ExtArgs> | null
    where?: CourseStructureWhereInput
    orderBy?: CourseStructureOrderByWithRelationInput | CourseStructureOrderByWithRelationInput[]
    cursor?: CourseStructureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseStructureScalarFieldEnum | CourseStructureScalarFieldEnum[]
  }

  /**
   * Section.CourseTask
   */
  export type Section$CourseTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTask
     */
    select?: CourseTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTaskInclude<ExtArgs> | null
    where?: CourseTaskWhereInput
    orderBy?: CourseTaskOrderByWithRelationInput | CourseTaskOrderByWithRelationInput[]
    cursor?: CourseTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseTaskScalarFieldEnum | CourseTaskScalarFieldEnum[]
  }

  /**
   * Section.Lesson
   */
  export type Section$LessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Section without action
   */
  export type SectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
  }


  /**
   * Model TimeOfDay
   */

  export type AggregateTimeOfDay = {
    _count: TimeOfDayCountAggregateOutputType | null
    _min: TimeOfDayMinAggregateOutputType | null
    _max: TimeOfDayMaxAggregateOutputType | null
  }

  export type TimeOfDayMinAggregateOutputType = {
    time_of_day_id: string | null
    time_of_day_name: string | null
  }

  export type TimeOfDayMaxAggregateOutputType = {
    time_of_day_id: string | null
    time_of_day_name: string | null
  }

  export type TimeOfDayCountAggregateOutputType = {
    time_of_day_id: number
    time_of_day_name: number
    _all: number
  }


  export type TimeOfDayMinAggregateInputType = {
    time_of_day_id?: true
    time_of_day_name?: true
  }

  export type TimeOfDayMaxAggregateInputType = {
    time_of_day_id?: true
    time_of_day_name?: true
  }

  export type TimeOfDayCountAggregateInputType = {
    time_of_day_id?: true
    time_of_day_name?: true
    _all?: true
  }

  export type TimeOfDayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeOfDay to aggregate.
     */
    where?: TimeOfDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeOfDays to fetch.
     */
    orderBy?: TimeOfDayOrderByWithRelationInput | TimeOfDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeOfDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeOfDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeOfDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeOfDays
    **/
    _count?: true | TimeOfDayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeOfDayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeOfDayMaxAggregateInputType
  }

  export type GetTimeOfDayAggregateType<T extends TimeOfDayAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeOfDay]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeOfDay[P]>
      : GetScalarType<T[P], AggregateTimeOfDay[P]>
  }




  export type TimeOfDayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeOfDayWhereInput
    orderBy?: TimeOfDayOrderByWithAggregationInput | TimeOfDayOrderByWithAggregationInput[]
    by: TimeOfDayScalarFieldEnum[] | TimeOfDayScalarFieldEnum
    having?: TimeOfDayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeOfDayCountAggregateInputType | true
    _min?: TimeOfDayMinAggregateInputType
    _max?: TimeOfDayMaxAggregateInputType
  }

  export type TimeOfDayGroupByOutputType = {
    time_of_day_id: string
    time_of_day_name: string
    _count: TimeOfDayCountAggregateOutputType | null
    _min: TimeOfDayMinAggregateOutputType | null
    _max: TimeOfDayMaxAggregateOutputType | null
  }

  type GetTimeOfDayGroupByPayload<T extends TimeOfDayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeOfDayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeOfDayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeOfDayGroupByOutputType[P]>
            : GetScalarType<T[P], TimeOfDayGroupByOutputType[P]>
        }
      >
    >


  export type TimeOfDaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    time_of_day_id?: boolean
    time_of_day_name?: boolean
    classes?: boolean | TimeOfDay$classesArgs<ExtArgs>
    _count?: boolean | TimeOfDayCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeOfDay"]>

  export type TimeOfDaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    time_of_day_id?: boolean
    time_of_day_name?: boolean
  }, ExtArgs["result"]["timeOfDay"]>

  export type TimeOfDaySelectScalar = {
    time_of_day_id?: boolean
    time_of_day_name?: boolean
  }

  export type TimeOfDayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | TimeOfDay$classesArgs<ExtArgs>
    _count?: boolean | TimeOfDayCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TimeOfDayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TimeOfDayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeOfDay"
    objects: {
      classes: Prisma.$ClassPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      time_of_day_id: string
      time_of_day_name: string
    }, ExtArgs["result"]["timeOfDay"]>
    composites: {}
  }

  type TimeOfDayGetPayload<S extends boolean | null | undefined | TimeOfDayDefaultArgs> = $Result.GetResult<Prisma.$TimeOfDayPayload, S>

  type TimeOfDayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TimeOfDayFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TimeOfDayCountAggregateInputType | true
    }

  export interface TimeOfDayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeOfDay'], meta: { name: 'TimeOfDay' } }
    /**
     * Find zero or one TimeOfDay that matches the filter.
     * @param {TimeOfDayFindUniqueArgs} args - Arguments to find a TimeOfDay
     * @example
     * // Get one TimeOfDay
     * const timeOfDay = await prisma.timeOfDay.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeOfDayFindUniqueArgs>(args: SelectSubset<T, TimeOfDayFindUniqueArgs<ExtArgs>>): Prisma__TimeOfDayClient<$Result.GetResult<Prisma.$TimeOfDayPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TimeOfDay that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TimeOfDayFindUniqueOrThrowArgs} args - Arguments to find a TimeOfDay
     * @example
     * // Get one TimeOfDay
     * const timeOfDay = await prisma.timeOfDay.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeOfDayFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeOfDayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeOfDayClient<$Result.GetResult<Prisma.$TimeOfDayPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TimeOfDay that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeOfDayFindFirstArgs} args - Arguments to find a TimeOfDay
     * @example
     * // Get one TimeOfDay
     * const timeOfDay = await prisma.timeOfDay.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeOfDayFindFirstArgs>(args?: SelectSubset<T, TimeOfDayFindFirstArgs<ExtArgs>>): Prisma__TimeOfDayClient<$Result.GetResult<Prisma.$TimeOfDayPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TimeOfDay that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeOfDayFindFirstOrThrowArgs} args - Arguments to find a TimeOfDay
     * @example
     * // Get one TimeOfDay
     * const timeOfDay = await prisma.timeOfDay.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeOfDayFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeOfDayFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeOfDayClient<$Result.GetResult<Prisma.$TimeOfDayPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TimeOfDays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeOfDayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeOfDays
     * const timeOfDays = await prisma.timeOfDay.findMany()
     * 
     * // Get first 10 TimeOfDays
     * const timeOfDays = await prisma.timeOfDay.findMany({ take: 10 })
     * 
     * // Only select the `time_of_day_id`
     * const timeOfDayWithTime_of_day_idOnly = await prisma.timeOfDay.findMany({ select: { time_of_day_id: true } })
     * 
     */
    findMany<T extends TimeOfDayFindManyArgs>(args?: SelectSubset<T, TimeOfDayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeOfDayPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TimeOfDay.
     * @param {TimeOfDayCreateArgs} args - Arguments to create a TimeOfDay.
     * @example
     * // Create one TimeOfDay
     * const TimeOfDay = await prisma.timeOfDay.create({
     *   data: {
     *     // ... data to create a TimeOfDay
     *   }
     * })
     * 
     */
    create<T extends TimeOfDayCreateArgs>(args: SelectSubset<T, TimeOfDayCreateArgs<ExtArgs>>): Prisma__TimeOfDayClient<$Result.GetResult<Prisma.$TimeOfDayPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TimeOfDays.
     * @param {TimeOfDayCreateManyArgs} args - Arguments to create many TimeOfDays.
     * @example
     * // Create many TimeOfDays
     * const timeOfDay = await prisma.timeOfDay.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeOfDayCreateManyArgs>(args?: SelectSubset<T, TimeOfDayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeOfDays and returns the data saved in the database.
     * @param {TimeOfDayCreateManyAndReturnArgs} args - Arguments to create many TimeOfDays.
     * @example
     * // Create many TimeOfDays
     * const timeOfDay = await prisma.timeOfDay.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeOfDays and only return the `time_of_day_id`
     * const timeOfDayWithTime_of_day_idOnly = await prisma.timeOfDay.createManyAndReturn({ 
     *   select: { time_of_day_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeOfDayCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeOfDayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeOfDayPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TimeOfDay.
     * @param {TimeOfDayDeleteArgs} args - Arguments to delete one TimeOfDay.
     * @example
     * // Delete one TimeOfDay
     * const TimeOfDay = await prisma.timeOfDay.delete({
     *   where: {
     *     // ... filter to delete one TimeOfDay
     *   }
     * })
     * 
     */
    delete<T extends TimeOfDayDeleteArgs>(args: SelectSubset<T, TimeOfDayDeleteArgs<ExtArgs>>): Prisma__TimeOfDayClient<$Result.GetResult<Prisma.$TimeOfDayPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TimeOfDay.
     * @param {TimeOfDayUpdateArgs} args - Arguments to update one TimeOfDay.
     * @example
     * // Update one TimeOfDay
     * const timeOfDay = await prisma.timeOfDay.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeOfDayUpdateArgs>(args: SelectSubset<T, TimeOfDayUpdateArgs<ExtArgs>>): Prisma__TimeOfDayClient<$Result.GetResult<Prisma.$TimeOfDayPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TimeOfDays.
     * @param {TimeOfDayDeleteManyArgs} args - Arguments to filter TimeOfDays to delete.
     * @example
     * // Delete a few TimeOfDays
     * const { count } = await prisma.timeOfDay.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeOfDayDeleteManyArgs>(args?: SelectSubset<T, TimeOfDayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeOfDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeOfDayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeOfDays
     * const timeOfDay = await prisma.timeOfDay.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeOfDayUpdateManyArgs>(args: SelectSubset<T, TimeOfDayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TimeOfDay.
     * @param {TimeOfDayUpsertArgs} args - Arguments to update or create a TimeOfDay.
     * @example
     * // Update or create a TimeOfDay
     * const timeOfDay = await prisma.timeOfDay.upsert({
     *   create: {
     *     // ... data to create a TimeOfDay
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeOfDay we want to update
     *   }
     * })
     */
    upsert<T extends TimeOfDayUpsertArgs>(args: SelectSubset<T, TimeOfDayUpsertArgs<ExtArgs>>): Prisma__TimeOfDayClient<$Result.GetResult<Prisma.$TimeOfDayPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TimeOfDays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeOfDayCountArgs} args - Arguments to filter TimeOfDays to count.
     * @example
     * // Count the number of TimeOfDays
     * const count = await prisma.timeOfDay.count({
     *   where: {
     *     // ... the filter for the TimeOfDays we want to count
     *   }
     * })
    **/
    count<T extends TimeOfDayCountArgs>(
      args?: Subset<T, TimeOfDayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeOfDayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeOfDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeOfDayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeOfDayAggregateArgs>(args: Subset<T, TimeOfDayAggregateArgs>): Prisma.PrismaPromise<GetTimeOfDayAggregateType<T>>

    /**
     * Group by TimeOfDay.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeOfDayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeOfDayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeOfDayGroupByArgs['orderBy'] }
        : { orderBy?: TimeOfDayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeOfDayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeOfDayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeOfDay model
   */
  readonly fields: TimeOfDayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeOfDay.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeOfDayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends TimeOfDay$classesArgs<ExtArgs> = {}>(args?: Subset<T, TimeOfDay$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeOfDay model
   */ 
  interface TimeOfDayFieldRefs {
    readonly time_of_day_id: FieldRef<"TimeOfDay", 'String'>
    readonly time_of_day_name: FieldRef<"TimeOfDay", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TimeOfDay findUnique
   */
  export type TimeOfDayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeOfDay
     */
    select?: TimeOfDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeOfDayInclude<ExtArgs> | null
    /**
     * Filter, which TimeOfDay to fetch.
     */
    where: TimeOfDayWhereUniqueInput
  }

  /**
   * TimeOfDay findUniqueOrThrow
   */
  export type TimeOfDayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeOfDay
     */
    select?: TimeOfDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeOfDayInclude<ExtArgs> | null
    /**
     * Filter, which TimeOfDay to fetch.
     */
    where: TimeOfDayWhereUniqueInput
  }

  /**
   * TimeOfDay findFirst
   */
  export type TimeOfDayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeOfDay
     */
    select?: TimeOfDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeOfDayInclude<ExtArgs> | null
    /**
     * Filter, which TimeOfDay to fetch.
     */
    where?: TimeOfDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeOfDays to fetch.
     */
    orderBy?: TimeOfDayOrderByWithRelationInput | TimeOfDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeOfDays.
     */
    cursor?: TimeOfDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeOfDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeOfDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeOfDays.
     */
    distinct?: TimeOfDayScalarFieldEnum | TimeOfDayScalarFieldEnum[]
  }

  /**
   * TimeOfDay findFirstOrThrow
   */
  export type TimeOfDayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeOfDay
     */
    select?: TimeOfDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeOfDayInclude<ExtArgs> | null
    /**
     * Filter, which TimeOfDay to fetch.
     */
    where?: TimeOfDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeOfDays to fetch.
     */
    orderBy?: TimeOfDayOrderByWithRelationInput | TimeOfDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeOfDays.
     */
    cursor?: TimeOfDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeOfDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeOfDays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeOfDays.
     */
    distinct?: TimeOfDayScalarFieldEnum | TimeOfDayScalarFieldEnum[]
  }

  /**
   * TimeOfDay findMany
   */
  export type TimeOfDayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeOfDay
     */
    select?: TimeOfDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeOfDayInclude<ExtArgs> | null
    /**
     * Filter, which TimeOfDays to fetch.
     */
    where?: TimeOfDayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeOfDays to fetch.
     */
    orderBy?: TimeOfDayOrderByWithRelationInput | TimeOfDayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeOfDays.
     */
    cursor?: TimeOfDayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeOfDays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeOfDays.
     */
    skip?: number
    distinct?: TimeOfDayScalarFieldEnum | TimeOfDayScalarFieldEnum[]
  }

  /**
   * TimeOfDay create
   */
  export type TimeOfDayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeOfDay
     */
    select?: TimeOfDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeOfDayInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeOfDay.
     */
    data: XOR<TimeOfDayCreateInput, TimeOfDayUncheckedCreateInput>
  }

  /**
   * TimeOfDay createMany
   */
  export type TimeOfDayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeOfDays.
     */
    data: TimeOfDayCreateManyInput | TimeOfDayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeOfDay createManyAndReturn
   */
  export type TimeOfDayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeOfDay
     */
    select?: TimeOfDaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TimeOfDays.
     */
    data: TimeOfDayCreateManyInput | TimeOfDayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeOfDay update
   */
  export type TimeOfDayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeOfDay
     */
    select?: TimeOfDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeOfDayInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeOfDay.
     */
    data: XOR<TimeOfDayUpdateInput, TimeOfDayUncheckedUpdateInput>
    /**
     * Choose, which TimeOfDay to update.
     */
    where: TimeOfDayWhereUniqueInput
  }

  /**
   * TimeOfDay updateMany
   */
  export type TimeOfDayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeOfDays.
     */
    data: XOR<TimeOfDayUpdateManyMutationInput, TimeOfDayUncheckedUpdateManyInput>
    /**
     * Filter which TimeOfDays to update
     */
    where?: TimeOfDayWhereInput
  }

  /**
   * TimeOfDay upsert
   */
  export type TimeOfDayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeOfDay
     */
    select?: TimeOfDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeOfDayInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeOfDay to update in case it exists.
     */
    where: TimeOfDayWhereUniqueInput
    /**
     * In case the TimeOfDay found by the `where` argument doesn't exist, create a new TimeOfDay with this data.
     */
    create: XOR<TimeOfDayCreateInput, TimeOfDayUncheckedCreateInput>
    /**
     * In case the TimeOfDay was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeOfDayUpdateInput, TimeOfDayUncheckedUpdateInput>
  }

  /**
   * TimeOfDay delete
   */
  export type TimeOfDayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeOfDay
     */
    select?: TimeOfDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeOfDayInclude<ExtArgs> | null
    /**
     * Filter which TimeOfDay to delete.
     */
    where: TimeOfDayWhereUniqueInput
  }

  /**
   * TimeOfDay deleteMany
   */
  export type TimeOfDayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeOfDays to delete
     */
    where?: TimeOfDayWhereInput
  }

  /**
   * TimeOfDay.classes
   */
  export type TimeOfDay$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * TimeOfDay without action
   */
  export type TimeOfDayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeOfDay
     */
    select?: TimeOfDaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeOfDayInclude<ExtArgs> | null
  }


  /**
   * Model TuitionLang
   */

  export type AggregateTuitionLang = {
    _count: TuitionLangCountAggregateOutputType | null
    _min: TuitionLangMinAggregateOutputType | null
    _max: TuitionLangMaxAggregateOutputType | null
  }

  export type TuitionLangMinAggregateOutputType = {
    tuition_lang_code: string | null
    tuition_lang_name: string | null
  }

  export type TuitionLangMaxAggregateOutputType = {
    tuition_lang_code: string | null
    tuition_lang_name: string | null
  }

  export type TuitionLangCountAggregateOutputType = {
    tuition_lang_code: number
    tuition_lang_name: number
    _all: number
  }


  export type TuitionLangMinAggregateInputType = {
    tuition_lang_code?: true
    tuition_lang_name?: true
  }

  export type TuitionLangMaxAggregateInputType = {
    tuition_lang_code?: true
    tuition_lang_name?: true
  }

  export type TuitionLangCountAggregateInputType = {
    tuition_lang_code?: true
    tuition_lang_name?: true
    _all?: true
  }

  export type TuitionLangAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TuitionLang to aggregate.
     */
    where?: TuitionLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TuitionLangs to fetch.
     */
    orderBy?: TuitionLangOrderByWithRelationInput | TuitionLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TuitionLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TuitionLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TuitionLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TuitionLangs
    **/
    _count?: true | TuitionLangCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TuitionLangMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TuitionLangMaxAggregateInputType
  }

  export type GetTuitionLangAggregateType<T extends TuitionLangAggregateArgs> = {
        [P in keyof T & keyof AggregateTuitionLang]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTuitionLang[P]>
      : GetScalarType<T[P], AggregateTuitionLang[P]>
  }




  export type TuitionLangGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TuitionLangWhereInput
    orderBy?: TuitionLangOrderByWithAggregationInput | TuitionLangOrderByWithAggregationInput[]
    by: TuitionLangScalarFieldEnum[] | TuitionLangScalarFieldEnum
    having?: TuitionLangScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TuitionLangCountAggregateInputType | true
    _min?: TuitionLangMinAggregateInputType
    _max?: TuitionLangMaxAggregateInputType
  }

  export type TuitionLangGroupByOutputType = {
    tuition_lang_code: string
    tuition_lang_name: string
    _count: TuitionLangCountAggregateOutputType | null
    _min: TuitionLangMinAggregateOutputType | null
    _max: TuitionLangMaxAggregateOutputType | null
  }

  type GetTuitionLangGroupByPayload<T extends TuitionLangGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TuitionLangGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TuitionLangGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TuitionLangGroupByOutputType[P]>
            : GetScalarType<T[P], TuitionLangGroupByOutputType[P]>
        }
      >
    >


  export type TuitionLangSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tuition_lang_code?: boolean
    tuition_lang_name?: boolean
    classes?: boolean | TuitionLang$classesArgs<ExtArgs>
    _count?: boolean | TuitionLangCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tuitionLang"]>

  export type TuitionLangSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tuition_lang_code?: boolean
    tuition_lang_name?: boolean
  }, ExtArgs["result"]["tuitionLang"]>

  export type TuitionLangSelectScalar = {
    tuition_lang_code?: boolean
    tuition_lang_name?: boolean
  }

  export type TuitionLangInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | TuitionLang$classesArgs<ExtArgs>
    _count?: boolean | TuitionLangCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TuitionLangIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TuitionLangPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TuitionLang"
    objects: {
      classes: Prisma.$ClassPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      tuition_lang_code: string
      tuition_lang_name: string
    }, ExtArgs["result"]["tuitionLang"]>
    composites: {}
  }

  type TuitionLangGetPayload<S extends boolean | null | undefined | TuitionLangDefaultArgs> = $Result.GetResult<Prisma.$TuitionLangPayload, S>

  type TuitionLangCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TuitionLangFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TuitionLangCountAggregateInputType | true
    }

  export interface TuitionLangDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TuitionLang'], meta: { name: 'TuitionLang' } }
    /**
     * Find zero or one TuitionLang that matches the filter.
     * @param {TuitionLangFindUniqueArgs} args - Arguments to find a TuitionLang
     * @example
     * // Get one TuitionLang
     * const tuitionLang = await prisma.tuitionLang.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TuitionLangFindUniqueArgs>(args: SelectSubset<T, TuitionLangFindUniqueArgs<ExtArgs>>): Prisma__TuitionLangClient<$Result.GetResult<Prisma.$TuitionLangPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TuitionLang that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TuitionLangFindUniqueOrThrowArgs} args - Arguments to find a TuitionLang
     * @example
     * // Get one TuitionLang
     * const tuitionLang = await prisma.tuitionLang.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TuitionLangFindUniqueOrThrowArgs>(args: SelectSubset<T, TuitionLangFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TuitionLangClient<$Result.GetResult<Prisma.$TuitionLangPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TuitionLang that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuitionLangFindFirstArgs} args - Arguments to find a TuitionLang
     * @example
     * // Get one TuitionLang
     * const tuitionLang = await prisma.tuitionLang.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TuitionLangFindFirstArgs>(args?: SelectSubset<T, TuitionLangFindFirstArgs<ExtArgs>>): Prisma__TuitionLangClient<$Result.GetResult<Prisma.$TuitionLangPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TuitionLang that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuitionLangFindFirstOrThrowArgs} args - Arguments to find a TuitionLang
     * @example
     * // Get one TuitionLang
     * const tuitionLang = await prisma.tuitionLang.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TuitionLangFindFirstOrThrowArgs>(args?: SelectSubset<T, TuitionLangFindFirstOrThrowArgs<ExtArgs>>): Prisma__TuitionLangClient<$Result.GetResult<Prisma.$TuitionLangPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TuitionLangs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuitionLangFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TuitionLangs
     * const tuitionLangs = await prisma.tuitionLang.findMany()
     * 
     * // Get first 10 TuitionLangs
     * const tuitionLangs = await prisma.tuitionLang.findMany({ take: 10 })
     * 
     * // Only select the `tuition_lang_code`
     * const tuitionLangWithTuition_lang_codeOnly = await prisma.tuitionLang.findMany({ select: { tuition_lang_code: true } })
     * 
     */
    findMany<T extends TuitionLangFindManyArgs>(args?: SelectSubset<T, TuitionLangFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TuitionLangPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TuitionLang.
     * @param {TuitionLangCreateArgs} args - Arguments to create a TuitionLang.
     * @example
     * // Create one TuitionLang
     * const TuitionLang = await prisma.tuitionLang.create({
     *   data: {
     *     // ... data to create a TuitionLang
     *   }
     * })
     * 
     */
    create<T extends TuitionLangCreateArgs>(args: SelectSubset<T, TuitionLangCreateArgs<ExtArgs>>): Prisma__TuitionLangClient<$Result.GetResult<Prisma.$TuitionLangPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TuitionLangs.
     * @param {TuitionLangCreateManyArgs} args - Arguments to create many TuitionLangs.
     * @example
     * // Create many TuitionLangs
     * const tuitionLang = await prisma.tuitionLang.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TuitionLangCreateManyArgs>(args?: SelectSubset<T, TuitionLangCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TuitionLangs and returns the data saved in the database.
     * @param {TuitionLangCreateManyAndReturnArgs} args - Arguments to create many TuitionLangs.
     * @example
     * // Create many TuitionLangs
     * const tuitionLang = await prisma.tuitionLang.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TuitionLangs and only return the `tuition_lang_code`
     * const tuitionLangWithTuition_lang_codeOnly = await prisma.tuitionLang.createManyAndReturn({ 
     *   select: { tuition_lang_code: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TuitionLangCreateManyAndReturnArgs>(args?: SelectSubset<T, TuitionLangCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TuitionLangPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TuitionLang.
     * @param {TuitionLangDeleteArgs} args - Arguments to delete one TuitionLang.
     * @example
     * // Delete one TuitionLang
     * const TuitionLang = await prisma.tuitionLang.delete({
     *   where: {
     *     // ... filter to delete one TuitionLang
     *   }
     * })
     * 
     */
    delete<T extends TuitionLangDeleteArgs>(args: SelectSubset<T, TuitionLangDeleteArgs<ExtArgs>>): Prisma__TuitionLangClient<$Result.GetResult<Prisma.$TuitionLangPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TuitionLang.
     * @param {TuitionLangUpdateArgs} args - Arguments to update one TuitionLang.
     * @example
     * // Update one TuitionLang
     * const tuitionLang = await prisma.tuitionLang.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TuitionLangUpdateArgs>(args: SelectSubset<T, TuitionLangUpdateArgs<ExtArgs>>): Prisma__TuitionLangClient<$Result.GetResult<Prisma.$TuitionLangPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TuitionLangs.
     * @param {TuitionLangDeleteManyArgs} args - Arguments to filter TuitionLangs to delete.
     * @example
     * // Delete a few TuitionLangs
     * const { count } = await prisma.tuitionLang.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TuitionLangDeleteManyArgs>(args?: SelectSubset<T, TuitionLangDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TuitionLangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuitionLangUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TuitionLangs
     * const tuitionLang = await prisma.tuitionLang.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TuitionLangUpdateManyArgs>(args: SelectSubset<T, TuitionLangUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TuitionLang.
     * @param {TuitionLangUpsertArgs} args - Arguments to update or create a TuitionLang.
     * @example
     * // Update or create a TuitionLang
     * const tuitionLang = await prisma.tuitionLang.upsert({
     *   create: {
     *     // ... data to create a TuitionLang
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TuitionLang we want to update
     *   }
     * })
     */
    upsert<T extends TuitionLangUpsertArgs>(args: SelectSubset<T, TuitionLangUpsertArgs<ExtArgs>>): Prisma__TuitionLangClient<$Result.GetResult<Prisma.$TuitionLangPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TuitionLangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuitionLangCountArgs} args - Arguments to filter TuitionLangs to count.
     * @example
     * // Count the number of TuitionLangs
     * const count = await prisma.tuitionLang.count({
     *   where: {
     *     // ... the filter for the TuitionLangs we want to count
     *   }
     * })
    **/
    count<T extends TuitionLangCountArgs>(
      args?: Subset<T, TuitionLangCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TuitionLangCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TuitionLang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuitionLangAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TuitionLangAggregateArgs>(args: Subset<T, TuitionLangAggregateArgs>): Prisma.PrismaPromise<GetTuitionLangAggregateType<T>>

    /**
     * Group by TuitionLang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuitionLangGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TuitionLangGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TuitionLangGroupByArgs['orderBy'] }
        : { orderBy?: TuitionLangGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TuitionLangGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTuitionLangGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TuitionLang model
   */
  readonly fields: TuitionLangFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TuitionLang.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TuitionLangClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends TuitionLang$classesArgs<ExtArgs> = {}>(args?: Subset<T, TuitionLang$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TuitionLang model
   */ 
  interface TuitionLangFieldRefs {
    readonly tuition_lang_code: FieldRef<"TuitionLang", 'String'>
    readonly tuition_lang_name: FieldRef<"TuitionLang", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TuitionLang findUnique
   */
  export type TuitionLangFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuitionLang
     */
    select?: TuitionLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuitionLangInclude<ExtArgs> | null
    /**
     * Filter, which TuitionLang to fetch.
     */
    where: TuitionLangWhereUniqueInput
  }

  /**
   * TuitionLang findUniqueOrThrow
   */
  export type TuitionLangFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuitionLang
     */
    select?: TuitionLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuitionLangInclude<ExtArgs> | null
    /**
     * Filter, which TuitionLang to fetch.
     */
    where: TuitionLangWhereUniqueInput
  }

  /**
   * TuitionLang findFirst
   */
  export type TuitionLangFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuitionLang
     */
    select?: TuitionLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuitionLangInclude<ExtArgs> | null
    /**
     * Filter, which TuitionLang to fetch.
     */
    where?: TuitionLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TuitionLangs to fetch.
     */
    orderBy?: TuitionLangOrderByWithRelationInput | TuitionLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TuitionLangs.
     */
    cursor?: TuitionLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TuitionLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TuitionLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TuitionLangs.
     */
    distinct?: TuitionLangScalarFieldEnum | TuitionLangScalarFieldEnum[]
  }

  /**
   * TuitionLang findFirstOrThrow
   */
  export type TuitionLangFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuitionLang
     */
    select?: TuitionLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuitionLangInclude<ExtArgs> | null
    /**
     * Filter, which TuitionLang to fetch.
     */
    where?: TuitionLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TuitionLangs to fetch.
     */
    orderBy?: TuitionLangOrderByWithRelationInput | TuitionLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TuitionLangs.
     */
    cursor?: TuitionLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TuitionLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TuitionLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TuitionLangs.
     */
    distinct?: TuitionLangScalarFieldEnum | TuitionLangScalarFieldEnum[]
  }

  /**
   * TuitionLang findMany
   */
  export type TuitionLangFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuitionLang
     */
    select?: TuitionLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuitionLangInclude<ExtArgs> | null
    /**
     * Filter, which TuitionLangs to fetch.
     */
    where?: TuitionLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TuitionLangs to fetch.
     */
    orderBy?: TuitionLangOrderByWithRelationInput | TuitionLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TuitionLangs.
     */
    cursor?: TuitionLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TuitionLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TuitionLangs.
     */
    skip?: number
    distinct?: TuitionLangScalarFieldEnum | TuitionLangScalarFieldEnum[]
  }

  /**
   * TuitionLang create
   */
  export type TuitionLangCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuitionLang
     */
    select?: TuitionLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuitionLangInclude<ExtArgs> | null
    /**
     * The data needed to create a TuitionLang.
     */
    data: XOR<TuitionLangCreateInput, TuitionLangUncheckedCreateInput>
  }

  /**
   * TuitionLang createMany
   */
  export type TuitionLangCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TuitionLangs.
     */
    data: TuitionLangCreateManyInput | TuitionLangCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TuitionLang createManyAndReturn
   */
  export type TuitionLangCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuitionLang
     */
    select?: TuitionLangSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TuitionLangs.
     */
    data: TuitionLangCreateManyInput | TuitionLangCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TuitionLang update
   */
  export type TuitionLangUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuitionLang
     */
    select?: TuitionLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuitionLangInclude<ExtArgs> | null
    /**
     * The data needed to update a TuitionLang.
     */
    data: XOR<TuitionLangUpdateInput, TuitionLangUncheckedUpdateInput>
    /**
     * Choose, which TuitionLang to update.
     */
    where: TuitionLangWhereUniqueInput
  }

  /**
   * TuitionLang updateMany
   */
  export type TuitionLangUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TuitionLangs.
     */
    data: XOR<TuitionLangUpdateManyMutationInput, TuitionLangUncheckedUpdateManyInput>
    /**
     * Filter which TuitionLangs to update
     */
    where?: TuitionLangWhereInput
  }

  /**
   * TuitionLang upsert
   */
  export type TuitionLangUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuitionLang
     */
    select?: TuitionLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuitionLangInclude<ExtArgs> | null
    /**
     * The filter to search for the TuitionLang to update in case it exists.
     */
    where: TuitionLangWhereUniqueInput
    /**
     * In case the TuitionLang found by the `where` argument doesn't exist, create a new TuitionLang with this data.
     */
    create: XOR<TuitionLangCreateInput, TuitionLangUncheckedCreateInput>
    /**
     * In case the TuitionLang was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TuitionLangUpdateInput, TuitionLangUncheckedUpdateInput>
  }

  /**
   * TuitionLang delete
   */
  export type TuitionLangDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuitionLang
     */
    select?: TuitionLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuitionLangInclude<ExtArgs> | null
    /**
     * Filter which TuitionLang to delete.
     */
    where: TuitionLangWhereUniqueInput
  }

  /**
   * TuitionLang deleteMany
   */
  export type TuitionLangDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TuitionLangs to delete
     */
    where?: TuitionLangWhereInput
  }

  /**
   * TuitionLang.classes
   */
  export type TuitionLang$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * TuitionLang without action
   */
  export type TuitionLangDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuitionLang
     */
    select?: TuitionLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuitionLangInclude<ExtArgs> | null
  }


  /**
   * Model Deck
   */

  export type AggregateDeck = {
    _count: DeckCountAggregateOutputType | null
    _min: DeckMinAggregateOutputType | null
    _max: DeckMaxAggregateOutputType | null
  }

  export type DeckMinAggregateOutputType = {
    deck_id: string | null
    user_id: string | null
    deck_description: string | null
  }

  export type DeckMaxAggregateOutputType = {
    deck_id: string | null
    user_id: string | null
    deck_description: string | null
  }

  export type DeckCountAggregateOutputType = {
    deck_id: number
    user_id: number
    deck_description: number
    _all: number
  }


  export type DeckMinAggregateInputType = {
    deck_id?: true
    user_id?: true
    deck_description?: true
  }

  export type DeckMaxAggregateInputType = {
    deck_id?: true
    user_id?: true
    deck_description?: true
  }

  export type DeckCountAggregateInputType = {
    deck_id?: true
    user_id?: true
    deck_description?: true
    _all?: true
  }

  export type DeckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deck to aggregate.
     */
    where?: DeckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Decks to fetch.
     */
    orderBy?: DeckOrderByWithRelationInput | DeckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Decks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Decks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Decks
    **/
    _count?: true | DeckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeckMaxAggregateInputType
  }

  export type GetDeckAggregateType<T extends DeckAggregateArgs> = {
        [P in keyof T & keyof AggregateDeck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeck[P]>
      : GetScalarType<T[P], AggregateDeck[P]>
  }




  export type DeckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeckWhereInput
    orderBy?: DeckOrderByWithAggregationInput | DeckOrderByWithAggregationInput[]
    by: DeckScalarFieldEnum[] | DeckScalarFieldEnum
    having?: DeckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeckCountAggregateInputType | true
    _min?: DeckMinAggregateInputType
    _max?: DeckMaxAggregateInputType
  }

  export type DeckGroupByOutputType = {
    deck_id: string
    user_id: string
    deck_description: string | null
    _count: DeckCountAggregateOutputType | null
    _min: DeckMinAggregateOutputType | null
    _max: DeckMaxAggregateOutputType | null
  }

  type GetDeckGroupByPayload<T extends DeckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeckGroupByOutputType[P]>
            : GetScalarType<T[P], DeckGroupByOutputType[P]>
        }
      >
    >


  export type DeckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    deck_id?: boolean
    user_id?: boolean
    deck_description?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    Card?: boolean | Deck$CardArgs<ExtArgs>
    _count?: boolean | DeckCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deck"]>

  export type DeckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    deck_id?: boolean
    user_id?: boolean
    deck_description?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deck"]>

  export type DeckSelectScalar = {
    deck_id?: boolean
    user_id?: boolean
    deck_description?: boolean
  }

  export type DeckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    Card?: boolean | Deck$CardArgs<ExtArgs>
    _count?: boolean | DeckCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deck"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      Card: Prisma.$LessonCardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      deck_id: string
      user_id: string
      deck_description: string | null
    }, ExtArgs["result"]["deck"]>
    composites: {}
  }

  type DeckGetPayload<S extends boolean | null | undefined | DeckDefaultArgs> = $Result.GetResult<Prisma.$DeckPayload, S>

  type DeckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeckFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeckCountAggregateInputType | true
    }

  export interface DeckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deck'], meta: { name: 'Deck' } }
    /**
     * Find zero or one Deck that matches the filter.
     * @param {DeckFindUniqueArgs} args - Arguments to find a Deck
     * @example
     * // Get one Deck
     * const deck = await prisma.deck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeckFindUniqueArgs>(args: SelectSubset<T, DeckFindUniqueArgs<ExtArgs>>): Prisma__DeckClient<$Result.GetResult<Prisma.$DeckPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Deck that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeckFindUniqueOrThrowArgs} args - Arguments to find a Deck
     * @example
     * // Get one Deck
     * const deck = await prisma.deck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeckFindUniqueOrThrowArgs>(args: SelectSubset<T, DeckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeckClient<$Result.GetResult<Prisma.$DeckPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Deck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeckFindFirstArgs} args - Arguments to find a Deck
     * @example
     * // Get one Deck
     * const deck = await prisma.deck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeckFindFirstArgs>(args?: SelectSubset<T, DeckFindFirstArgs<ExtArgs>>): Prisma__DeckClient<$Result.GetResult<Prisma.$DeckPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Deck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeckFindFirstOrThrowArgs} args - Arguments to find a Deck
     * @example
     * // Get one Deck
     * const deck = await prisma.deck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeckFindFirstOrThrowArgs>(args?: SelectSubset<T, DeckFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeckClient<$Result.GetResult<Prisma.$DeckPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Decks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Decks
     * const decks = await prisma.deck.findMany()
     * 
     * // Get first 10 Decks
     * const decks = await prisma.deck.findMany({ take: 10 })
     * 
     * // Only select the `deck_id`
     * const deckWithDeck_idOnly = await prisma.deck.findMany({ select: { deck_id: true } })
     * 
     */
    findMany<T extends DeckFindManyArgs>(args?: SelectSubset<T, DeckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeckPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Deck.
     * @param {DeckCreateArgs} args - Arguments to create a Deck.
     * @example
     * // Create one Deck
     * const Deck = await prisma.deck.create({
     *   data: {
     *     // ... data to create a Deck
     *   }
     * })
     * 
     */
    create<T extends DeckCreateArgs>(args: SelectSubset<T, DeckCreateArgs<ExtArgs>>): Prisma__DeckClient<$Result.GetResult<Prisma.$DeckPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Decks.
     * @param {DeckCreateManyArgs} args - Arguments to create many Decks.
     * @example
     * // Create many Decks
     * const deck = await prisma.deck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeckCreateManyArgs>(args?: SelectSubset<T, DeckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Decks and returns the data saved in the database.
     * @param {DeckCreateManyAndReturnArgs} args - Arguments to create many Decks.
     * @example
     * // Create many Decks
     * const deck = await prisma.deck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Decks and only return the `deck_id`
     * const deckWithDeck_idOnly = await prisma.deck.createManyAndReturn({ 
     *   select: { deck_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeckCreateManyAndReturnArgs>(args?: SelectSubset<T, DeckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeckPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Deck.
     * @param {DeckDeleteArgs} args - Arguments to delete one Deck.
     * @example
     * // Delete one Deck
     * const Deck = await prisma.deck.delete({
     *   where: {
     *     // ... filter to delete one Deck
     *   }
     * })
     * 
     */
    delete<T extends DeckDeleteArgs>(args: SelectSubset<T, DeckDeleteArgs<ExtArgs>>): Prisma__DeckClient<$Result.GetResult<Prisma.$DeckPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Deck.
     * @param {DeckUpdateArgs} args - Arguments to update one Deck.
     * @example
     * // Update one Deck
     * const deck = await prisma.deck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeckUpdateArgs>(args: SelectSubset<T, DeckUpdateArgs<ExtArgs>>): Prisma__DeckClient<$Result.GetResult<Prisma.$DeckPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Decks.
     * @param {DeckDeleteManyArgs} args - Arguments to filter Decks to delete.
     * @example
     * // Delete a few Decks
     * const { count } = await prisma.deck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeckDeleteManyArgs>(args?: SelectSubset<T, DeckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Decks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Decks
     * const deck = await prisma.deck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeckUpdateManyArgs>(args: SelectSubset<T, DeckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deck.
     * @param {DeckUpsertArgs} args - Arguments to update or create a Deck.
     * @example
     * // Update or create a Deck
     * const deck = await prisma.deck.upsert({
     *   create: {
     *     // ... data to create a Deck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deck we want to update
     *   }
     * })
     */
    upsert<T extends DeckUpsertArgs>(args: SelectSubset<T, DeckUpsertArgs<ExtArgs>>): Prisma__DeckClient<$Result.GetResult<Prisma.$DeckPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Decks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeckCountArgs} args - Arguments to filter Decks to count.
     * @example
     * // Count the number of Decks
     * const count = await prisma.deck.count({
     *   where: {
     *     // ... the filter for the Decks we want to count
     *   }
     * })
    **/
    count<T extends DeckCountArgs>(
      args?: Subset<T, DeckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeckAggregateArgs>(args: Subset<T, DeckAggregateArgs>): Prisma.PrismaPromise<GetDeckAggregateType<T>>

    /**
     * Group by Deck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeckGroupByArgs['orderBy'] }
        : { orderBy?: DeckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deck model
   */
  readonly fields: DeckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Card<T extends Deck$CardArgs<ExtArgs> = {}>(args?: Subset<T, Deck$CardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCardPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deck model
   */ 
  interface DeckFieldRefs {
    readonly deck_id: FieldRef<"Deck", 'String'>
    readonly user_id: FieldRef<"Deck", 'String'>
    readonly deck_description: FieldRef<"Deck", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Deck findUnique
   */
  export type DeckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deck
     */
    select?: DeckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeckInclude<ExtArgs> | null
    /**
     * Filter, which Deck to fetch.
     */
    where: DeckWhereUniqueInput
  }

  /**
   * Deck findUniqueOrThrow
   */
  export type DeckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deck
     */
    select?: DeckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeckInclude<ExtArgs> | null
    /**
     * Filter, which Deck to fetch.
     */
    where: DeckWhereUniqueInput
  }

  /**
   * Deck findFirst
   */
  export type DeckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deck
     */
    select?: DeckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeckInclude<ExtArgs> | null
    /**
     * Filter, which Deck to fetch.
     */
    where?: DeckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Decks to fetch.
     */
    orderBy?: DeckOrderByWithRelationInput | DeckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Decks.
     */
    cursor?: DeckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Decks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Decks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Decks.
     */
    distinct?: DeckScalarFieldEnum | DeckScalarFieldEnum[]
  }

  /**
   * Deck findFirstOrThrow
   */
  export type DeckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deck
     */
    select?: DeckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeckInclude<ExtArgs> | null
    /**
     * Filter, which Deck to fetch.
     */
    where?: DeckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Decks to fetch.
     */
    orderBy?: DeckOrderByWithRelationInput | DeckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Decks.
     */
    cursor?: DeckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Decks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Decks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Decks.
     */
    distinct?: DeckScalarFieldEnum | DeckScalarFieldEnum[]
  }

  /**
   * Deck findMany
   */
  export type DeckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deck
     */
    select?: DeckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeckInclude<ExtArgs> | null
    /**
     * Filter, which Decks to fetch.
     */
    where?: DeckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Decks to fetch.
     */
    orderBy?: DeckOrderByWithRelationInput | DeckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Decks.
     */
    cursor?: DeckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Decks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Decks.
     */
    skip?: number
    distinct?: DeckScalarFieldEnum | DeckScalarFieldEnum[]
  }

  /**
   * Deck create
   */
  export type DeckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deck
     */
    select?: DeckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeckInclude<ExtArgs> | null
    /**
     * The data needed to create a Deck.
     */
    data: XOR<DeckCreateInput, DeckUncheckedCreateInput>
  }

  /**
   * Deck createMany
   */
  export type DeckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Decks.
     */
    data: DeckCreateManyInput | DeckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deck createManyAndReturn
   */
  export type DeckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deck
     */
    select?: DeckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Decks.
     */
    data: DeckCreateManyInput | DeckCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeckIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deck update
   */
  export type DeckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deck
     */
    select?: DeckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeckInclude<ExtArgs> | null
    /**
     * The data needed to update a Deck.
     */
    data: XOR<DeckUpdateInput, DeckUncheckedUpdateInput>
    /**
     * Choose, which Deck to update.
     */
    where: DeckWhereUniqueInput
  }

  /**
   * Deck updateMany
   */
  export type DeckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Decks.
     */
    data: XOR<DeckUpdateManyMutationInput, DeckUncheckedUpdateManyInput>
    /**
     * Filter which Decks to update
     */
    where?: DeckWhereInput
  }

  /**
   * Deck upsert
   */
  export type DeckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deck
     */
    select?: DeckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeckInclude<ExtArgs> | null
    /**
     * The filter to search for the Deck to update in case it exists.
     */
    where: DeckWhereUniqueInput
    /**
     * In case the Deck found by the `where` argument doesn't exist, create a new Deck with this data.
     */
    create: XOR<DeckCreateInput, DeckUncheckedCreateInput>
    /**
     * In case the Deck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeckUpdateInput, DeckUncheckedUpdateInput>
  }

  /**
   * Deck delete
   */
  export type DeckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deck
     */
    select?: DeckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeckInclude<ExtArgs> | null
    /**
     * Filter which Deck to delete.
     */
    where: DeckWhereUniqueInput
  }

  /**
   * Deck deleteMany
   */
  export type DeckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Decks to delete
     */
    where?: DeckWhereInput
  }

  /**
   * Deck.Card
   */
  export type Deck$CardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCard
     */
    select?: LessonCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCardInclude<ExtArgs> | null
    where?: LessonCardWhereInput
    orderBy?: LessonCardOrderByWithRelationInput | LessonCardOrderByWithRelationInput[]
    cursor?: LessonCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonCardScalarFieldEnum | LessonCardScalarFieldEnum[]
  }

  /**
   * Deck without action
   */
  export type DeckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deck
     */
    select?: DeckSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeckInclude<ExtArgs> | null
  }


  /**
   * Model LessonCard
   */

  export type AggregateLessonCard = {
    _count: LessonCardCountAggregateOutputType | null
    _avg: LessonCardAvgAggregateOutputType | null
    _sum: LessonCardSumAggregateOutputType | null
    _min: LessonCardMinAggregateOutputType | null
    _max: LessonCardMaxAggregateOutputType | null
  }

  export type LessonCardAvgAggregateOutputType = {
    lesson_id: number | null
  }

  export type LessonCardSumAggregateOutputType = {
    lesson_id: number | null
  }

  export type LessonCardMinAggregateOutputType = {
    card_id: string | null
    deck_id: string | null
    question: string | null
    answer: string | null
    example: string | null
    course_code: string | null
    lesson_id: number | null
  }

  export type LessonCardMaxAggregateOutputType = {
    card_id: string | null
    deck_id: string | null
    question: string | null
    answer: string | null
    example: string | null
    course_code: string | null
    lesson_id: number | null
  }

  export type LessonCardCountAggregateOutputType = {
    card_id: number
    deck_id: number
    question: number
    answer: number
    example: number
    course_code: number
    lesson_id: number
    _all: number
  }


  export type LessonCardAvgAggregateInputType = {
    lesson_id?: true
  }

  export type LessonCardSumAggregateInputType = {
    lesson_id?: true
  }

  export type LessonCardMinAggregateInputType = {
    card_id?: true
    deck_id?: true
    question?: true
    answer?: true
    example?: true
    course_code?: true
    lesson_id?: true
  }

  export type LessonCardMaxAggregateInputType = {
    card_id?: true
    deck_id?: true
    question?: true
    answer?: true
    example?: true
    course_code?: true
    lesson_id?: true
  }

  export type LessonCardCountAggregateInputType = {
    card_id?: true
    deck_id?: true
    question?: true
    answer?: true
    example?: true
    course_code?: true
    lesson_id?: true
    _all?: true
  }

  export type LessonCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonCard to aggregate.
     */
    where?: LessonCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonCards to fetch.
     */
    orderBy?: LessonCardOrderByWithRelationInput | LessonCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonCards
    **/
    _count?: true | LessonCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonCardMaxAggregateInputType
  }

  export type GetLessonCardAggregateType<T extends LessonCardAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonCard[P]>
      : GetScalarType<T[P], AggregateLessonCard[P]>
  }




  export type LessonCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonCardWhereInput
    orderBy?: LessonCardOrderByWithAggregationInput | LessonCardOrderByWithAggregationInput[]
    by: LessonCardScalarFieldEnum[] | LessonCardScalarFieldEnum
    having?: LessonCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCardCountAggregateInputType | true
    _avg?: LessonCardAvgAggregateInputType
    _sum?: LessonCardSumAggregateInputType
    _min?: LessonCardMinAggregateInputType
    _max?: LessonCardMaxAggregateInputType
  }

  export type LessonCardGroupByOutputType = {
    card_id: string
    deck_id: string
    question: string
    answer: string
    example: string | null
    course_code: string
    lesson_id: number
    _count: LessonCardCountAggregateOutputType | null
    _avg: LessonCardAvgAggregateOutputType | null
    _sum: LessonCardSumAggregateOutputType | null
    _min: LessonCardMinAggregateOutputType | null
    _max: LessonCardMaxAggregateOutputType | null
  }

  type GetLessonCardGroupByPayload<T extends LessonCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonCardGroupByOutputType[P]>
            : GetScalarType<T[P], LessonCardGroupByOutputType[P]>
        }
      >
    >


  export type LessonCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    card_id?: boolean
    deck_id?: boolean
    question?: boolean
    answer?: boolean
    example?: boolean
    course_code?: boolean
    lesson_id?: boolean
    deck?: boolean | DeckDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonCard"]>

  export type LessonCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    card_id?: boolean
    deck_id?: boolean
    question?: boolean
    answer?: boolean
    example?: boolean
    course_code?: boolean
    lesson_id?: boolean
    deck?: boolean | DeckDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lessonCard"]>

  export type LessonCardSelectScalar = {
    card_id?: boolean
    deck_id?: boolean
    question?: boolean
    answer?: boolean
    example?: boolean
    course_code?: boolean
    lesson_id?: boolean
  }

  export type LessonCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deck?: boolean | DeckDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type LessonCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deck?: boolean | DeckDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $LessonCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LessonCard"
    objects: {
      deck: Prisma.$DeckPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      lesson: Prisma.$LessonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      card_id: string
      deck_id: string
      question: string
      answer: string
      example: string | null
      course_code: string
      lesson_id: number
    }, ExtArgs["result"]["lessonCard"]>
    composites: {}
  }

  type LessonCardGetPayload<S extends boolean | null | undefined | LessonCardDefaultArgs> = $Result.GetResult<Prisma.$LessonCardPayload, S>

  type LessonCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LessonCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LessonCardCountAggregateInputType | true
    }

  export interface LessonCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonCard'], meta: { name: 'LessonCard' } }
    /**
     * Find zero or one LessonCard that matches the filter.
     * @param {LessonCardFindUniqueArgs} args - Arguments to find a LessonCard
     * @example
     * // Get one LessonCard
     * const lessonCard = await prisma.lessonCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonCardFindUniqueArgs>(args: SelectSubset<T, LessonCardFindUniqueArgs<ExtArgs>>): Prisma__LessonCardClient<$Result.GetResult<Prisma.$LessonCardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LessonCard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LessonCardFindUniqueOrThrowArgs} args - Arguments to find a LessonCard
     * @example
     * // Get one LessonCard
     * const lessonCard = await prisma.lessonCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonCardFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonCardClient<$Result.GetResult<Prisma.$LessonCardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LessonCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCardFindFirstArgs} args - Arguments to find a LessonCard
     * @example
     * // Get one LessonCard
     * const lessonCard = await prisma.lessonCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonCardFindFirstArgs>(args?: SelectSubset<T, LessonCardFindFirstArgs<ExtArgs>>): Prisma__LessonCardClient<$Result.GetResult<Prisma.$LessonCardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LessonCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCardFindFirstOrThrowArgs} args - Arguments to find a LessonCard
     * @example
     * // Get one LessonCard
     * const lessonCard = await prisma.lessonCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonCardFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonCardClient<$Result.GetResult<Prisma.$LessonCardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LessonCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonCards
     * const lessonCards = await prisma.lessonCard.findMany()
     * 
     * // Get first 10 LessonCards
     * const lessonCards = await prisma.lessonCard.findMany({ take: 10 })
     * 
     * // Only select the `card_id`
     * const lessonCardWithCard_idOnly = await prisma.lessonCard.findMany({ select: { card_id: true } })
     * 
     */
    findMany<T extends LessonCardFindManyArgs>(args?: SelectSubset<T, LessonCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LessonCard.
     * @param {LessonCardCreateArgs} args - Arguments to create a LessonCard.
     * @example
     * // Create one LessonCard
     * const LessonCard = await prisma.lessonCard.create({
     *   data: {
     *     // ... data to create a LessonCard
     *   }
     * })
     * 
     */
    create<T extends LessonCardCreateArgs>(args: SelectSubset<T, LessonCardCreateArgs<ExtArgs>>): Prisma__LessonCardClient<$Result.GetResult<Prisma.$LessonCardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LessonCards.
     * @param {LessonCardCreateManyArgs} args - Arguments to create many LessonCards.
     * @example
     * // Create many LessonCards
     * const lessonCard = await prisma.lessonCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCardCreateManyArgs>(args?: SelectSubset<T, LessonCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LessonCards and returns the data saved in the database.
     * @param {LessonCardCreateManyAndReturnArgs} args - Arguments to create many LessonCards.
     * @example
     * // Create many LessonCards
     * const lessonCard = await prisma.lessonCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LessonCards and only return the `card_id`
     * const lessonCardWithCard_idOnly = await prisma.lessonCard.createManyAndReturn({ 
     *   select: { card_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCardCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonCardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LessonCard.
     * @param {LessonCardDeleteArgs} args - Arguments to delete one LessonCard.
     * @example
     * // Delete one LessonCard
     * const LessonCard = await prisma.lessonCard.delete({
     *   where: {
     *     // ... filter to delete one LessonCard
     *   }
     * })
     * 
     */
    delete<T extends LessonCardDeleteArgs>(args: SelectSubset<T, LessonCardDeleteArgs<ExtArgs>>): Prisma__LessonCardClient<$Result.GetResult<Prisma.$LessonCardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LessonCard.
     * @param {LessonCardUpdateArgs} args - Arguments to update one LessonCard.
     * @example
     * // Update one LessonCard
     * const lessonCard = await prisma.lessonCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonCardUpdateArgs>(args: SelectSubset<T, LessonCardUpdateArgs<ExtArgs>>): Prisma__LessonCardClient<$Result.GetResult<Prisma.$LessonCardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LessonCards.
     * @param {LessonCardDeleteManyArgs} args - Arguments to filter LessonCards to delete.
     * @example
     * // Delete a few LessonCards
     * const { count } = await prisma.lessonCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonCardDeleteManyArgs>(args?: SelectSubset<T, LessonCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonCards
     * const lessonCard = await prisma.lessonCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonCardUpdateManyArgs>(args: SelectSubset<T, LessonCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LessonCard.
     * @param {LessonCardUpsertArgs} args - Arguments to update or create a LessonCard.
     * @example
     * // Update or create a LessonCard
     * const lessonCard = await prisma.lessonCard.upsert({
     *   create: {
     *     // ... data to create a LessonCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonCard we want to update
     *   }
     * })
     */
    upsert<T extends LessonCardUpsertArgs>(args: SelectSubset<T, LessonCardUpsertArgs<ExtArgs>>): Prisma__LessonCardClient<$Result.GetResult<Prisma.$LessonCardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LessonCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCardCountArgs} args - Arguments to filter LessonCards to count.
     * @example
     * // Count the number of LessonCards
     * const count = await prisma.lessonCard.count({
     *   where: {
     *     // ... the filter for the LessonCards we want to count
     *   }
     * })
    **/
    count<T extends LessonCardCountArgs>(
      args?: Subset<T, LessonCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonCardAggregateArgs>(args: Subset<T, LessonCardAggregateArgs>): Prisma.PrismaPromise<GetLessonCardAggregateType<T>>

    /**
     * Group by LessonCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonCardGroupByArgs['orderBy'] }
        : { orderBy?: LessonCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LessonCard model
   */
  readonly fields: LessonCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deck<T extends DeckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeckDefaultArgs<ExtArgs>>): Prisma__DeckClient<$Result.GetResult<Prisma.$DeckPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LessonCard model
   */ 
  interface LessonCardFieldRefs {
    readonly card_id: FieldRef<"LessonCard", 'String'>
    readonly deck_id: FieldRef<"LessonCard", 'String'>
    readonly question: FieldRef<"LessonCard", 'String'>
    readonly answer: FieldRef<"LessonCard", 'String'>
    readonly example: FieldRef<"LessonCard", 'String'>
    readonly course_code: FieldRef<"LessonCard", 'String'>
    readonly lesson_id: FieldRef<"LessonCard", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LessonCard findUnique
   */
  export type LessonCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCard
     */
    select?: LessonCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCardInclude<ExtArgs> | null
    /**
     * Filter, which LessonCard to fetch.
     */
    where: LessonCardWhereUniqueInput
  }

  /**
   * LessonCard findUniqueOrThrow
   */
  export type LessonCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCard
     */
    select?: LessonCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCardInclude<ExtArgs> | null
    /**
     * Filter, which LessonCard to fetch.
     */
    where: LessonCardWhereUniqueInput
  }

  /**
   * LessonCard findFirst
   */
  export type LessonCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCard
     */
    select?: LessonCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCardInclude<ExtArgs> | null
    /**
     * Filter, which LessonCard to fetch.
     */
    where?: LessonCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonCards to fetch.
     */
    orderBy?: LessonCardOrderByWithRelationInput | LessonCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonCards.
     */
    cursor?: LessonCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonCards.
     */
    distinct?: LessonCardScalarFieldEnum | LessonCardScalarFieldEnum[]
  }

  /**
   * LessonCard findFirstOrThrow
   */
  export type LessonCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCard
     */
    select?: LessonCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCardInclude<ExtArgs> | null
    /**
     * Filter, which LessonCard to fetch.
     */
    where?: LessonCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonCards to fetch.
     */
    orderBy?: LessonCardOrderByWithRelationInput | LessonCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonCards.
     */
    cursor?: LessonCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonCards.
     */
    distinct?: LessonCardScalarFieldEnum | LessonCardScalarFieldEnum[]
  }

  /**
   * LessonCard findMany
   */
  export type LessonCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCard
     */
    select?: LessonCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCardInclude<ExtArgs> | null
    /**
     * Filter, which LessonCards to fetch.
     */
    where?: LessonCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonCards to fetch.
     */
    orderBy?: LessonCardOrderByWithRelationInput | LessonCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonCards.
     */
    cursor?: LessonCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonCards.
     */
    skip?: number
    distinct?: LessonCardScalarFieldEnum | LessonCardScalarFieldEnum[]
  }

  /**
   * LessonCard create
   */
  export type LessonCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCard
     */
    select?: LessonCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCardInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonCard.
     */
    data: XOR<LessonCardCreateInput, LessonCardUncheckedCreateInput>
  }

  /**
   * LessonCard createMany
   */
  export type LessonCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonCards.
     */
    data: LessonCardCreateManyInput | LessonCardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LessonCard createManyAndReturn
   */
  export type LessonCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCard
     */
    select?: LessonCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LessonCards.
     */
    data: LessonCardCreateManyInput | LessonCardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LessonCard update
   */
  export type LessonCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCard
     */
    select?: LessonCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCardInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonCard.
     */
    data: XOR<LessonCardUpdateInput, LessonCardUncheckedUpdateInput>
    /**
     * Choose, which LessonCard to update.
     */
    where: LessonCardWhereUniqueInput
  }

  /**
   * LessonCard updateMany
   */
  export type LessonCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonCards.
     */
    data: XOR<LessonCardUpdateManyMutationInput, LessonCardUncheckedUpdateManyInput>
    /**
     * Filter which LessonCards to update
     */
    where?: LessonCardWhereInput
  }

  /**
   * LessonCard upsert
   */
  export type LessonCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCard
     */
    select?: LessonCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCardInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonCard to update in case it exists.
     */
    where: LessonCardWhereUniqueInput
    /**
     * In case the LessonCard found by the `where` argument doesn't exist, create a new LessonCard with this data.
     */
    create: XOR<LessonCardCreateInput, LessonCardUncheckedCreateInput>
    /**
     * In case the LessonCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonCardUpdateInput, LessonCardUncheckedUpdateInput>
  }

  /**
   * LessonCard delete
   */
  export type LessonCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCard
     */
    select?: LessonCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCardInclude<ExtArgs> | null
    /**
     * Filter which LessonCard to delete.
     */
    where: LessonCardWhereUniqueInput
  }

  /**
   * LessonCard deleteMany
   */
  export type LessonCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonCards to delete
     */
    where?: LessonCardWhereInput
  }

  /**
   * LessonCard without action
   */
  export type LessonCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCard
     */
    select?: LessonCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonCardInclude<ExtArgs> | null
  }


  /**
   * Model UserCard
   */

  export type AggregateUserCard = {
    _count: UserCardCountAggregateOutputType | null
    _avg: UserCardAvgAggregateOutputType | null
    _sum: UserCardSumAggregateOutputType | null
    _min: UserCardMinAggregateOutputType | null
    _max: UserCardMaxAggregateOutputType | null
  }

  export type UserCardAvgAggregateOutputType = {
    lesson_id: number | null
  }

  export type UserCardSumAggregateOutputType = {
    lesson_id: number | null
  }

  export type UserCardMinAggregateOutputType = {
    user_card_id: string | null
    user_id: string | null
    question: string | null
    answer: string | null
    example: string | null
    lesson_id: number | null
  }

  export type UserCardMaxAggregateOutputType = {
    user_card_id: string | null
    user_id: string | null
    question: string | null
    answer: string | null
    example: string | null
    lesson_id: number | null
  }

  export type UserCardCountAggregateOutputType = {
    user_card_id: number
    user_id: number
    question: number
    answer: number
    example: number
    lesson_id: number
    _all: number
  }


  export type UserCardAvgAggregateInputType = {
    lesson_id?: true
  }

  export type UserCardSumAggregateInputType = {
    lesson_id?: true
  }

  export type UserCardMinAggregateInputType = {
    user_card_id?: true
    user_id?: true
    question?: true
    answer?: true
    example?: true
    lesson_id?: true
  }

  export type UserCardMaxAggregateInputType = {
    user_card_id?: true
    user_id?: true
    question?: true
    answer?: true
    example?: true
    lesson_id?: true
  }

  export type UserCardCountAggregateInputType = {
    user_card_id?: true
    user_id?: true
    question?: true
    answer?: true
    example?: true
    lesson_id?: true
    _all?: true
  }

  export type UserCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCard to aggregate.
     */
    where?: UserCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCards to fetch.
     */
    orderBy?: UserCardOrderByWithRelationInput | UserCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCards
    **/
    _count?: true | UserCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCardMaxAggregateInputType
  }

  export type GetUserCardAggregateType<T extends UserCardAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCard[P]>
      : GetScalarType<T[P], AggregateUserCard[P]>
  }




  export type UserCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCardWhereInput
    orderBy?: UserCardOrderByWithAggregationInput | UserCardOrderByWithAggregationInput[]
    by: UserCardScalarFieldEnum[] | UserCardScalarFieldEnum
    having?: UserCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCardCountAggregateInputType | true
    _avg?: UserCardAvgAggregateInputType
    _sum?: UserCardSumAggregateInputType
    _min?: UserCardMinAggregateInputType
    _max?: UserCardMaxAggregateInputType
  }

  export type UserCardGroupByOutputType = {
    user_card_id: string
    user_id: string
    question: string
    answer: string
    example: string | null
    lesson_id: number | null
    _count: UserCardCountAggregateOutputType | null
    _avg: UserCardAvgAggregateOutputType | null
    _sum: UserCardSumAggregateOutputType | null
    _min: UserCardMinAggregateOutputType | null
    _max: UserCardMaxAggregateOutputType | null
  }

  type GetUserCardGroupByPayload<T extends UserCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCardGroupByOutputType[P]>
            : GetScalarType<T[P], UserCardGroupByOutputType[P]>
        }
      >
    >


  export type UserCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_card_id?: boolean
    user_id?: boolean
    question?: boolean
    answer?: boolean
    example?: boolean
    lesson_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | UserCard$lessonArgs<ExtArgs>
  }, ExtArgs["result"]["userCard"]>

  export type UserCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_card_id?: boolean
    user_id?: boolean
    question?: boolean
    answer?: boolean
    example?: boolean
    lesson_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | UserCard$lessonArgs<ExtArgs>
  }, ExtArgs["result"]["userCard"]>

  export type UserCardSelectScalar = {
    user_card_id?: boolean
    user_id?: boolean
    question?: boolean
    answer?: boolean
    example?: boolean
    lesson_id?: boolean
  }

  export type UserCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | UserCard$lessonArgs<ExtArgs>
  }
  export type UserCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lesson?: boolean | UserCard$lessonArgs<ExtArgs>
  }

  export type $UserCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCard"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      lesson: Prisma.$LessonPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      user_card_id: string
      user_id: string
      question: string
      answer: string
      example: string | null
      lesson_id: number | null
    }, ExtArgs["result"]["userCard"]>
    composites: {}
  }

  type UserCardGetPayload<S extends boolean | null | undefined | UserCardDefaultArgs> = $Result.GetResult<Prisma.$UserCardPayload, S>

  type UserCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCardCountAggregateInputType | true
    }

  export interface UserCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCard'], meta: { name: 'UserCard' } }
    /**
     * Find zero or one UserCard that matches the filter.
     * @param {UserCardFindUniqueArgs} args - Arguments to find a UserCard
     * @example
     * // Get one UserCard
     * const userCard = await prisma.userCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCardFindUniqueArgs>(args: SelectSubset<T, UserCardFindUniqueArgs<ExtArgs>>): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserCard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserCardFindUniqueOrThrowArgs} args - Arguments to find a UserCard
     * @example
     * // Get one UserCard
     * const userCard = await prisma.userCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCardFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardFindFirstArgs} args - Arguments to find a UserCard
     * @example
     * // Get one UserCard
     * const userCard = await prisma.userCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCardFindFirstArgs>(args?: SelectSubset<T, UserCardFindFirstArgs<ExtArgs>>): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardFindFirstOrThrowArgs} args - Arguments to find a UserCard
     * @example
     * // Get one UserCard
     * const userCard = await prisma.userCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCardFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCards
     * const userCards = await prisma.userCard.findMany()
     * 
     * // Get first 10 UserCards
     * const userCards = await prisma.userCard.findMany({ take: 10 })
     * 
     * // Only select the `user_card_id`
     * const userCardWithUser_card_idOnly = await prisma.userCard.findMany({ select: { user_card_id: true } })
     * 
     */
    findMany<T extends UserCardFindManyArgs>(args?: SelectSubset<T, UserCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserCard.
     * @param {UserCardCreateArgs} args - Arguments to create a UserCard.
     * @example
     * // Create one UserCard
     * const UserCard = await prisma.userCard.create({
     *   data: {
     *     // ... data to create a UserCard
     *   }
     * })
     * 
     */
    create<T extends UserCardCreateArgs>(args: SelectSubset<T, UserCardCreateArgs<ExtArgs>>): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserCards.
     * @param {UserCardCreateManyArgs} args - Arguments to create many UserCards.
     * @example
     * // Create many UserCards
     * const userCard = await prisma.userCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCardCreateManyArgs>(args?: SelectSubset<T, UserCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserCards and returns the data saved in the database.
     * @param {UserCardCreateManyAndReturnArgs} args - Arguments to create many UserCards.
     * @example
     * // Create many UserCards
     * const userCard = await prisma.userCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserCards and only return the `user_card_id`
     * const userCardWithUser_card_idOnly = await prisma.userCard.createManyAndReturn({ 
     *   select: { user_card_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCardCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserCard.
     * @param {UserCardDeleteArgs} args - Arguments to delete one UserCard.
     * @example
     * // Delete one UserCard
     * const UserCard = await prisma.userCard.delete({
     *   where: {
     *     // ... filter to delete one UserCard
     *   }
     * })
     * 
     */
    delete<T extends UserCardDeleteArgs>(args: SelectSubset<T, UserCardDeleteArgs<ExtArgs>>): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserCard.
     * @param {UserCardUpdateArgs} args - Arguments to update one UserCard.
     * @example
     * // Update one UserCard
     * const userCard = await prisma.userCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCardUpdateArgs>(args: SelectSubset<T, UserCardUpdateArgs<ExtArgs>>): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserCards.
     * @param {UserCardDeleteManyArgs} args - Arguments to filter UserCards to delete.
     * @example
     * // Delete a few UserCards
     * const { count } = await prisma.userCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCardDeleteManyArgs>(args?: SelectSubset<T, UserCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCards
     * const userCard = await prisma.userCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCardUpdateManyArgs>(args: SelectSubset<T, UserCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserCard.
     * @param {UserCardUpsertArgs} args - Arguments to update or create a UserCard.
     * @example
     * // Update or create a UserCard
     * const userCard = await prisma.userCard.upsert({
     *   create: {
     *     // ... data to create a UserCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCard we want to update
     *   }
     * })
     */
    upsert<T extends UserCardUpsertArgs>(args: SelectSubset<T, UserCardUpsertArgs<ExtArgs>>): Prisma__UserCardClient<$Result.GetResult<Prisma.$UserCardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardCountArgs} args - Arguments to filter UserCards to count.
     * @example
     * // Count the number of UserCards
     * const count = await prisma.userCard.count({
     *   where: {
     *     // ... the filter for the UserCards we want to count
     *   }
     * })
    **/
    count<T extends UserCardCountArgs>(
      args?: Subset<T, UserCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCardAggregateArgs>(args: Subset<T, UserCardAggregateArgs>): Prisma.PrismaPromise<GetUserCardAggregateType<T>>

    /**
     * Group by UserCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCardGroupByArgs['orderBy'] }
        : { orderBy?: UserCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCard model
   */
  readonly fields: UserCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lesson<T extends UserCard$lessonArgs<ExtArgs> = {}>(args?: Subset<T, UserCard$lessonArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCard model
   */ 
  interface UserCardFieldRefs {
    readonly user_card_id: FieldRef<"UserCard", 'String'>
    readonly user_id: FieldRef<"UserCard", 'String'>
    readonly question: FieldRef<"UserCard", 'String'>
    readonly answer: FieldRef<"UserCard", 'String'>
    readonly example: FieldRef<"UserCard", 'String'>
    readonly lesson_id: FieldRef<"UserCard", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserCard findUnique
   */
  export type UserCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter, which UserCard to fetch.
     */
    where: UserCardWhereUniqueInput
  }

  /**
   * UserCard findUniqueOrThrow
   */
  export type UserCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter, which UserCard to fetch.
     */
    where: UserCardWhereUniqueInput
  }

  /**
   * UserCard findFirst
   */
  export type UserCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter, which UserCard to fetch.
     */
    where?: UserCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCards to fetch.
     */
    orderBy?: UserCardOrderByWithRelationInput | UserCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCards.
     */
    cursor?: UserCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCards.
     */
    distinct?: UserCardScalarFieldEnum | UserCardScalarFieldEnum[]
  }

  /**
   * UserCard findFirstOrThrow
   */
  export type UserCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter, which UserCard to fetch.
     */
    where?: UserCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCards to fetch.
     */
    orderBy?: UserCardOrderByWithRelationInput | UserCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCards.
     */
    cursor?: UserCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCards.
     */
    distinct?: UserCardScalarFieldEnum | UserCardScalarFieldEnum[]
  }

  /**
   * UserCard findMany
   */
  export type UserCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter, which UserCards to fetch.
     */
    where?: UserCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCards to fetch.
     */
    orderBy?: UserCardOrderByWithRelationInput | UserCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCards.
     */
    cursor?: UserCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCards.
     */
    skip?: number
    distinct?: UserCardScalarFieldEnum | UserCardScalarFieldEnum[]
  }

  /**
   * UserCard create
   */
  export type UserCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCard.
     */
    data: XOR<UserCardCreateInput, UserCardUncheckedCreateInput>
  }

  /**
   * UserCard createMany
   */
  export type UserCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCards.
     */
    data: UserCardCreateManyInput | UserCardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCard createManyAndReturn
   */
  export type UserCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserCards.
     */
    data: UserCardCreateManyInput | UserCardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCard update
   */
  export type UserCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCard.
     */
    data: XOR<UserCardUpdateInput, UserCardUncheckedUpdateInput>
    /**
     * Choose, which UserCard to update.
     */
    where: UserCardWhereUniqueInput
  }

  /**
   * UserCard updateMany
   */
  export type UserCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCards.
     */
    data: XOR<UserCardUpdateManyMutationInput, UserCardUncheckedUpdateManyInput>
    /**
     * Filter which UserCards to update
     */
    where?: UserCardWhereInput
  }

  /**
   * UserCard upsert
   */
  export type UserCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCard to update in case it exists.
     */
    where: UserCardWhereUniqueInput
    /**
     * In case the UserCard found by the `where` argument doesn't exist, create a new UserCard with this data.
     */
    create: XOR<UserCardCreateInput, UserCardUncheckedCreateInput>
    /**
     * In case the UserCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCardUpdateInput, UserCardUncheckedUpdateInput>
  }

  /**
   * UserCard delete
   */
  export type UserCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
    /**
     * Filter which UserCard to delete.
     */
    where: UserCardWhereUniqueInput
  }

  /**
   * UserCard deleteMany
   */
  export type UserCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCards to delete
     */
    where?: UserCardWhereInput
  }

  /**
   * UserCard.lesson
   */
  export type UserCard$lessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
  }

  /**
   * UserCard without action
   */
  export type UserCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCard
     */
    select?: UserCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCardInclude<ExtArgs> | null
  }


  /**
   * Model Vocabulary
   */

  export type AggregateVocabulary = {
    _count: VocabularyCountAggregateOutputType | null
    _min: VocabularyMinAggregateOutputType | null
    _max: VocabularyMaxAggregateOutputType | null
  }

  export type VocabularyMinAggregateOutputType = {
    vocabulary_id: string | null
    user_id: string | null
  }

  export type VocabularyMaxAggregateOutputType = {
    vocabulary_id: string | null
    user_id: string | null
  }

  export type VocabularyCountAggregateOutputType = {
    vocabulary_id: number
    user_id: number
    _all: number
  }


  export type VocabularyMinAggregateInputType = {
    vocabulary_id?: true
    user_id?: true
  }

  export type VocabularyMaxAggregateInputType = {
    vocabulary_id?: true
    user_id?: true
  }

  export type VocabularyCountAggregateInputType = {
    vocabulary_id?: true
    user_id?: true
    _all?: true
  }

  export type VocabularyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vocabulary to aggregate.
     */
    where?: VocabularyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vocabularies to fetch.
     */
    orderBy?: VocabularyOrderByWithRelationInput | VocabularyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VocabularyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vocabularies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vocabularies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vocabularies
    **/
    _count?: true | VocabularyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VocabularyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VocabularyMaxAggregateInputType
  }

  export type GetVocabularyAggregateType<T extends VocabularyAggregateArgs> = {
        [P in keyof T & keyof AggregateVocabulary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVocabulary[P]>
      : GetScalarType<T[P], AggregateVocabulary[P]>
  }




  export type VocabularyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VocabularyWhereInput
    orderBy?: VocabularyOrderByWithAggregationInput | VocabularyOrderByWithAggregationInput[]
    by: VocabularyScalarFieldEnum[] | VocabularyScalarFieldEnum
    having?: VocabularyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VocabularyCountAggregateInputType | true
    _min?: VocabularyMinAggregateInputType
    _max?: VocabularyMaxAggregateInputType
  }

  export type VocabularyGroupByOutputType = {
    vocabulary_id: string
    user_id: string
    _count: VocabularyCountAggregateOutputType | null
    _min: VocabularyMinAggregateOutputType | null
    _max: VocabularyMaxAggregateOutputType | null
  }

  type GetVocabularyGroupByPayload<T extends VocabularyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VocabularyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VocabularyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VocabularyGroupByOutputType[P]>
            : GetScalarType<T[P], VocabularyGroupByOutputType[P]>
        }
      >
    >


  export type VocabularySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vocabulary_id?: boolean
    user_id?: boolean
  }, ExtArgs["result"]["vocabulary"]>

  export type VocabularySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vocabulary_id?: boolean
    user_id?: boolean
  }, ExtArgs["result"]["vocabulary"]>

  export type VocabularySelectScalar = {
    vocabulary_id?: boolean
    user_id?: boolean
  }


  export type $VocabularyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vocabulary"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      vocabulary_id: string
      user_id: string
    }, ExtArgs["result"]["vocabulary"]>
    composites: {}
  }

  type VocabularyGetPayload<S extends boolean | null | undefined | VocabularyDefaultArgs> = $Result.GetResult<Prisma.$VocabularyPayload, S>

  type VocabularyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VocabularyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VocabularyCountAggregateInputType | true
    }

  export interface VocabularyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vocabulary'], meta: { name: 'Vocabulary' } }
    /**
     * Find zero or one Vocabulary that matches the filter.
     * @param {VocabularyFindUniqueArgs} args - Arguments to find a Vocabulary
     * @example
     * // Get one Vocabulary
     * const vocabulary = await prisma.vocabulary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VocabularyFindUniqueArgs>(args: SelectSubset<T, VocabularyFindUniqueArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Vocabulary that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VocabularyFindUniqueOrThrowArgs} args - Arguments to find a Vocabulary
     * @example
     * // Get one Vocabulary
     * const vocabulary = await prisma.vocabulary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VocabularyFindUniqueOrThrowArgs>(args: SelectSubset<T, VocabularyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Vocabulary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyFindFirstArgs} args - Arguments to find a Vocabulary
     * @example
     * // Get one Vocabulary
     * const vocabulary = await prisma.vocabulary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VocabularyFindFirstArgs>(args?: SelectSubset<T, VocabularyFindFirstArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Vocabulary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyFindFirstOrThrowArgs} args - Arguments to find a Vocabulary
     * @example
     * // Get one Vocabulary
     * const vocabulary = await prisma.vocabulary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VocabularyFindFirstOrThrowArgs>(args?: SelectSubset<T, VocabularyFindFirstOrThrowArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Vocabularies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vocabularies
     * const vocabularies = await prisma.vocabulary.findMany()
     * 
     * // Get first 10 Vocabularies
     * const vocabularies = await prisma.vocabulary.findMany({ take: 10 })
     * 
     * // Only select the `vocabulary_id`
     * const vocabularyWithVocabulary_idOnly = await prisma.vocabulary.findMany({ select: { vocabulary_id: true } })
     * 
     */
    findMany<T extends VocabularyFindManyArgs>(args?: SelectSubset<T, VocabularyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Vocabulary.
     * @param {VocabularyCreateArgs} args - Arguments to create a Vocabulary.
     * @example
     * // Create one Vocabulary
     * const Vocabulary = await prisma.vocabulary.create({
     *   data: {
     *     // ... data to create a Vocabulary
     *   }
     * })
     * 
     */
    create<T extends VocabularyCreateArgs>(args: SelectSubset<T, VocabularyCreateArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Vocabularies.
     * @param {VocabularyCreateManyArgs} args - Arguments to create many Vocabularies.
     * @example
     * // Create many Vocabularies
     * const vocabulary = await prisma.vocabulary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VocabularyCreateManyArgs>(args?: SelectSubset<T, VocabularyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vocabularies and returns the data saved in the database.
     * @param {VocabularyCreateManyAndReturnArgs} args - Arguments to create many Vocabularies.
     * @example
     * // Create many Vocabularies
     * const vocabulary = await prisma.vocabulary.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vocabularies and only return the `vocabulary_id`
     * const vocabularyWithVocabulary_idOnly = await prisma.vocabulary.createManyAndReturn({ 
     *   select: { vocabulary_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VocabularyCreateManyAndReturnArgs>(args?: SelectSubset<T, VocabularyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Vocabulary.
     * @param {VocabularyDeleteArgs} args - Arguments to delete one Vocabulary.
     * @example
     * // Delete one Vocabulary
     * const Vocabulary = await prisma.vocabulary.delete({
     *   where: {
     *     // ... filter to delete one Vocabulary
     *   }
     * })
     * 
     */
    delete<T extends VocabularyDeleteArgs>(args: SelectSubset<T, VocabularyDeleteArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Vocabulary.
     * @param {VocabularyUpdateArgs} args - Arguments to update one Vocabulary.
     * @example
     * // Update one Vocabulary
     * const vocabulary = await prisma.vocabulary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VocabularyUpdateArgs>(args: SelectSubset<T, VocabularyUpdateArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Vocabularies.
     * @param {VocabularyDeleteManyArgs} args - Arguments to filter Vocabularies to delete.
     * @example
     * // Delete a few Vocabularies
     * const { count } = await prisma.vocabulary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VocabularyDeleteManyArgs>(args?: SelectSubset<T, VocabularyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vocabularies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vocabularies
     * const vocabulary = await prisma.vocabulary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VocabularyUpdateManyArgs>(args: SelectSubset<T, VocabularyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vocabulary.
     * @param {VocabularyUpsertArgs} args - Arguments to update or create a Vocabulary.
     * @example
     * // Update or create a Vocabulary
     * const vocabulary = await prisma.vocabulary.upsert({
     *   create: {
     *     // ... data to create a Vocabulary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vocabulary we want to update
     *   }
     * })
     */
    upsert<T extends VocabularyUpsertArgs>(args: SelectSubset<T, VocabularyUpsertArgs<ExtArgs>>): Prisma__VocabularyClient<$Result.GetResult<Prisma.$VocabularyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Vocabularies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyCountArgs} args - Arguments to filter Vocabularies to count.
     * @example
     * // Count the number of Vocabularies
     * const count = await prisma.vocabulary.count({
     *   where: {
     *     // ... the filter for the Vocabularies we want to count
     *   }
     * })
    **/
    count<T extends VocabularyCountArgs>(
      args?: Subset<T, VocabularyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VocabularyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vocabulary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VocabularyAggregateArgs>(args: Subset<T, VocabularyAggregateArgs>): Prisma.PrismaPromise<GetVocabularyAggregateType<T>>

    /**
     * Group by Vocabulary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VocabularyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VocabularyGroupByArgs['orderBy'] }
        : { orderBy?: VocabularyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VocabularyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVocabularyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vocabulary model
   */
  readonly fields: VocabularyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vocabulary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VocabularyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vocabulary model
   */ 
  interface VocabularyFieldRefs {
    readonly vocabulary_id: FieldRef<"Vocabulary", 'String'>
    readonly user_id: FieldRef<"Vocabulary", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vocabulary findUnique
   */
  export type VocabularyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * Filter, which Vocabulary to fetch.
     */
    where: VocabularyWhereUniqueInput
  }

  /**
   * Vocabulary findUniqueOrThrow
   */
  export type VocabularyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * Filter, which Vocabulary to fetch.
     */
    where: VocabularyWhereUniqueInput
  }

  /**
   * Vocabulary findFirst
   */
  export type VocabularyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * Filter, which Vocabulary to fetch.
     */
    where?: VocabularyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vocabularies to fetch.
     */
    orderBy?: VocabularyOrderByWithRelationInput | VocabularyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vocabularies.
     */
    cursor?: VocabularyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vocabularies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vocabularies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vocabularies.
     */
    distinct?: VocabularyScalarFieldEnum | VocabularyScalarFieldEnum[]
  }

  /**
   * Vocabulary findFirstOrThrow
   */
  export type VocabularyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * Filter, which Vocabulary to fetch.
     */
    where?: VocabularyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vocabularies to fetch.
     */
    orderBy?: VocabularyOrderByWithRelationInput | VocabularyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vocabularies.
     */
    cursor?: VocabularyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vocabularies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vocabularies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vocabularies.
     */
    distinct?: VocabularyScalarFieldEnum | VocabularyScalarFieldEnum[]
  }

  /**
   * Vocabulary findMany
   */
  export type VocabularyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * Filter, which Vocabularies to fetch.
     */
    where?: VocabularyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vocabularies to fetch.
     */
    orderBy?: VocabularyOrderByWithRelationInput | VocabularyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vocabularies.
     */
    cursor?: VocabularyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vocabularies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vocabularies.
     */
    skip?: number
    distinct?: VocabularyScalarFieldEnum | VocabularyScalarFieldEnum[]
  }

  /**
   * Vocabulary create
   */
  export type VocabularyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * The data needed to create a Vocabulary.
     */
    data: XOR<VocabularyCreateInput, VocabularyUncheckedCreateInput>
  }

  /**
   * Vocabulary createMany
   */
  export type VocabularyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vocabularies.
     */
    data: VocabularyCreateManyInput | VocabularyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vocabulary createManyAndReturn
   */
  export type VocabularyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Vocabularies.
     */
    data: VocabularyCreateManyInput | VocabularyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vocabulary update
   */
  export type VocabularyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * The data needed to update a Vocabulary.
     */
    data: XOR<VocabularyUpdateInput, VocabularyUncheckedUpdateInput>
    /**
     * Choose, which Vocabulary to update.
     */
    where: VocabularyWhereUniqueInput
  }

  /**
   * Vocabulary updateMany
   */
  export type VocabularyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vocabularies.
     */
    data: XOR<VocabularyUpdateManyMutationInput, VocabularyUncheckedUpdateManyInput>
    /**
     * Filter which Vocabularies to update
     */
    where?: VocabularyWhereInput
  }

  /**
   * Vocabulary upsert
   */
  export type VocabularyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * The filter to search for the Vocabulary to update in case it exists.
     */
    where: VocabularyWhereUniqueInput
    /**
     * In case the Vocabulary found by the `where` argument doesn't exist, create a new Vocabulary with this data.
     */
    create: XOR<VocabularyCreateInput, VocabularyUncheckedCreateInput>
    /**
     * In case the Vocabulary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VocabularyUpdateInput, VocabularyUncheckedUpdateInput>
  }

  /**
   * Vocabulary delete
   */
  export type VocabularyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
    /**
     * Filter which Vocabulary to delete.
     */
    where: VocabularyWhereUniqueInput
  }

  /**
   * Vocabulary deleteMany
   */
  export type VocabularyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vocabularies to delete
     */
    where?: VocabularyWhereInput
  }

  /**
   * Vocabulary without action
   */
  export type VocabularyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vocabulary
     */
    select?: VocabularySelect<ExtArgs> | null
  }


  /**
   * Model VocabularyInbox
   */

  export type AggregateVocabularyInbox = {
    _count: VocabularyInboxCountAggregateOutputType | null
    _min: VocabularyInboxMinAggregateOutputType | null
    _max: VocabularyInboxMaxAggregateOutputType | null
  }

  export type VocabularyInboxMinAggregateOutputType = {
    user_id: string | null
    question: string | null
    answer: string | null
  }

  export type VocabularyInboxMaxAggregateOutputType = {
    user_id: string | null
    question: string | null
    answer: string | null
  }

  export type VocabularyInboxCountAggregateOutputType = {
    user_id: number
    question: number
    answer: number
    _all: number
  }


  export type VocabularyInboxMinAggregateInputType = {
    user_id?: true
    question?: true
    answer?: true
  }

  export type VocabularyInboxMaxAggregateInputType = {
    user_id?: true
    question?: true
    answer?: true
  }

  export type VocabularyInboxCountAggregateInputType = {
    user_id?: true
    question?: true
    answer?: true
    _all?: true
  }

  export type VocabularyInboxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VocabularyInbox to aggregate.
     */
    where?: VocabularyInboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VocabularyInboxes to fetch.
     */
    orderBy?: VocabularyInboxOrderByWithRelationInput | VocabularyInboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VocabularyInboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VocabularyInboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VocabularyInboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VocabularyInboxes
    **/
    _count?: true | VocabularyInboxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VocabularyInboxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VocabularyInboxMaxAggregateInputType
  }

  export type GetVocabularyInboxAggregateType<T extends VocabularyInboxAggregateArgs> = {
        [P in keyof T & keyof AggregateVocabularyInbox]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVocabularyInbox[P]>
      : GetScalarType<T[P], AggregateVocabularyInbox[P]>
  }




  export type VocabularyInboxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VocabularyInboxWhereInput
    orderBy?: VocabularyInboxOrderByWithAggregationInput | VocabularyInboxOrderByWithAggregationInput[]
    by: VocabularyInboxScalarFieldEnum[] | VocabularyInboxScalarFieldEnum
    having?: VocabularyInboxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VocabularyInboxCountAggregateInputType | true
    _min?: VocabularyInboxMinAggregateInputType
    _max?: VocabularyInboxMaxAggregateInputType
  }

  export type VocabularyInboxGroupByOutputType = {
    user_id: string
    question: string
    answer: string
    _count: VocabularyInboxCountAggregateOutputType | null
    _min: VocabularyInboxMinAggregateOutputType | null
    _max: VocabularyInboxMaxAggregateOutputType | null
  }

  type GetVocabularyInboxGroupByPayload<T extends VocabularyInboxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VocabularyInboxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VocabularyInboxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VocabularyInboxGroupByOutputType[P]>
            : GetScalarType<T[P], VocabularyInboxGroupByOutputType[P]>
        }
      >
    >


  export type VocabularyInboxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    question?: boolean
    answer?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vocabularyInbox"]>

  export type VocabularyInboxSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    question?: boolean
    answer?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vocabularyInbox"]>

  export type VocabularyInboxSelectScalar = {
    user_id?: boolean
    question?: boolean
    answer?: boolean
  }

  export type VocabularyInboxInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VocabularyInboxIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VocabularyInboxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VocabularyInbox"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      question: string
      answer: string
    }, ExtArgs["result"]["vocabularyInbox"]>
    composites: {}
  }

  type VocabularyInboxGetPayload<S extends boolean | null | undefined | VocabularyInboxDefaultArgs> = $Result.GetResult<Prisma.$VocabularyInboxPayload, S>

  type VocabularyInboxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VocabularyInboxFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VocabularyInboxCountAggregateInputType | true
    }

  export interface VocabularyInboxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VocabularyInbox'], meta: { name: 'VocabularyInbox' } }
    /**
     * Find zero or one VocabularyInbox that matches the filter.
     * @param {VocabularyInboxFindUniqueArgs} args - Arguments to find a VocabularyInbox
     * @example
     * // Get one VocabularyInbox
     * const vocabularyInbox = await prisma.vocabularyInbox.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VocabularyInboxFindUniqueArgs>(args: SelectSubset<T, VocabularyInboxFindUniqueArgs<ExtArgs>>): Prisma__VocabularyInboxClient<$Result.GetResult<Prisma.$VocabularyInboxPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VocabularyInbox that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VocabularyInboxFindUniqueOrThrowArgs} args - Arguments to find a VocabularyInbox
     * @example
     * // Get one VocabularyInbox
     * const vocabularyInbox = await prisma.vocabularyInbox.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VocabularyInboxFindUniqueOrThrowArgs>(args: SelectSubset<T, VocabularyInboxFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VocabularyInboxClient<$Result.GetResult<Prisma.$VocabularyInboxPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VocabularyInbox that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyInboxFindFirstArgs} args - Arguments to find a VocabularyInbox
     * @example
     * // Get one VocabularyInbox
     * const vocabularyInbox = await prisma.vocabularyInbox.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VocabularyInboxFindFirstArgs>(args?: SelectSubset<T, VocabularyInboxFindFirstArgs<ExtArgs>>): Prisma__VocabularyInboxClient<$Result.GetResult<Prisma.$VocabularyInboxPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VocabularyInbox that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyInboxFindFirstOrThrowArgs} args - Arguments to find a VocabularyInbox
     * @example
     * // Get one VocabularyInbox
     * const vocabularyInbox = await prisma.vocabularyInbox.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VocabularyInboxFindFirstOrThrowArgs>(args?: SelectSubset<T, VocabularyInboxFindFirstOrThrowArgs<ExtArgs>>): Prisma__VocabularyInboxClient<$Result.GetResult<Prisma.$VocabularyInboxPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VocabularyInboxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyInboxFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VocabularyInboxes
     * const vocabularyInboxes = await prisma.vocabularyInbox.findMany()
     * 
     * // Get first 10 VocabularyInboxes
     * const vocabularyInboxes = await prisma.vocabularyInbox.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const vocabularyInboxWithUser_idOnly = await prisma.vocabularyInbox.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends VocabularyInboxFindManyArgs>(args?: SelectSubset<T, VocabularyInboxFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VocabularyInboxPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VocabularyInbox.
     * @param {VocabularyInboxCreateArgs} args - Arguments to create a VocabularyInbox.
     * @example
     * // Create one VocabularyInbox
     * const VocabularyInbox = await prisma.vocabularyInbox.create({
     *   data: {
     *     // ... data to create a VocabularyInbox
     *   }
     * })
     * 
     */
    create<T extends VocabularyInboxCreateArgs>(args: SelectSubset<T, VocabularyInboxCreateArgs<ExtArgs>>): Prisma__VocabularyInboxClient<$Result.GetResult<Prisma.$VocabularyInboxPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VocabularyInboxes.
     * @param {VocabularyInboxCreateManyArgs} args - Arguments to create many VocabularyInboxes.
     * @example
     * // Create many VocabularyInboxes
     * const vocabularyInbox = await prisma.vocabularyInbox.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VocabularyInboxCreateManyArgs>(args?: SelectSubset<T, VocabularyInboxCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VocabularyInboxes and returns the data saved in the database.
     * @param {VocabularyInboxCreateManyAndReturnArgs} args - Arguments to create many VocabularyInboxes.
     * @example
     * // Create many VocabularyInboxes
     * const vocabularyInbox = await prisma.vocabularyInbox.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VocabularyInboxes and only return the `user_id`
     * const vocabularyInboxWithUser_idOnly = await prisma.vocabularyInbox.createManyAndReturn({ 
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VocabularyInboxCreateManyAndReturnArgs>(args?: SelectSubset<T, VocabularyInboxCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VocabularyInboxPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VocabularyInbox.
     * @param {VocabularyInboxDeleteArgs} args - Arguments to delete one VocabularyInbox.
     * @example
     * // Delete one VocabularyInbox
     * const VocabularyInbox = await prisma.vocabularyInbox.delete({
     *   where: {
     *     // ... filter to delete one VocabularyInbox
     *   }
     * })
     * 
     */
    delete<T extends VocabularyInboxDeleteArgs>(args: SelectSubset<T, VocabularyInboxDeleteArgs<ExtArgs>>): Prisma__VocabularyInboxClient<$Result.GetResult<Prisma.$VocabularyInboxPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VocabularyInbox.
     * @param {VocabularyInboxUpdateArgs} args - Arguments to update one VocabularyInbox.
     * @example
     * // Update one VocabularyInbox
     * const vocabularyInbox = await prisma.vocabularyInbox.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VocabularyInboxUpdateArgs>(args: SelectSubset<T, VocabularyInboxUpdateArgs<ExtArgs>>): Prisma__VocabularyInboxClient<$Result.GetResult<Prisma.$VocabularyInboxPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VocabularyInboxes.
     * @param {VocabularyInboxDeleteManyArgs} args - Arguments to filter VocabularyInboxes to delete.
     * @example
     * // Delete a few VocabularyInboxes
     * const { count } = await prisma.vocabularyInbox.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VocabularyInboxDeleteManyArgs>(args?: SelectSubset<T, VocabularyInboxDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VocabularyInboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyInboxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VocabularyInboxes
     * const vocabularyInbox = await prisma.vocabularyInbox.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VocabularyInboxUpdateManyArgs>(args: SelectSubset<T, VocabularyInboxUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VocabularyInbox.
     * @param {VocabularyInboxUpsertArgs} args - Arguments to update or create a VocabularyInbox.
     * @example
     * // Update or create a VocabularyInbox
     * const vocabularyInbox = await prisma.vocabularyInbox.upsert({
     *   create: {
     *     // ... data to create a VocabularyInbox
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VocabularyInbox we want to update
     *   }
     * })
     */
    upsert<T extends VocabularyInboxUpsertArgs>(args: SelectSubset<T, VocabularyInboxUpsertArgs<ExtArgs>>): Prisma__VocabularyInboxClient<$Result.GetResult<Prisma.$VocabularyInboxPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VocabularyInboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyInboxCountArgs} args - Arguments to filter VocabularyInboxes to count.
     * @example
     * // Count the number of VocabularyInboxes
     * const count = await prisma.vocabularyInbox.count({
     *   where: {
     *     // ... the filter for the VocabularyInboxes we want to count
     *   }
     * })
    **/
    count<T extends VocabularyInboxCountArgs>(
      args?: Subset<T, VocabularyInboxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VocabularyInboxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VocabularyInbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyInboxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VocabularyInboxAggregateArgs>(args: Subset<T, VocabularyInboxAggregateArgs>): Prisma.PrismaPromise<GetVocabularyInboxAggregateType<T>>

    /**
     * Group by VocabularyInbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VocabularyInboxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VocabularyInboxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VocabularyInboxGroupByArgs['orderBy'] }
        : { orderBy?: VocabularyInboxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VocabularyInboxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVocabularyInboxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VocabularyInbox model
   */
  readonly fields: VocabularyInboxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VocabularyInbox.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VocabularyInboxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VocabularyInbox model
   */ 
  interface VocabularyInboxFieldRefs {
    readonly user_id: FieldRef<"VocabularyInbox", 'String'>
    readonly question: FieldRef<"VocabularyInbox", 'String'>
    readonly answer: FieldRef<"VocabularyInbox", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VocabularyInbox findUnique
   */
  export type VocabularyInboxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyInbox
     */
    select?: VocabularyInboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInboxInclude<ExtArgs> | null
    /**
     * Filter, which VocabularyInbox to fetch.
     */
    where: VocabularyInboxWhereUniqueInput
  }

  /**
   * VocabularyInbox findUniqueOrThrow
   */
  export type VocabularyInboxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyInbox
     */
    select?: VocabularyInboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInboxInclude<ExtArgs> | null
    /**
     * Filter, which VocabularyInbox to fetch.
     */
    where: VocabularyInboxWhereUniqueInput
  }

  /**
   * VocabularyInbox findFirst
   */
  export type VocabularyInboxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyInbox
     */
    select?: VocabularyInboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInboxInclude<ExtArgs> | null
    /**
     * Filter, which VocabularyInbox to fetch.
     */
    where?: VocabularyInboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VocabularyInboxes to fetch.
     */
    orderBy?: VocabularyInboxOrderByWithRelationInput | VocabularyInboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VocabularyInboxes.
     */
    cursor?: VocabularyInboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VocabularyInboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VocabularyInboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VocabularyInboxes.
     */
    distinct?: VocabularyInboxScalarFieldEnum | VocabularyInboxScalarFieldEnum[]
  }

  /**
   * VocabularyInbox findFirstOrThrow
   */
  export type VocabularyInboxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyInbox
     */
    select?: VocabularyInboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInboxInclude<ExtArgs> | null
    /**
     * Filter, which VocabularyInbox to fetch.
     */
    where?: VocabularyInboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VocabularyInboxes to fetch.
     */
    orderBy?: VocabularyInboxOrderByWithRelationInput | VocabularyInboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VocabularyInboxes.
     */
    cursor?: VocabularyInboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VocabularyInboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VocabularyInboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VocabularyInboxes.
     */
    distinct?: VocabularyInboxScalarFieldEnum | VocabularyInboxScalarFieldEnum[]
  }

  /**
   * VocabularyInbox findMany
   */
  export type VocabularyInboxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyInbox
     */
    select?: VocabularyInboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInboxInclude<ExtArgs> | null
    /**
     * Filter, which VocabularyInboxes to fetch.
     */
    where?: VocabularyInboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VocabularyInboxes to fetch.
     */
    orderBy?: VocabularyInboxOrderByWithRelationInput | VocabularyInboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VocabularyInboxes.
     */
    cursor?: VocabularyInboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VocabularyInboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VocabularyInboxes.
     */
    skip?: number
    distinct?: VocabularyInboxScalarFieldEnum | VocabularyInboxScalarFieldEnum[]
  }

  /**
   * VocabularyInbox create
   */
  export type VocabularyInboxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyInbox
     */
    select?: VocabularyInboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInboxInclude<ExtArgs> | null
    /**
     * The data needed to create a VocabularyInbox.
     */
    data: XOR<VocabularyInboxCreateInput, VocabularyInboxUncheckedCreateInput>
  }

  /**
   * VocabularyInbox createMany
   */
  export type VocabularyInboxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VocabularyInboxes.
     */
    data: VocabularyInboxCreateManyInput | VocabularyInboxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VocabularyInbox createManyAndReturn
   */
  export type VocabularyInboxCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyInbox
     */
    select?: VocabularyInboxSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VocabularyInboxes.
     */
    data: VocabularyInboxCreateManyInput | VocabularyInboxCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInboxIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VocabularyInbox update
   */
  export type VocabularyInboxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyInbox
     */
    select?: VocabularyInboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInboxInclude<ExtArgs> | null
    /**
     * The data needed to update a VocabularyInbox.
     */
    data: XOR<VocabularyInboxUpdateInput, VocabularyInboxUncheckedUpdateInput>
    /**
     * Choose, which VocabularyInbox to update.
     */
    where: VocabularyInboxWhereUniqueInput
  }

  /**
   * VocabularyInbox updateMany
   */
  export type VocabularyInboxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VocabularyInboxes.
     */
    data: XOR<VocabularyInboxUpdateManyMutationInput, VocabularyInboxUncheckedUpdateManyInput>
    /**
     * Filter which VocabularyInboxes to update
     */
    where?: VocabularyInboxWhereInput
  }

  /**
   * VocabularyInbox upsert
   */
  export type VocabularyInboxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyInbox
     */
    select?: VocabularyInboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInboxInclude<ExtArgs> | null
    /**
     * The filter to search for the VocabularyInbox to update in case it exists.
     */
    where: VocabularyInboxWhereUniqueInput
    /**
     * In case the VocabularyInbox found by the `where` argument doesn't exist, create a new VocabularyInbox with this data.
     */
    create: XOR<VocabularyInboxCreateInput, VocabularyInboxUncheckedCreateInput>
    /**
     * In case the VocabularyInbox was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VocabularyInboxUpdateInput, VocabularyInboxUncheckedUpdateInput>
  }

  /**
   * VocabularyInbox delete
   */
  export type VocabularyInboxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyInbox
     */
    select?: VocabularyInboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInboxInclude<ExtArgs> | null
    /**
     * Filter which VocabularyInbox to delete.
     */
    where: VocabularyInboxWhereUniqueInput
  }

  /**
   * VocabularyInbox deleteMany
   */
  export type VocabularyInboxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VocabularyInboxes to delete
     */
    where?: VocabularyInboxWhereInput
  }

  /**
   * VocabularyInbox without action
   */
  export type VocabularyInboxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VocabularyInbox
     */
    select?: VocabularyInboxSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VocabularyInboxInclude<ExtArgs> | null
  }


  /**
   * Model BookingRequest
   */

  export type AggregateBookingRequest = {
    _count: BookingRequestCountAggregateOutputType | null
    _min: BookingRequestMinAggregateOutputType | null
    _max: BookingRequestMaxAggregateOutputType | null
  }

  export type BookingRequestMinAggregateOutputType = {
    booking_request_id: string | null
    class_id: string | null
    booking_date: Date | null
    booking_request_status: $Enums.BookingRequestStatus | null
    user_stated_name: string | null
    user_stated_phone: string | null
    user_stated_email: string | null
    user_stated_telegram_nickname: string | null
  }

  export type BookingRequestMaxAggregateOutputType = {
    booking_request_id: string | null
    class_id: string | null
    booking_date: Date | null
    booking_request_status: $Enums.BookingRequestStatus | null
    user_stated_name: string | null
    user_stated_phone: string | null
    user_stated_email: string | null
    user_stated_telegram_nickname: string | null
  }

  export type BookingRequestCountAggregateOutputType = {
    booking_request_id: number
    class_id: number
    booking_date: number
    booking_request_status: number
    user_stated_name: number
    user_stated_phone: number
    user_stated_email: number
    user_stated_telegram_nickname: number
    _all: number
  }


  export type BookingRequestMinAggregateInputType = {
    booking_request_id?: true
    class_id?: true
    booking_date?: true
    booking_request_status?: true
    user_stated_name?: true
    user_stated_phone?: true
    user_stated_email?: true
    user_stated_telegram_nickname?: true
  }

  export type BookingRequestMaxAggregateInputType = {
    booking_request_id?: true
    class_id?: true
    booking_date?: true
    booking_request_status?: true
    user_stated_name?: true
    user_stated_phone?: true
    user_stated_email?: true
    user_stated_telegram_nickname?: true
  }

  export type BookingRequestCountAggregateInputType = {
    booking_request_id?: true
    class_id?: true
    booking_date?: true
    booking_request_status?: true
    user_stated_name?: true
    user_stated_phone?: true
    user_stated_email?: true
    user_stated_telegram_nickname?: true
    _all?: true
  }

  export type BookingRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingRequest to aggregate.
     */
    where?: BookingRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRequests to fetch.
     */
    orderBy?: BookingRequestOrderByWithRelationInput | BookingRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingRequests
    **/
    _count?: true | BookingRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingRequestMaxAggregateInputType
  }

  export type GetBookingRequestAggregateType<T extends BookingRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingRequest[P]>
      : GetScalarType<T[P], AggregateBookingRequest[P]>
  }




  export type BookingRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingRequestWhereInput
    orderBy?: BookingRequestOrderByWithAggregationInput | BookingRequestOrderByWithAggregationInput[]
    by: BookingRequestScalarFieldEnum[] | BookingRequestScalarFieldEnum
    having?: BookingRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingRequestCountAggregateInputType | true
    _min?: BookingRequestMinAggregateInputType
    _max?: BookingRequestMaxAggregateInputType
  }

  export type BookingRequestGroupByOutputType = {
    booking_request_id: string
    class_id: string
    booking_date: Date
    booking_request_status: $Enums.BookingRequestStatus
    user_stated_name: string | null
    user_stated_phone: string | null
    user_stated_email: string | null
    user_stated_telegram_nickname: string | null
    _count: BookingRequestCountAggregateOutputType | null
    _min: BookingRequestMinAggregateOutputType | null
    _max: BookingRequestMaxAggregateOutputType | null
  }

  type GetBookingRequestGroupByPayload<T extends BookingRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingRequestGroupByOutputType[P]>
            : GetScalarType<T[P], BookingRequestGroupByOutputType[P]>
        }
      >
    >


  export type BookingRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    booking_request_id?: boolean
    class_id?: boolean
    booking_date?: boolean
    booking_request_status?: boolean
    user_stated_name?: boolean
    user_stated_phone?: boolean
    user_stated_email?: boolean
    user_stated_telegram_nickname?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingRequest"]>

  export type BookingRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    booking_request_id?: boolean
    class_id?: boolean
    booking_date?: boolean
    booking_request_status?: boolean
    user_stated_name?: boolean
    user_stated_phone?: boolean
    user_stated_email?: boolean
    user_stated_telegram_nickname?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingRequest"]>

  export type BookingRequestSelectScalar = {
    booking_request_id?: boolean
    class_id?: boolean
    booking_date?: boolean
    booking_request_status?: boolean
    user_stated_name?: boolean
    user_stated_phone?: boolean
    user_stated_email?: boolean
    user_stated_telegram_nickname?: boolean
  }

  export type BookingRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type BookingRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $BookingRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingRequest"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      booking_request_id: string
      class_id: string
      booking_date: Date
      booking_request_status: $Enums.BookingRequestStatus
      user_stated_name: string | null
      user_stated_phone: string | null
      user_stated_email: string | null
      user_stated_telegram_nickname: string | null
    }, ExtArgs["result"]["bookingRequest"]>
    composites: {}
  }

  type BookingRequestGetPayload<S extends boolean | null | undefined | BookingRequestDefaultArgs> = $Result.GetResult<Prisma.$BookingRequestPayload, S>

  type BookingRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingRequestCountAggregateInputType | true
    }

  export interface BookingRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingRequest'], meta: { name: 'BookingRequest' } }
    /**
     * Find zero or one BookingRequest that matches the filter.
     * @param {BookingRequestFindUniqueArgs} args - Arguments to find a BookingRequest
     * @example
     * // Get one BookingRequest
     * const bookingRequest = await prisma.bookingRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingRequestFindUniqueArgs>(args: SelectSubset<T, BookingRequestFindUniqueArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BookingRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingRequestFindUniqueOrThrowArgs} args - Arguments to find a BookingRequest
     * @example
     * // Get one BookingRequest
     * const bookingRequest = await prisma.bookingRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BookingRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequestFindFirstArgs} args - Arguments to find a BookingRequest
     * @example
     * // Get one BookingRequest
     * const bookingRequest = await prisma.bookingRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingRequestFindFirstArgs>(args?: SelectSubset<T, BookingRequestFindFirstArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BookingRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequestFindFirstOrThrowArgs} args - Arguments to find a BookingRequest
     * @example
     * // Get one BookingRequest
     * const bookingRequest = await prisma.bookingRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BookingRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingRequests
     * const bookingRequests = await prisma.bookingRequest.findMany()
     * 
     * // Get first 10 BookingRequests
     * const bookingRequests = await prisma.bookingRequest.findMany({ take: 10 })
     * 
     * // Only select the `booking_request_id`
     * const bookingRequestWithBooking_request_idOnly = await prisma.bookingRequest.findMany({ select: { booking_request_id: true } })
     * 
     */
    findMany<T extends BookingRequestFindManyArgs>(args?: SelectSubset<T, BookingRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BookingRequest.
     * @param {BookingRequestCreateArgs} args - Arguments to create a BookingRequest.
     * @example
     * // Create one BookingRequest
     * const BookingRequest = await prisma.bookingRequest.create({
     *   data: {
     *     // ... data to create a BookingRequest
     *   }
     * })
     * 
     */
    create<T extends BookingRequestCreateArgs>(args: SelectSubset<T, BookingRequestCreateArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BookingRequests.
     * @param {BookingRequestCreateManyArgs} args - Arguments to create many BookingRequests.
     * @example
     * // Create many BookingRequests
     * const bookingRequest = await prisma.bookingRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingRequestCreateManyArgs>(args?: SelectSubset<T, BookingRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingRequests and returns the data saved in the database.
     * @param {BookingRequestCreateManyAndReturnArgs} args - Arguments to create many BookingRequests.
     * @example
     * // Create many BookingRequests
     * const bookingRequest = await prisma.bookingRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingRequests and only return the `booking_request_id`
     * const bookingRequestWithBooking_request_idOnly = await prisma.bookingRequest.createManyAndReturn({ 
     *   select: { booking_request_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BookingRequest.
     * @param {BookingRequestDeleteArgs} args - Arguments to delete one BookingRequest.
     * @example
     * // Delete one BookingRequest
     * const BookingRequest = await prisma.bookingRequest.delete({
     *   where: {
     *     // ... filter to delete one BookingRequest
     *   }
     * })
     * 
     */
    delete<T extends BookingRequestDeleteArgs>(args: SelectSubset<T, BookingRequestDeleteArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BookingRequest.
     * @param {BookingRequestUpdateArgs} args - Arguments to update one BookingRequest.
     * @example
     * // Update one BookingRequest
     * const bookingRequest = await prisma.bookingRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingRequestUpdateArgs>(args: SelectSubset<T, BookingRequestUpdateArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BookingRequests.
     * @param {BookingRequestDeleteManyArgs} args - Arguments to filter BookingRequests to delete.
     * @example
     * // Delete a few BookingRequests
     * const { count } = await prisma.bookingRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingRequestDeleteManyArgs>(args?: SelectSubset<T, BookingRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingRequests
     * const bookingRequest = await prisma.bookingRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingRequestUpdateManyArgs>(args: SelectSubset<T, BookingRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BookingRequest.
     * @param {BookingRequestUpsertArgs} args - Arguments to update or create a BookingRequest.
     * @example
     * // Update or create a BookingRequest
     * const bookingRequest = await prisma.bookingRequest.upsert({
     *   create: {
     *     // ... data to create a BookingRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingRequest we want to update
     *   }
     * })
     */
    upsert<T extends BookingRequestUpsertArgs>(args: SelectSubset<T, BookingRequestUpsertArgs<ExtArgs>>): Prisma__BookingRequestClient<$Result.GetResult<Prisma.$BookingRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BookingRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequestCountArgs} args - Arguments to filter BookingRequests to count.
     * @example
     * // Count the number of BookingRequests
     * const count = await prisma.bookingRequest.count({
     *   where: {
     *     // ... the filter for the BookingRequests we want to count
     *   }
     * })
    **/
    count<T extends BookingRequestCountArgs>(
      args?: Subset<T, BookingRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingRequestAggregateArgs>(args: Subset<T, BookingRequestAggregateArgs>): Prisma.PrismaPromise<GetBookingRequestAggregateType<T>>

    /**
     * Group by BookingRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingRequestGroupByArgs['orderBy'] }
        : { orderBy?: BookingRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingRequest model
   */
  readonly fields: BookingRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingRequest model
   */ 
  interface BookingRequestFieldRefs {
    readonly booking_request_id: FieldRef<"BookingRequest", 'String'>
    readonly class_id: FieldRef<"BookingRequest", 'String'>
    readonly booking_date: FieldRef<"BookingRequest", 'DateTime'>
    readonly booking_request_status: FieldRef<"BookingRequest", 'BookingRequestStatus'>
    readonly user_stated_name: FieldRef<"BookingRequest", 'String'>
    readonly user_stated_phone: FieldRef<"BookingRequest", 'String'>
    readonly user_stated_email: FieldRef<"BookingRequest", 'String'>
    readonly user_stated_telegram_nickname: FieldRef<"BookingRequest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BookingRequest findUnique
   */
  export type BookingRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * Filter, which BookingRequest to fetch.
     */
    where: BookingRequestWhereUniqueInput
  }

  /**
   * BookingRequest findUniqueOrThrow
   */
  export type BookingRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * Filter, which BookingRequest to fetch.
     */
    where: BookingRequestWhereUniqueInput
  }

  /**
   * BookingRequest findFirst
   */
  export type BookingRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * Filter, which BookingRequest to fetch.
     */
    where?: BookingRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRequests to fetch.
     */
    orderBy?: BookingRequestOrderByWithRelationInput | BookingRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingRequests.
     */
    cursor?: BookingRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingRequests.
     */
    distinct?: BookingRequestScalarFieldEnum | BookingRequestScalarFieldEnum[]
  }

  /**
   * BookingRequest findFirstOrThrow
   */
  export type BookingRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * Filter, which BookingRequest to fetch.
     */
    where?: BookingRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRequests to fetch.
     */
    orderBy?: BookingRequestOrderByWithRelationInput | BookingRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingRequests.
     */
    cursor?: BookingRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingRequests.
     */
    distinct?: BookingRequestScalarFieldEnum | BookingRequestScalarFieldEnum[]
  }

  /**
   * BookingRequest findMany
   */
  export type BookingRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * Filter, which BookingRequests to fetch.
     */
    where?: BookingRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRequests to fetch.
     */
    orderBy?: BookingRequestOrderByWithRelationInput | BookingRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingRequests.
     */
    cursor?: BookingRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRequests.
     */
    skip?: number
    distinct?: BookingRequestScalarFieldEnum | BookingRequestScalarFieldEnum[]
  }

  /**
   * BookingRequest create
   */
  export type BookingRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingRequest.
     */
    data: XOR<BookingRequestCreateInput, BookingRequestUncheckedCreateInput>
  }

  /**
   * BookingRequest createMany
   */
  export type BookingRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingRequests.
     */
    data: BookingRequestCreateManyInput | BookingRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingRequest createManyAndReturn
   */
  export type BookingRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BookingRequests.
     */
    data: BookingRequestCreateManyInput | BookingRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingRequest update
   */
  export type BookingRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingRequest.
     */
    data: XOR<BookingRequestUpdateInput, BookingRequestUncheckedUpdateInput>
    /**
     * Choose, which BookingRequest to update.
     */
    where: BookingRequestWhereUniqueInput
  }

  /**
   * BookingRequest updateMany
   */
  export type BookingRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingRequests.
     */
    data: XOR<BookingRequestUpdateManyMutationInput, BookingRequestUncheckedUpdateManyInput>
    /**
     * Filter which BookingRequests to update
     */
    where?: BookingRequestWhereInput
  }

  /**
   * BookingRequest upsert
   */
  export type BookingRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingRequest to update in case it exists.
     */
    where: BookingRequestWhereUniqueInput
    /**
     * In case the BookingRequest found by the `where` argument doesn't exist, create a new BookingRequest with this data.
     */
    create: XOR<BookingRequestCreateInput, BookingRequestUncheckedCreateInput>
    /**
     * In case the BookingRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingRequestUpdateInput, BookingRequestUncheckedUpdateInput>
  }

  /**
   * BookingRequest delete
   */
  export type BookingRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
    /**
     * Filter which BookingRequest to delete.
     */
    where: BookingRequestWhereUniqueInput
  }

  /**
   * BookingRequest deleteMany
   */
  export type BookingRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingRequests to delete
     */
    where?: BookingRequestWhereInput
  }

  /**
   * BookingRequest without action
   */
  export type BookingRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequest
     */
    select?: BookingRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequestInclude<ExtArgs> | null
  }


  /**
   * Model ClassTask
   */

  export type AggregateClassTask = {
    _count: ClassTaskCountAggregateOutputType | null
    _avg: ClassTaskAvgAggregateOutputType | null
    _sum: ClassTaskSumAggregateOutputType | null
    _min: ClassTaskMinAggregateOutputType | null
    _max: ClassTaskMaxAggregateOutputType | null
  }

  export type ClassTaskAvgAggregateOutputType = {
    class_task_id: number | null
  }

  export type ClassTaskSumAggregateOutputType = {
    class_task_id: number | null
  }

  export type ClassTaskMinAggregateOutputType = {
    class_task_id: number | null
    course_task_id: string | null
    class_id: string | null
  }

  export type ClassTaskMaxAggregateOutputType = {
    class_task_id: number | null
    course_task_id: string | null
    class_id: string | null
  }

  export type ClassTaskCountAggregateOutputType = {
    class_task_id: number
    course_task_id: number
    class_id: number
    _all: number
  }


  export type ClassTaskAvgAggregateInputType = {
    class_task_id?: true
  }

  export type ClassTaskSumAggregateInputType = {
    class_task_id?: true
  }

  export type ClassTaskMinAggregateInputType = {
    class_task_id?: true
    course_task_id?: true
    class_id?: true
  }

  export type ClassTaskMaxAggregateInputType = {
    class_task_id?: true
    course_task_id?: true
    class_id?: true
  }

  export type ClassTaskCountAggregateInputType = {
    class_task_id?: true
    course_task_id?: true
    class_id?: true
    _all?: true
  }

  export type ClassTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassTask to aggregate.
     */
    where?: ClassTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassTasks to fetch.
     */
    orderBy?: ClassTaskOrderByWithRelationInput | ClassTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassTasks
    **/
    _count?: true | ClassTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassTaskMaxAggregateInputType
  }

  export type GetClassTaskAggregateType<T extends ClassTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateClassTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassTask[P]>
      : GetScalarType<T[P], AggregateClassTask[P]>
  }




  export type ClassTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassTaskWhereInput
    orderBy?: ClassTaskOrderByWithAggregationInput | ClassTaskOrderByWithAggregationInput[]
    by: ClassTaskScalarFieldEnum[] | ClassTaskScalarFieldEnum
    having?: ClassTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassTaskCountAggregateInputType | true
    _avg?: ClassTaskAvgAggregateInputType
    _sum?: ClassTaskSumAggregateInputType
    _min?: ClassTaskMinAggregateInputType
    _max?: ClassTaskMaxAggregateInputType
  }

  export type ClassTaskGroupByOutputType = {
    class_task_id: number
    course_task_id: string
    class_id: string
    _count: ClassTaskCountAggregateOutputType | null
    _avg: ClassTaskAvgAggregateOutputType | null
    _sum: ClassTaskSumAggregateOutputType | null
    _min: ClassTaskMinAggregateOutputType | null
    _max: ClassTaskMaxAggregateOutputType | null
  }

  type GetClassTaskGroupByPayload<T extends ClassTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassTaskGroupByOutputType[P]>
            : GetScalarType<T[P], ClassTaskGroupByOutputType[P]>
        }
      >
    >


  export type ClassTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    class_task_id?: boolean
    course_task_id?: boolean
    class_id?: boolean
    course_task?: boolean | CourseTaskDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    student_tasks?: boolean | ClassTask$student_tasksArgs<ExtArgs>
    student_answer?: boolean | ClassTask$student_answerArgs<ExtArgs>
    _count?: boolean | ClassTaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classTask"]>

  export type ClassTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    class_task_id?: boolean
    course_task_id?: boolean
    class_id?: boolean
    course_task?: boolean | CourseTaskDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classTask"]>

  export type ClassTaskSelectScalar = {
    class_task_id?: boolean
    course_task_id?: boolean
    class_id?: boolean
  }

  export type ClassTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course_task?: boolean | CourseTaskDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    student_tasks?: boolean | ClassTask$student_tasksArgs<ExtArgs>
    student_answer?: boolean | ClassTask$student_answerArgs<ExtArgs>
    _count?: boolean | ClassTaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course_task?: boolean | CourseTaskDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $ClassTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassTask"
    objects: {
      course_task: Prisma.$CourseTaskPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
      student_tasks: Prisma.$StudentTaskPayload<ExtArgs>[]
      student_answer: Prisma.$StudentAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      class_task_id: number
      course_task_id: string
      class_id: string
    }, ExtArgs["result"]["classTask"]>
    composites: {}
  }

  type ClassTaskGetPayload<S extends boolean | null | undefined | ClassTaskDefaultArgs> = $Result.GetResult<Prisma.$ClassTaskPayload, S>

  type ClassTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassTaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassTaskCountAggregateInputType | true
    }

  export interface ClassTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassTask'], meta: { name: 'ClassTask' } }
    /**
     * Find zero or one ClassTask that matches the filter.
     * @param {ClassTaskFindUniqueArgs} args - Arguments to find a ClassTask
     * @example
     * // Get one ClassTask
     * const classTask = await prisma.classTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassTaskFindUniqueArgs>(args: SelectSubset<T, ClassTaskFindUniqueArgs<ExtArgs>>): Prisma__ClassTaskClient<$Result.GetResult<Prisma.$ClassTaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClassTask that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassTaskFindUniqueOrThrowArgs} args - Arguments to find a ClassTask
     * @example
     * // Get one ClassTask
     * const classTask = await prisma.classTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassTaskClient<$Result.GetResult<Prisma.$ClassTaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClassTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassTaskFindFirstArgs} args - Arguments to find a ClassTask
     * @example
     * // Get one ClassTask
     * const classTask = await prisma.classTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassTaskFindFirstArgs>(args?: SelectSubset<T, ClassTaskFindFirstArgs<ExtArgs>>): Prisma__ClassTaskClient<$Result.GetResult<Prisma.$ClassTaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClassTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassTaskFindFirstOrThrowArgs} args - Arguments to find a ClassTask
     * @example
     * // Get one ClassTask
     * const classTask = await prisma.classTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassTaskClient<$Result.GetResult<Prisma.$ClassTaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClassTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassTasks
     * const classTasks = await prisma.classTask.findMany()
     * 
     * // Get first 10 ClassTasks
     * const classTasks = await prisma.classTask.findMany({ take: 10 })
     * 
     * // Only select the `class_task_id`
     * const classTaskWithClass_task_idOnly = await prisma.classTask.findMany({ select: { class_task_id: true } })
     * 
     */
    findMany<T extends ClassTaskFindManyArgs>(args?: SelectSubset<T, ClassTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassTaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClassTask.
     * @param {ClassTaskCreateArgs} args - Arguments to create a ClassTask.
     * @example
     * // Create one ClassTask
     * const ClassTask = await prisma.classTask.create({
     *   data: {
     *     // ... data to create a ClassTask
     *   }
     * })
     * 
     */
    create<T extends ClassTaskCreateArgs>(args: SelectSubset<T, ClassTaskCreateArgs<ExtArgs>>): Prisma__ClassTaskClient<$Result.GetResult<Prisma.$ClassTaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClassTasks.
     * @param {ClassTaskCreateManyArgs} args - Arguments to create many ClassTasks.
     * @example
     * // Create many ClassTasks
     * const classTask = await prisma.classTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassTaskCreateManyArgs>(args?: SelectSubset<T, ClassTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassTasks and returns the data saved in the database.
     * @param {ClassTaskCreateManyAndReturnArgs} args - Arguments to create many ClassTasks.
     * @example
     * // Create many ClassTasks
     * const classTask = await prisma.classTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassTasks and only return the `class_task_id`
     * const classTaskWithClass_task_idOnly = await prisma.classTask.createManyAndReturn({ 
     *   select: { class_task_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassTaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClassTask.
     * @param {ClassTaskDeleteArgs} args - Arguments to delete one ClassTask.
     * @example
     * // Delete one ClassTask
     * const ClassTask = await prisma.classTask.delete({
     *   where: {
     *     // ... filter to delete one ClassTask
     *   }
     * })
     * 
     */
    delete<T extends ClassTaskDeleteArgs>(args: SelectSubset<T, ClassTaskDeleteArgs<ExtArgs>>): Prisma__ClassTaskClient<$Result.GetResult<Prisma.$ClassTaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClassTask.
     * @param {ClassTaskUpdateArgs} args - Arguments to update one ClassTask.
     * @example
     * // Update one ClassTask
     * const classTask = await prisma.classTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassTaskUpdateArgs>(args: SelectSubset<T, ClassTaskUpdateArgs<ExtArgs>>): Prisma__ClassTaskClient<$Result.GetResult<Prisma.$ClassTaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClassTasks.
     * @param {ClassTaskDeleteManyArgs} args - Arguments to filter ClassTasks to delete.
     * @example
     * // Delete a few ClassTasks
     * const { count } = await prisma.classTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassTaskDeleteManyArgs>(args?: SelectSubset<T, ClassTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassTasks
     * const classTask = await prisma.classTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassTaskUpdateManyArgs>(args: SelectSubset<T, ClassTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassTask.
     * @param {ClassTaskUpsertArgs} args - Arguments to update or create a ClassTask.
     * @example
     * // Update or create a ClassTask
     * const classTask = await prisma.classTask.upsert({
     *   create: {
     *     // ... data to create a ClassTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassTask we want to update
     *   }
     * })
     */
    upsert<T extends ClassTaskUpsertArgs>(args: SelectSubset<T, ClassTaskUpsertArgs<ExtArgs>>): Prisma__ClassTaskClient<$Result.GetResult<Prisma.$ClassTaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClassTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassTaskCountArgs} args - Arguments to filter ClassTasks to count.
     * @example
     * // Count the number of ClassTasks
     * const count = await prisma.classTask.count({
     *   where: {
     *     // ... the filter for the ClassTasks we want to count
     *   }
     * })
    **/
    count<T extends ClassTaskCountArgs>(
      args?: Subset<T, ClassTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassTaskAggregateArgs>(args: Subset<T, ClassTaskAggregateArgs>): Prisma.PrismaPromise<GetClassTaskAggregateType<T>>

    /**
     * Group by ClassTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassTaskGroupByArgs['orderBy'] }
        : { orderBy?: ClassTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassTask model
   */
  readonly fields: ClassTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course_task<T extends CourseTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseTaskDefaultArgs<ExtArgs>>): Prisma__CourseTaskClient<$Result.GetResult<Prisma.$CourseTaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student_tasks<T extends ClassTask$student_tasksArgs<ExtArgs> = {}>(args?: Subset<T, ClassTask$student_tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "findMany"> | Null>
    student_answer<T extends ClassTask$student_answerArgs<ExtArgs> = {}>(args?: Subset<T, ClassTask$student_answerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassTask model
   */ 
  interface ClassTaskFieldRefs {
    readonly class_task_id: FieldRef<"ClassTask", 'Int'>
    readonly course_task_id: FieldRef<"ClassTask", 'String'>
    readonly class_id: FieldRef<"ClassTask", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClassTask findUnique
   */
  export type ClassTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassTask
     */
    select?: ClassTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTaskInclude<ExtArgs> | null
    /**
     * Filter, which ClassTask to fetch.
     */
    where: ClassTaskWhereUniqueInput
  }

  /**
   * ClassTask findUniqueOrThrow
   */
  export type ClassTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassTask
     */
    select?: ClassTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTaskInclude<ExtArgs> | null
    /**
     * Filter, which ClassTask to fetch.
     */
    where: ClassTaskWhereUniqueInput
  }

  /**
   * ClassTask findFirst
   */
  export type ClassTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassTask
     */
    select?: ClassTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTaskInclude<ExtArgs> | null
    /**
     * Filter, which ClassTask to fetch.
     */
    where?: ClassTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassTasks to fetch.
     */
    orderBy?: ClassTaskOrderByWithRelationInput | ClassTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassTasks.
     */
    cursor?: ClassTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassTasks.
     */
    distinct?: ClassTaskScalarFieldEnum | ClassTaskScalarFieldEnum[]
  }

  /**
   * ClassTask findFirstOrThrow
   */
  export type ClassTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassTask
     */
    select?: ClassTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTaskInclude<ExtArgs> | null
    /**
     * Filter, which ClassTask to fetch.
     */
    where?: ClassTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassTasks to fetch.
     */
    orderBy?: ClassTaskOrderByWithRelationInput | ClassTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassTasks.
     */
    cursor?: ClassTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassTasks.
     */
    distinct?: ClassTaskScalarFieldEnum | ClassTaskScalarFieldEnum[]
  }

  /**
   * ClassTask findMany
   */
  export type ClassTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassTask
     */
    select?: ClassTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTaskInclude<ExtArgs> | null
    /**
     * Filter, which ClassTasks to fetch.
     */
    where?: ClassTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassTasks to fetch.
     */
    orderBy?: ClassTaskOrderByWithRelationInput | ClassTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassTasks.
     */
    cursor?: ClassTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassTasks.
     */
    skip?: number
    distinct?: ClassTaskScalarFieldEnum | ClassTaskScalarFieldEnum[]
  }

  /**
   * ClassTask create
   */
  export type ClassTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassTask
     */
    select?: ClassTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassTask.
     */
    data: XOR<ClassTaskCreateInput, ClassTaskUncheckedCreateInput>
  }

  /**
   * ClassTask createMany
   */
  export type ClassTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassTasks.
     */
    data: ClassTaskCreateManyInput | ClassTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassTask createManyAndReturn
   */
  export type ClassTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassTask
     */
    select?: ClassTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClassTasks.
     */
    data: ClassTaskCreateManyInput | ClassTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassTask update
   */
  export type ClassTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassTask
     */
    select?: ClassTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassTask.
     */
    data: XOR<ClassTaskUpdateInput, ClassTaskUncheckedUpdateInput>
    /**
     * Choose, which ClassTask to update.
     */
    where: ClassTaskWhereUniqueInput
  }

  /**
   * ClassTask updateMany
   */
  export type ClassTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassTasks.
     */
    data: XOR<ClassTaskUpdateManyMutationInput, ClassTaskUncheckedUpdateManyInput>
    /**
     * Filter which ClassTasks to update
     */
    where?: ClassTaskWhereInput
  }

  /**
   * ClassTask upsert
   */
  export type ClassTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassTask
     */
    select?: ClassTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassTask to update in case it exists.
     */
    where: ClassTaskWhereUniqueInput
    /**
     * In case the ClassTask found by the `where` argument doesn't exist, create a new ClassTask with this data.
     */
    create: XOR<ClassTaskCreateInput, ClassTaskUncheckedCreateInput>
    /**
     * In case the ClassTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassTaskUpdateInput, ClassTaskUncheckedUpdateInput>
  }

  /**
   * ClassTask delete
   */
  export type ClassTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassTask
     */
    select?: ClassTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTaskInclude<ExtArgs> | null
    /**
     * Filter which ClassTask to delete.
     */
    where: ClassTaskWhereUniqueInput
  }

  /**
   * ClassTask deleteMany
   */
  export type ClassTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassTasks to delete
     */
    where?: ClassTaskWhereInput
  }

  /**
   * ClassTask.student_tasks
   */
  export type ClassTask$student_tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    where?: StudentTaskWhereInput
    orderBy?: StudentTaskOrderByWithRelationInput | StudentTaskOrderByWithRelationInput[]
    cursor?: StudentTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTaskScalarFieldEnum | StudentTaskScalarFieldEnum[]
  }

  /**
   * ClassTask.student_answer
   */
  export type ClassTask$student_answerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAnswer
     */
    select?: StudentAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAnswerInclude<ExtArgs> | null
    where?: StudentAnswerWhereInput
    orderBy?: StudentAnswerOrderByWithRelationInput | StudentAnswerOrderByWithRelationInput[]
    cursor?: StudentAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAnswerScalarFieldEnum | StudentAnswerScalarFieldEnum[]
  }

  /**
   * ClassTask without action
   */
  export type ClassTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassTask
     */
    select?: ClassTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassTaskInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    student_id: string | null
    user_id: string | null
    student_nickname: string | null
    enrolled_date: Date | null
    left_date: Date | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean | null
    class_id: string | null
  }

  export type StudentMaxAggregateOutputType = {
    student_id: string | null
    user_id: string | null
    student_nickname: string | null
    enrolled_date: Date | null
    left_date: Date | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean | null
    class_id: string | null
  }

  export type StudentCountAggregateOutputType = {
    student_id: number
    user_id: number
    student_nickname: number
    enrolled_date: number
    left_date: number
    created_date: number
    updated_date: number
    deleted: number
    class_id: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    student_id?: true
    user_id?: true
    student_nickname?: true
    enrolled_date?: true
    left_date?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    class_id?: true
  }

  export type StudentMaxAggregateInputType = {
    student_id?: true
    user_id?: true
    student_nickname?: true
    enrolled_date?: true
    left_date?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    class_id?: true
  }

  export type StudentCountAggregateInputType = {
    student_id?: true
    user_id?: true
    student_nickname?: true
    enrolled_date?: true
    left_date?: true
    created_date?: true
    updated_date?: true
    deleted?: true
    class_id?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    student_id: string
    user_id: string
    student_nickname: string | null
    enrolled_date: Date | null
    left_date: Date | null
    created_date: Date | null
    updated_date: Date | null
    deleted: boolean
    class_id: string
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_id?: boolean
    user_id?: boolean
    student_nickname?: boolean
    enrolled_date?: boolean
    left_date?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    class_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    student_task?: boolean | Student$student_taskArgs<ExtArgs>
    student_answers?: boolean | Student$student_answersArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_id?: boolean
    user_id?: boolean
    student_nickname?: boolean
    enrolled_date?: boolean
    left_date?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    class_id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    student_id?: boolean
    user_id?: boolean
    student_nickname?: boolean
    enrolled_date?: boolean
    left_date?: boolean
    created_date?: boolean
    updated_date?: boolean
    deleted?: boolean
    class_id?: boolean
  }

  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    student_task?: boolean | Student$student_taskArgs<ExtArgs>
    student_answers?: boolean | Student$student_answersArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
      student_task: Prisma.$StudentTaskPayload<ExtArgs>[]
      student_answers: Prisma.$StudentAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      student_id: string
      user_id: string
      student_nickname: string | null
      /**
       * When the student joined a particular class
       */
      enrolled_date: Date | null
      left_date: Date | null
      created_date: Date | null
      updated_date: Date | null
      deleted: boolean
      class_id: string
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `student_id`
     * const studentWithStudent_idOnly = await prisma.student.findMany({ select: { student_id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `student_id`
     * const studentWithStudent_idOnly = await prisma.student.createManyAndReturn({ 
     *   select: { student_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student_task<T extends Student$student_taskArgs<ExtArgs> = {}>(args?: Subset<T, Student$student_taskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "findMany"> | Null>
    student_answers<T extends Student$student_answersArgs<ExtArgs> = {}>(args?: Subset<T, Student$student_answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAnswerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */ 
  interface StudentFieldRefs {
    readonly student_id: FieldRef<"Student", 'String'>
    readonly user_id: FieldRef<"Student", 'String'>
    readonly student_nickname: FieldRef<"Student", 'String'>
    readonly enrolled_date: FieldRef<"Student", 'DateTime'>
    readonly left_date: FieldRef<"Student", 'DateTime'>
    readonly created_date: FieldRef<"Student", 'DateTime'>
    readonly updated_date: FieldRef<"Student", 'DateTime'>
    readonly deleted: FieldRef<"Student", 'Boolean'>
    readonly class_id: FieldRef<"Student", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
  }

  /**
   * Student.student_task
   */
  export type Student$student_taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    where?: StudentTaskWhereInput
    orderBy?: StudentTaskOrderByWithRelationInput | StudentTaskOrderByWithRelationInput[]
    cursor?: StudentTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTaskScalarFieldEnum | StudentTaskScalarFieldEnum[]
  }

  /**
   * Student.student_answers
   */
  export type Student$student_answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAnswer
     */
    select?: StudentAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAnswerInclude<ExtArgs> | null
    where?: StudentAnswerWhereInput
    orderBy?: StudentAnswerOrderByWithRelationInput | StudentAnswerOrderByWithRelationInput[]
    cursor?: StudentAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAnswerScalarFieldEnum | StudentAnswerScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model StudentAnswer
   */

  export type AggregateStudentAnswer = {
    _count: StudentAnswerCountAggregateOutputType | null
    _avg: StudentAnswerAvgAggregateOutputType | null
    _sum: StudentAnswerSumAggregateOutputType | null
    _min: StudentAnswerMinAggregateOutputType | null
    _max: StudentAnswerMaxAggregateOutputType | null
  }

  export type StudentAnswerAvgAggregateOutputType = {
    student_answer_id: number | null
    class_task_id: number | null
  }

  export type StudentAnswerSumAggregateOutputType = {
    student_answer_id: number | null
    class_task_id: number | null
  }

  export type StudentAnswerMinAggregateOutputType = {
    student_answer_id: number | null
    student_id: string | null
    class_task_id: number | null
    answer: string | null
  }

  export type StudentAnswerMaxAggregateOutputType = {
    student_answer_id: number | null
    student_id: string | null
    class_task_id: number | null
    answer: string | null
  }

  export type StudentAnswerCountAggregateOutputType = {
    student_answer_id: number
    student_id: number
    class_task_id: number
    answer: number
    _all: number
  }


  export type StudentAnswerAvgAggregateInputType = {
    student_answer_id?: true
    class_task_id?: true
  }

  export type StudentAnswerSumAggregateInputType = {
    student_answer_id?: true
    class_task_id?: true
  }

  export type StudentAnswerMinAggregateInputType = {
    student_answer_id?: true
    student_id?: true
    class_task_id?: true
    answer?: true
  }

  export type StudentAnswerMaxAggregateInputType = {
    student_answer_id?: true
    student_id?: true
    class_task_id?: true
    answer?: true
  }

  export type StudentAnswerCountAggregateInputType = {
    student_answer_id?: true
    student_id?: true
    class_task_id?: true
    answer?: true
    _all?: true
  }

  export type StudentAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAnswer to aggregate.
     */
    where?: StudentAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAnswers to fetch.
     */
    orderBy?: StudentAnswerOrderByWithRelationInput | StudentAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentAnswers
    **/
    _count?: true | StudentAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentAnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentAnswerMaxAggregateInputType
  }

  export type GetStudentAnswerAggregateType<T extends StudentAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentAnswer[P]>
      : GetScalarType<T[P], AggregateStudentAnswer[P]>
  }




  export type StudentAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAnswerWhereInput
    orderBy?: StudentAnswerOrderByWithAggregationInput | StudentAnswerOrderByWithAggregationInput[]
    by: StudentAnswerScalarFieldEnum[] | StudentAnswerScalarFieldEnum
    having?: StudentAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentAnswerCountAggregateInputType | true
    _avg?: StudentAnswerAvgAggregateInputType
    _sum?: StudentAnswerSumAggregateInputType
    _min?: StudentAnswerMinAggregateInputType
    _max?: StudentAnswerMaxAggregateInputType
  }

  export type StudentAnswerGroupByOutputType = {
    student_answer_id: number
    student_id: string
    class_task_id: number
    answer: string
    _count: StudentAnswerCountAggregateOutputType | null
    _avg: StudentAnswerAvgAggregateOutputType | null
    _sum: StudentAnswerSumAggregateOutputType | null
    _min: StudentAnswerMinAggregateOutputType | null
    _max: StudentAnswerMaxAggregateOutputType | null
  }

  type GetStudentAnswerGroupByPayload<T extends StudentAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], StudentAnswerGroupByOutputType[P]>
        }
      >
    >


  export type StudentAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_answer_id?: boolean
    student_id?: boolean
    class_task_id?: boolean
    answer?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    class_task?: boolean | ClassTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentAnswer"]>

  export type StudentAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_answer_id?: boolean
    student_id?: boolean
    class_task_id?: boolean
    answer?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    class_task?: boolean | ClassTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentAnswer"]>

  export type StudentAnswerSelectScalar = {
    student_answer_id?: boolean
    student_id?: boolean
    class_task_id?: boolean
    answer?: boolean
  }

  export type StudentAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    class_task?: boolean | ClassTaskDefaultArgs<ExtArgs>
  }
  export type StudentAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    class_task?: boolean | ClassTaskDefaultArgs<ExtArgs>
  }

  export type $StudentAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentAnswer"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      class_task: Prisma.$ClassTaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      student_answer_id: number
      student_id: string
      class_task_id: number
      answer: string
    }, ExtArgs["result"]["studentAnswer"]>
    composites: {}
  }

  type StudentAnswerGetPayload<S extends boolean | null | undefined | StudentAnswerDefaultArgs> = $Result.GetResult<Prisma.$StudentAnswerPayload, S>

  type StudentAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentAnswerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentAnswerCountAggregateInputType | true
    }

  export interface StudentAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentAnswer'], meta: { name: 'StudentAnswer' } }
    /**
     * Find zero or one StudentAnswer that matches the filter.
     * @param {StudentAnswerFindUniqueArgs} args - Arguments to find a StudentAnswer
     * @example
     * // Get one StudentAnswer
     * const studentAnswer = await prisma.studentAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentAnswerFindUniqueArgs>(args: SelectSubset<T, StudentAnswerFindUniqueArgs<ExtArgs>>): Prisma__StudentAnswerClient<$Result.GetResult<Prisma.$StudentAnswerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentAnswer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentAnswerFindUniqueOrThrowArgs} args - Arguments to find a StudentAnswer
     * @example
     * // Get one StudentAnswer
     * const studentAnswer = await prisma.studentAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentAnswerClient<$Result.GetResult<Prisma.$StudentAnswerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAnswerFindFirstArgs} args - Arguments to find a StudentAnswer
     * @example
     * // Get one StudentAnswer
     * const studentAnswer = await prisma.studentAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentAnswerFindFirstArgs>(args?: SelectSubset<T, StudentAnswerFindFirstArgs<ExtArgs>>): Prisma__StudentAnswerClient<$Result.GetResult<Prisma.$StudentAnswerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAnswerFindFirstOrThrowArgs} args - Arguments to find a StudentAnswer
     * @example
     * // Get one StudentAnswer
     * const studentAnswer = await prisma.studentAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentAnswerClient<$Result.GetResult<Prisma.$StudentAnswerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentAnswers
     * const studentAnswers = await prisma.studentAnswer.findMany()
     * 
     * // Get first 10 StudentAnswers
     * const studentAnswers = await prisma.studentAnswer.findMany({ take: 10 })
     * 
     * // Only select the `student_answer_id`
     * const studentAnswerWithStudent_answer_idOnly = await prisma.studentAnswer.findMany({ select: { student_answer_id: true } })
     * 
     */
    findMany<T extends StudentAnswerFindManyArgs>(args?: SelectSubset<T, StudentAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAnswerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentAnswer.
     * @param {StudentAnswerCreateArgs} args - Arguments to create a StudentAnswer.
     * @example
     * // Create one StudentAnswer
     * const StudentAnswer = await prisma.studentAnswer.create({
     *   data: {
     *     // ... data to create a StudentAnswer
     *   }
     * })
     * 
     */
    create<T extends StudentAnswerCreateArgs>(args: SelectSubset<T, StudentAnswerCreateArgs<ExtArgs>>): Prisma__StudentAnswerClient<$Result.GetResult<Prisma.$StudentAnswerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentAnswers.
     * @param {StudentAnswerCreateManyArgs} args - Arguments to create many StudentAnswers.
     * @example
     * // Create many StudentAnswers
     * const studentAnswer = await prisma.studentAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentAnswerCreateManyArgs>(args?: SelectSubset<T, StudentAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentAnswers and returns the data saved in the database.
     * @param {StudentAnswerCreateManyAndReturnArgs} args - Arguments to create many StudentAnswers.
     * @example
     * // Create many StudentAnswers
     * const studentAnswer = await prisma.studentAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentAnswers and only return the `student_answer_id`
     * const studentAnswerWithStudent_answer_idOnly = await prisma.studentAnswer.createManyAndReturn({ 
     *   select: { student_answer_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAnswerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentAnswer.
     * @param {StudentAnswerDeleteArgs} args - Arguments to delete one StudentAnswer.
     * @example
     * // Delete one StudentAnswer
     * const StudentAnswer = await prisma.studentAnswer.delete({
     *   where: {
     *     // ... filter to delete one StudentAnswer
     *   }
     * })
     * 
     */
    delete<T extends StudentAnswerDeleteArgs>(args: SelectSubset<T, StudentAnswerDeleteArgs<ExtArgs>>): Prisma__StudentAnswerClient<$Result.GetResult<Prisma.$StudentAnswerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentAnswer.
     * @param {StudentAnswerUpdateArgs} args - Arguments to update one StudentAnswer.
     * @example
     * // Update one StudentAnswer
     * const studentAnswer = await prisma.studentAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentAnswerUpdateArgs>(args: SelectSubset<T, StudentAnswerUpdateArgs<ExtArgs>>): Prisma__StudentAnswerClient<$Result.GetResult<Prisma.$StudentAnswerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentAnswers.
     * @param {StudentAnswerDeleteManyArgs} args - Arguments to filter StudentAnswers to delete.
     * @example
     * // Delete a few StudentAnswers
     * const { count } = await prisma.studentAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentAnswerDeleteManyArgs>(args?: SelectSubset<T, StudentAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentAnswers
     * const studentAnswer = await prisma.studentAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentAnswerUpdateManyArgs>(args: SelectSubset<T, StudentAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentAnswer.
     * @param {StudentAnswerUpsertArgs} args - Arguments to update or create a StudentAnswer.
     * @example
     * // Update or create a StudentAnswer
     * const studentAnswer = await prisma.studentAnswer.upsert({
     *   create: {
     *     // ... data to create a StudentAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentAnswer we want to update
     *   }
     * })
     */
    upsert<T extends StudentAnswerUpsertArgs>(args: SelectSubset<T, StudentAnswerUpsertArgs<ExtArgs>>): Prisma__StudentAnswerClient<$Result.GetResult<Prisma.$StudentAnswerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAnswerCountArgs} args - Arguments to filter StudentAnswers to count.
     * @example
     * // Count the number of StudentAnswers
     * const count = await prisma.studentAnswer.count({
     *   where: {
     *     // ... the filter for the StudentAnswers we want to count
     *   }
     * })
    **/
    count<T extends StudentAnswerCountArgs>(
      args?: Subset<T, StudentAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAnswerAggregateArgs>(args: Subset<T, StudentAnswerAggregateArgs>): Prisma.PrismaPromise<GetStudentAnswerAggregateType<T>>

    /**
     * Group by StudentAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentAnswerGroupByArgs['orderBy'] }
        : { orderBy?: StudentAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentAnswer model
   */
  readonly fields: StudentAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class_task<T extends ClassTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassTaskDefaultArgs<ExtArgs>>): Prisma__ClassTaskClient<$Result.GetResult<Prisma.$ClassTaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentAnswer model
   */ 
  interface StudentAnswerFieldRefs {
    readonly student_answer_id: FieldRef<"StudentAnswer", 'Int'>
    readonly student_id: FieldRef<"StudentAnswer", 'String'>
    readonly class_task_id: FieldRef<"StudentAnswer", 'Int'>
    readonly answer: FieldRef<"StudentAnswer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentAnswer findUnique
   */
  export type StudentAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAnswer
     */
    select?: StudentAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAnswerInclude<ExtArgs> | null
    /**
     * Filter, which StudentAnswer to fetch.
     */
    where: StudentAnswerWhereUniqueInput
  }

  /**
   * StudentAnswer findUniqueOrThrow
   */
  export type StudentAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAnswer
     */
    select?: StudentAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAnswerInclude<ExtArgs> | null
    /**
     * Filter, which StudentAnswer to fetch.
     */
    where: StudentAnswerWhereUniqueInput
  }

  /**
   * StudentAnswer findFirst
   */
  export type StudentAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAnswer
     */
    select?: StudentAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAnswerInclude<ExtArgs> | null
    /**
     * Filter, which StudentAnswer to fetch.
     */
    where?: StudentAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAnswers to fetch.
     */
    orderBy?: StudentAnswerOrderByWithRelationInput | StudentAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAnswers.
     */
    cursor?: StudentAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAnswers.
     */
    distinct?: StudentAnswerScalarFieldEnum | StudentAnswerScalarFieldEnum[]
  }

  /**
   * StudentAnswer findFirstOrThrow
   */
  export type StudentAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAnswer
     */
    select?: StudentAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAnswerInclude<ExtArgs> | null
    /**
     * Filter, which StudentAnswer to fetch.
     */
    where?: StudentAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAnswers to fetch.
     */
    orderBy?: StudentAnswerOrderByWithRelationInput | StudentAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAnswers.
     */
    cursor?: StudentAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAnswers.
     */
    distinct?: StudentAnswerScalarFieldEnum | StudentAnswerScalarFieldEnum[]
  }

  /**
   * StudentAnswer findMany
   */
  export type StudentAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAnswer
     */
    select?: StudentAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAnswerInclude<ExtArgs> | null
    /**
     * Filter, which StudentAnswers to fetch.
     */
    where?: StudentAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAnswers to fetch.
     */
    orderBy?: StudentAnswerOrderByWithRelationInput | StudentAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentAnswers.
     */
    cursor?: StudentAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAnswers.
     */
    skip?: number
    distinct?: StudentAnswerScalarFieldEnum | StudentAnswerScalarFieldEnum[]
  }

  /**
   * StudentAnswer create
   */
  export type StudentAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAnswer
     */
    select?: StudentAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentAnswer.
     */
    data: XOR<StudentAnswerCreateInput, StudentAnswerUncheckedCreateInput>
  }

  /**
   * StudentAnswer createMany
   */
  export type StudentAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentAnswers.
     */
    data: StudentAnswerCreateManyInput | StudentAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentAnswer createManyAndReturn
   */
  export type StudentAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAnswer
     */
    select?: StudentAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentAnswers.
     */
    data: StudentAnswerCreateManyInput | StudentAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentAnswer update
   */
  export type StudentAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAnswer
     */
    select?: StudentAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentAnswer.
     */
    data: XOR<StudentAnswerUpdateInput, StudentAnswerUncheckedUpdateInput>
    /**
     * Choose, which StudentAnswer to update.
     */
    where: StudentAnswerWhereUniqueInput
  }

  /**
   * StudentAnswer updateMany
   */
  export type StudentAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentAnswers.
     */
    data: XOR<StudentAnswerUpdateManyMutationInput, StudentAnswerUncheckedUpdateManyInput>
    /**
     * Filter which StudentAnswers to update
     */
    where?: StudentAnswerWhereInput
  }

  /**
   * StudentAnswer upsert
   */
  export type StudentAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAnswer
     */
    select?: StudentAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentAnswer to update in case it exists.
     */
    where: StudentAnswerWhereUniqueInput
    /**
     * In case the StudentAnswer found by the `where` argument doesn't exist, create a new StudentAnswer with this data.
     */
    create: XOR<StudentAnswerCreateInput, StudentAnswerUncheckedCreateInput>
    /**
     * In case the StudentAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentAnswerUpdateInput, StudentAnswerUncheckedUpdateInput>
  }

  /**
   * StudentAnswer delete
   */
  export type StudentAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAnswer
     */
    select?: StudentAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAnswerInclude<ExtArgs> | null
    /**
     * Filter which StudentAnswer to delete.
     */
    where: StudentAnswerWhereUniqueInput
  }

  /**
   * StudentAnswer deleteMany
   */
  export type StudentAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAnswers to delete
     */
    where?: StudentAnswerWhereInput
  }

  /**
   * StudentAnswer without action
   */
  export type StudentAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAnswer
     */
    select?: StudentAnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAnswerInclude<ExtArgs> | null
  }


  /**
   * Model StudentTask
   */

  export type AggregateStudentTask = {
    _count: StudentTaskCountAggregateOutputType | null
    _avg: StudentTaskAvgAggregateOutputType | null
    _sum: StudentTaskSumAggregateOutputType | null
    _min: StudentTaskMinAggregateOutputType | null
    _max: StudentTaskMaxAggregateOutputType | null
  }

  export type StudentTaskAvgAggregateOutputType = {
    student_task_id: number | null
    class_task_id: number | null
  }

  export type StudentTaskSumAggregateOutputType = {
    student_task_id: number | null
    class_task_id: number | null
  }

  export type StudentTaskMinAggregateOutputType = {
    student_task_id: number | null
    student_id: string | null
    class_task_id: number | null
    task_status: $Enums.StudentTaskStatus | null
  }

  export type StudentTaskMaxAggregateOutputType = {
    student_task_id: number | null
    student_id: string | null
    class_task_id: number | null
    task_status: $Enums.StudentTaskStatus | null
  }

  export type StudentTaskCountAggregateOutputType = {
    student_task_id: number
    student_id: number
    class_task_id: number
    task_status: number
    _all: number
  }


  export type StudentTaskAvgAggregateInputType = {
    student_task_id?: true
    class_task_id?: true
  }

  export type StudentTaskSumAggregateInputType = {
    student_task_id?: true
    class_task_id?: true
  }

  export type StudentTaskMinAggregateInputType = {
    student_task_id?: true
    student_id?: true
    class_task_id?: true
    task_status?: true
  }

  export type StudentTaskMaxAggregateInputType = {
    student_task_id?: true
    student_id?: true
    class_task_id?: true
    task_status?: true
  }

  export type StudentTaskCountAggregateInputType = {
    student_task_id?: true
    student_id?: true
    class_task_id?: true
    task_status?: true
    _all?: true
  }

  export type StudentTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTask to aggregate.
     */
    where?: StudentTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTasks to fetch.
     */
    orderBy?: StudentTaskOrderByWithRelationInput | StudentTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentTasks
    **/
    _count?: true | StudentTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentTaskMaxAggregateInputType
  }

  export type GetStudentTaskAggregateType<T extends StudentTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentTask[P]>
      : GetScalarType<T[P], AggregateStudentTask[P]>
  }




  export type StudentTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTaskWhereInput
    orderBy?: StudentTaskOrderByWithAggregationInput | StudentTaskOrderByWithAggregationInput[]
    by: StudentTaskScalarFieldEnum[] | StudentTaskScalarFieldEnum
    having?: StudentTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentTaskCountAggregateInputType | true
    _avg?: StudentTaskAvgAggregateInputType
    _sum?: StudentTaskSumAggregateInputType
    _min?: StudentTaskMinAggregateInputType
    _max?: StudentTaskMaxAggregateInputType
  }

  export type StudentTaskGroupByOutputType = {
    student_task_id: number
    student_id: string
    class_task_id: number
    task_status: $Enums.StudentTaskStatus
    _count: StudentTaskCountAggregateOutputType | null
    _avg: StudentTaskAvgAggregateOutputType | null
    _sum: StudentTaskSumAggregateOutputType | null
    _min: StudentTaskMinAggregateOutputType | null
    _max: StudentTaskMaxAggregateOutputType | null
  }

  type GetStudentTaskGroupByPayload<T extends StudentTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentTaskGroupByOutputType[P]>
            : GetScalarType<T[P], StudentTaskGroupByOutputType[P]>
        }
      >
    >


  export type StudentTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_task_id?: boolean
    student_id?: boolean
    class_task_id?: boolean
    task_status?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    class_task?: boolean | ClassTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTask"]>

  export type StudentTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_task_id?: boolean
    student_id?: boolean
    class_task_id?: boolean
    task_status?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    class_task?: boolean | ClassTaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTask"]>

  export type StudentTaskSelectScalar = {
    student_task_id?: boolean
    student_id?: boolean
    class_task_id?: boolean
    task_status?: boolean
  }

  export type StudentTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    class_task?: boolean | ClassTaskDefaultArgs<ExtArgs>
  }
  export type StudentTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    class_task?: boolean | ClassTaskDefaultArgs<ExtArgs>
  }

  export type $StudentTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentTask"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      class_task: Prisma.$ClassTaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      student_task_id: number
      student_id: string
      class_task_id: number
      task_status: $Enums.StudentTaskStatus
    }, ExtArgs["result"]["studentTask"]>
    composites: {}
  }

  type StudentTaskGetPayload<S extends boolean | null | undefined | StudentTaskDefaultArgs> = $Result.GetResult<Prisma.$StudentTaskPayload, S>

  type StudentTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentTaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentTaskCountAggregateInputType | true
    }

  export interface StudentTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentTask'], meta: { name: 'StudentTask' } }
    /**
     * Find zero or one StudentTask that matches the filter.
     * @param {StudentTaskFindUniqueArgs} args - Arguments to find a StudentTask
     * @example
     * // Get one StudentTask
     * const studentTask = await prisma.studentTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentTaskFindUniqueArgs>(args: SelectSubset<T, StudentTaskFindUniqueArgs<ExtArgs>>): Prisma__StudentTaskClient<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentTask that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentTaskFindUniqueOrThrowArgs} args - Arguments to find a StudentTask
     * @example
     * // Get one StudentTask
     * const studentTask = await prisma.studentTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentTaskClient<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTaskFindFirstArgs} args - Arguments to find a StudentTask
     * @example
     * // Get one StudentTask
     * const studentTask = await prisma.studentTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentTaskFindFirstArgs>(args?: SelectSubset<T, StudentTaskFindFirstArgs<ExtArgs>>): Prisma__StudentTaskClient<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTaskFindFirstOrThrowArgs} args - Arguments to find a StudentTask
     * @example
     * // Get one StudentTask
     * const studentTask = await prisma.studentTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentTaskClient<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentTasks
     * const studentTasks = await prisma.studentTask.findMany()
     * 
     * // Get first 10 StudentTasks
     * const studentTasks = await prisma.studentTask.findMany({ take: 10 })
     * 
     * // Only select the `student_task_id`
     * const studentTaskWithStudent_task_idOnly = await prisma.studentTask.findMany({ select: { student_task_id: true } })
     * 
     */
    findMany<T extends StudentTaskFindManyArgs>(args?: SelectSubset<T, StudentTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentTask.
     * @param {StudentTaskCreateArgs} args - Arguments to create a StudentTask.
     * @example
     * // Create one StudentTask
     * const StudentTask = await prisma.studentTask.create({
     *   data: {
     *     // ... data to create a StudentTask
     *   }
     * })
     * 
     */
    create<T extends StudentTaskCreateArgs>(args: SelectSubset<T, StudentTaskCreateArgs<ExtArgs>>): Prisma__StudentTaskClient<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentTasks.
     * @param {StudentTaskCreateManyArgs} args - Arguments to create many StudentTasks.
     * @example
     * // Create many StudentTasks
     * const studentTask = await prisma.studentTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentTaskCreateManyArgs>(args?: SelectSubset<T, StudentTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentTasks and returns the data saved in the database.
     * @param {StudentTaskCreateManyAndReturnArgs} args - Arguments to create many StudentTasks.
     * @example
     * // Create many StudentTasks
     * const studentTask = await prisma.studentTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentTasks and only return the `student_task_id`
     * const studentTaskWithStudent_task_idOnly = await prisma.studentTask.createManyAndReturn({ 
     *   select: { student_task_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentTask.
     * @param {StudentTaskDeleteArgs} args - Arguments to delete one StudentTask.
     * @example
     * // Delete one StudentTask
     * const StudentTask = await prisma.studentTask.delete({
     *   where: {
     *     // ... filter to delete one StudentTask
     *   }
     * })
     * 
     */
    delete<T extends StudentTaskDeleteArgs>(args: SelectSubset<T, StudentTaskDeleteArgs<ExtArgs>>): Prisma__StudentTaskClient<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentTask.
     * @param {StudentTaskUpdateArgs} args - Arguments to update one StudentTask.
     * @example
     * // Update one StudentTask
     * const studentTask = await prisma.studentTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentTaskUpdateArgs>(args: SelectSubset<T, StudentTaskUpdateArgs<ExtArgs>>): Prisma__StudentTaskClient<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentTasks.
     * @param {StudentTaskDeleteManyArgs} args - Arguments to filter StudentTasks to delete.
     * @example
     * // Delete a few StudentTasks
     * const { count } = await prisma.studentTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentTaskDeleteManyArgs>(args?: SelectSubset<T, StudentTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentTasks
     * const studentTask = await prisma.studentTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentTaskUpdateManyArgs>(args: SelectSubset<T, StudentTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentTask.
     * @param {StudentTaskUpsertArgs} args - Arguments to update or create a StudentTask.
     * @example
     * // Update or create a StudentTask
     * const studentTask = await prisma.studentTask.upsert({
     *   create: {
     *     // ... data to create a StudentTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentTask we want to update
     *   }
     * })
     */
    upsert<T extends StudentTaskUpsertArgs>(args: SelectSubset<T, StudentTaskUpsertArgs<ExtArgs>>): Prisma__StudentTaskClient<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTaskCountArgs} args - Arguments to filter StudentTasks to count.
     * @example
     * // Count the number of StudentTasks
     * const count = await prisma.studentTask.count({
     *   where: {
     *     // ... the filter for the StudentTasks we want to count
     *   }
     * })
    **/
    count<T extends StudentTaskCountArgs>(
      args?: Subset<T, StudentTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentTaskAggregateArgs>(args: Subset<T, StudentTaskAggregateArgs>): Prisma.PrismaPromise<GetStudentTaskAggregateType<T>>

    /**
     * Group by StudentTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentTaskGroupByArgs['orderBy'] }
        : { orderBy?: StudentTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentTask model
   */
  readonly fields: StudentTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class_task<T extends ClassTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassTaskDefaultArgs<ExtArgs>>): Prisma__ClassTaskClient<$Result.GetResult<Prisma.$ClassTaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentTask model
   */ 
  interface StudentTaskFieldRefs {
    readonly student_task_id: FieldRef<"StudentTask", 'Int'>
    readonly student_id: FieldRef<"StudentTask", 'String'>
    readonly class_task_id: FieldRef<"StudentTask", 'Int'>
    readonly task_status: FieldRef<"StudentTask", 'StudentTaskStatus'>
  }
    

  // Custom InputTypes
  /**
   * StudentTask findUnique
   */
  export type StudentTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * Filter, which StudentTask to fetch.
     */
    where: StudentTaskWhereUniqueInput
  }

  /**
   * StudentTask findUniqueOrThrow
   */
  export type StudentTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * Filter, which StudentTask to fetch.
     */
    where: StudentTaskWhereUniqueInput
  }

  /**
   * StudentTask findFirst
   */
  export type StudentTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * Filter, which StudentTask to fetch.
     */
    where?: StudentTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTasks to fetch.
     */
    orderBy?: StudentTaskOrderByWithRelationInput | StudentTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTasks.
     */
    cursor?: StudentTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTasks.
     */
    distinct?: StudentTaskScalarFieldEnum | StudentTaskScalarFieldEnum[]
  }

  /**
   * StudentTask findFirstOrThrow
   */
  export type StudentTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * Filter, which StudentTask to fetch.
     */
    where?: StudentTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTasks to fetch.
     */
    orderBy?: StudentTaskOrderByWithRelationInput | StudentTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTasks.
     */
    cursor?: StudentTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTasks.
     */
    distinct?: StudentTaskScalarFieldEnum | StudentTaskScalarFieldEnum[]
  }

  /**
   * StudentTask findMany
   */
  export type StudentTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * Filter, which StudentTasks to fetch.
     */
    where?: StudentTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTasks to fetch.
     */
    orderBy?: StudentTaskOrderByWithRelationInput | StudentTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentTasks.
     */
    cursor?: StudentTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTasks.
     */
    skip?: number
    distinct?: StudentTaskScalarFieldEnum | StudentTaskScalarFieldEnum[]
  }

  /**
   * StudentTask create
   */
  export type StudentTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentTask.
     */
    data: XOR<StudentTaskCreateInput, StudentTaskUncheckedCreateInput>
  }

  /**
   * StudentTask createMany
   */
  export type StudentTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentTasks.
     */
    data: StudentTaskCreateManyInput | StudentTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentTask createManyAndReturn
   */
  export type StudentTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentTasks.
     */
    data: StudentTaskCreateManyInput | StudentTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentTask update
   */
  export type StudentTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentTask.
     */
    data: XOR<StudentTaskUpdateInput, StudentTaskUncheckedUpdateInput>
    /**
     * Choose, which StudentTask to update.
     */
    where: StudentTaskWhereUniqueInput
  }

  /**
   * StudentTask updateMany
   */
  export type StudentTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentTasks.
     */
    data: XOR<StudentTaskUpdateManyMutationInput, StudentTaskUncheckedUpdateManyInput>
    /**
     * Filter which StudentTasks to update
     */
    where?: StudentTaskWhereInput
  }

  /**
   * StudentTask upsert
   */
  export type StudentTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentTask to update in case it exists.
     */
    where: StudentTaskWhereUniqueInput
    /**
     * In case the StudentTask found by the `where` argument doesn't exist, create a new StudentTask with this data.
     */
    create: XOR<StudentTaskCreateInput, StudentTaskUncheckedCreateInput>
    /**
     * In case the StudentTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentTaskUpdateInput, StudentTaskUncheckedUpdateInput>
  }

  /**
   * StudentTask delete
   */
  export type StudentTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * Filter which StudentTask to delete.
     */
    where: StudentTaskWhereUniqueInput
  }

  /**
   * StudentTask deleteMany
   */
  export type StudentTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTasks to delete
     */
    where?: StudentTaskWhereInput
  }

  /**
   * StudentTask without action
   */
  export type StudentTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    task_id: number | null
    task_type_id: number | null
    task_form_id: number | null
    lesson_id: number | null
  }

  export type TaskSumAggregateOutputType = {
    task_id: number | null
    task_type_id: number | null
    task_form_id: number | null
    lesson_id: number | null
  }

  export type TaskMinAggregateOutputType = {
    task_id: number | null
    task_description: string | null
    task_text: string | null
    task_type_id: number | null
    task_context_id: string | null
    task_form_id: number | null
    task_created_date: Date | null
    task_updated_date: Date | null
    deleted: boolean | null
    lesson_id: number | null
    gap_map: string | null
  }

  export type TaskMaxAggregateOutputType = {
    task_id: number | null
    task_description: string | null
    task_text: string | null
    task_type_id: number | null
    task_context_id: string | null
    task_form_id: number | null
    task_created_date: Date | null
    task_updated_date: Date | null
    deleted: boolean | null
    lesson_id: number | null
    gap_map: string | null
  }

  export type TaskCountAggregateOutputType = {
    task_id: number
    task_description: number
    task_text: number
    task_type_id: number
    task_context_id: number
    task_form_id: number
    task_created_date: number
    task_updated_date: number
    deleted: number
    lesson_id: number
    gap_map: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    task_id?: true
    task_type_id?: true
    task_form_id?: true
    lesson_id?: true
  }

  export type TaskSumAggregateInputType = {
    task_id?: true
    task_type_id?: true
    task_form_id?: true
    lesson_id?: true
  }

  export type TaskMinAggregateInputType = {
    task_id?: true
    task_description?: true
    task_text?: true
    task_type_id?: true
    task_context_id?: true
    task_form_id?: true
    task_created_date?: true
    task_updated_date?: true
    deleted?: true
    lesson_id?: true
    gap_map?: true
  }

  export type TaskMaxAggregateInputType = {
    task_id?: true
    task_description?: true
    task_text?: true
    task_type_id?: true
    task_context_id?: true
    task_form_id?: true
    task_created_date?: true
    task_updated_date?: true
    deleted?: true
    lesson_id?: true
    gap_map?: true
  }

  export type TaskCountAggregateInputType = {
    task_id?: true
    task_description?: true
    task_text?: true
    task_type_id?: true
    task_context_id?: true
    task_form_id?: true
    task_created_date?: true
    task_updated_date?: true
    deleted?: true
    lesson_id?: true
    gap_map?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    task_id: number
    task_description: string | null
    task_text: string | null
    task_type_id: number
    task_context_id: string
    task_form_id: number | null
    task_created_date: Date | null
    task_updated_date: Date | null
    deleted: boolean
    lesson_id: number
    gap_map: string | null
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    task_id?: boolean
    task_description?: boolean
    task_text?: boolean
    task_type_id?: boolean
    task_context_id?: boolean
    task_form_id?: boolean
    task_created_date?: boolean
    task_updated_date?: boolean
    deleted?: boolean
    lesson_id?: boolean
    gap_map?: boolean
    task_type?: boolean | TaskTypeDefaultArgs<ExtArgs>
    task_context?: boolean | TaskContextDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    task_forms?: boolean | Task$task_formsArgs<ExtArgs>
    task_options?: boolean | Task$task_optionsArgs<ExtArgs>
    CourseTask?: boolean | Task$CourseTaskArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    task_id?: boolean
    task_description?: boolean
    task_text?: boolean
    task_type_id?: boolean
    task_context_id?: boolean
    task_form_id?: boolean
    task_created_date?: boolean
    task_updated_date?: boolean
    deleted?: boolean
    lesson_id?: boolean
    gap_map?: boolean
    task_type?: boolean | TaskTypeDefaultArgs<ExtArgs>
    task_context?: boolean | TaskContextDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    task_id?: boolean
    task_description?: boolean
    task_text?: boolean
    task_type_id?: boolean
    task_context_id?: boolean
    task_form_id?: boolean
    task_created_date?: boolean
    task_updated_date?: boolean
    deleted?: boolean
    lesson_id?: boolean
    gap_map?: boolean
  }

  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_type?: boolean | TaskTypeDefaultArgs<ExtArgs>
    task_context?: boolean | TaskContextDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    task_forms?: boolean | Task$task_formsArgs<ExtArgs>
    task_options?: boolean | Task$task_optionsArgs<ExtArgs>
    CourseTask?: boolean | Task$CourseTaskArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task_type?: boolean | TaskTypeDefaultArgs<ExtArgs>
    task_context?: boolean | TaskContextDefaultArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      task_type: Prisma.$TaskTypePayload<ExtArgs>
      task_context: Prisma.$TaskContextPayload<ExtArgs>
      lesson: Prisma.$LessonPayload<ExtArgs>
      task_forms: Prisma.$TaskFormPayload<ExtArgs>[]
      task_options: Prisma.$TaskOptionPayload<ExtArgs>[]
      CourseTask: Prisma.$CourseTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      task_id: number
      /**
       * Instruction for task
       */
      task_description: string | null
      /**
       * The actual task text, e.g. reading passage, listening script, etc
       */
      task_text: string | null
      task_type_id: number
      task_context_id: string
      task_form_id: number | null
      task_created_date: Date | null
      task_updated_date: Date | null
      deleted: boolean
      lesson_id: number
      gap_map: string | null
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `task_id`
     * const taskWithTask_idOnly = await prisma.task.findMany({ select: { task_id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `task_id`
     * const taskWithTask_idOnly = await prisma.task.createManyAndReturn({ 
     *   select: { task_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task_type<T extends TaskTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskTypeDefaultArgs<ExtArgs>>): Prisma__TaskTypeClient<$Result.GetResult<Prisma.$TaskTypePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    task_context<T extends TaskContextDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskContextDefaultArgs<ExtArgs>>): Prisma__TaskContextClient<$Result.GetResult<Prisma.$TaskContextPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    task_forms<T extends Task$task_formsArgs<ExtArgs> = {}>(args?: Subset<T, Task$task_formsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskFormPayload<ExtArgs>, T, "findMany"> | Null>
    task_options<T extends Task$task_optionsArgs<ExtArgs> = {}>(args?: Subset<T, Task$task_optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskOptionPayload<ExtArgs>, T, "findMany"> | Null>
    CourseTask<T extends Task$CourseTaskArgs<ExtArgs> = {}>(args?: Subset<T, Task$CourseTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseTaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */ 
  interface TaskFieldRefs {
    readonly task_id: FieldRef<"Task", 'Int'>
    readonly task_description: FieldRef<"Task", 'String'>
    readonly task_text: FieldRef<"Task", 'String'>
    readonly task_type_id: FieldRef<"Task", 'Int'>
    readonly task_context_id: FieldRef<"Task", 'String'>
    readonly task_form_id: FieldRef<"Task", 'Int'>
    readonly task_created_date: FieldRef<"Task", 'DateTime'>
    readonly task_updated_date: FieldRef<"Task", 'DateTime'>
    readonly deleted: FieldRef<"Task", 'Boolean'>
    readonly lesson_id: FieldRef<"Task", 'Int'>
    readonly gap_map: FieldRef<"Task", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
  }

  /**
   * Task.task_forms
   */
  export type Task$task_formsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskForm
     */
    select?: TaskFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFormInclude<ExtArgs> | null
    where?: TaskFormWhereInput
    orderBy?: TaskFormOrderByWithRelationInput | TaskFormOrderByWithRelationInput[]
    cursor?: TaskFormWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskFormScalarFieldEnum | TaskFormScalarFieldEnum[]
  }

  /**
   * Task.task_options
   */
  export type Task$task_optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOption
     */
    select?: TaskOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOptionInclude<ExtArgs> | null
    where?: TaskOptionWhereInput
    orderBy?: TaskOptionOrderByWithRelationInput | TaskOptionOrderByWithRelationInput[]
    cursor?: TaskOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskOptionScalarFieldEnum | TaskOptionScalarFieldEnum[]
  }

  /**
   * Task.CourseTask
   */
  export type Task$CourseTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseTask
     */
    select?: CourseTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseTaskInclude<ExtArgs> | null
    where?: CourseTaskWhereInput
    orderBy?: CourseTaskOrderByWithRelationInput | CourseTaskOrderByWithRelationInput[]
    cursor?: CourseTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseTaskScalarFieldEnum | CourseTaskScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model TaskForm
   */

  export type AggregateTaskForm = {
    _count: TaskFormCountAggregateOutputType | null
    _avg: TaskFormAvgAggregateOutputType | null
    _sum: TaskFormSumAggregateOutputType | null
    _min: TaskFormMinAggregateOutputType | null
    _max: TaskFormMaxAggregateOutputType | null
  }

  export type TaskFormAvgAggregateOutputType = {
    task_form_id: number | null
  }

  export type TaskFormSumAggregateOutputType = {
    task_form_id: number | null
  }

  export type TaskFormMinAggregateOutputType = {
    task_form_id: number | null
    task_form_name: string | null
    task_form_description: string | null
  }

  export type TaskFormMaxAggregateOutputType = {
    task_form_id: number | null
    task_form_name: string | null
    task_form_description: string | null
  }

  export type TaskFormCountAggregateOutputType = {
    task_form_id: number
    task_form_name: number
    task_form_description: number
    _all: number
  }


  export type TaskFormAvgAggregateInputType = {
    task_form_id?: true
  }

  export type TaskFormSumAggregateInputType = {
    task_form_id?: true
  }

  export type TaskFormMinAggregateInputType = {
    task_form_id?: true
    task_form_name?: true
    task_form_description?: true
  }

  export type TaskFormMaxAggregateInputType = {
    task_form_id?: true
    task_form_name?: true
    task_form_description?: true
  }

  export type TaskFormCountAggregateInputType = {
    task_form_id?: true
    task_form_name?: true
    task_form_description?: true
    _all?: true
  }

  export type TaskFormAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskForm to aggregate.
     */
    where?: TaskFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskForms to fetch.
     */
    orderBy?: TaskFormOrderByWithRelationInput | TaskFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskForms
    **/
    _count?: true | TaskFormCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskFormAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskFormSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskFormMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskFormMaxAggregateInputType
  }

  export type GetTaskFormAggregateType<T extends TaskFormAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskForm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskForm[P]>
      : GetScalarType<T[P], AggregateTaskForm[P]>
  }




  export type TaskFormGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskFormWhereInput
    orderBy?: TaskFormOrderByWithAggregationInput | TaskFormOrderByWithAggregationInput[]
    by: TaskFormScalarFieldEnum[] | TaskFormScalarFieldEnum
    having?: TaskFormScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskFormCountAggregateInputType | true
    _avg?: TaskFormAvgAggregateInputType
    _sum?: TaskFormSumAggregateInputType
    _min?: TaskFormMinAggregateInputType
    _max?: TaskFormMaxAggregateInputType
  }

  export type TaskFormGroupByOutputType = {
    task_form_id: number
    task_form_name: string
    task_form_description: string | null
    _count: TaskFormCountAggregateOutputType | null
    _avg: TaskFormAvgAggregateOutputType | null
    _sum: TaskFormSumAggregateOutputType | null
    _min: TaskFormMinAggregateOutputType | null
    _max: TaskFormMaxAggregateOutputType | null
  }

  type GetTaskFormGroupByPayload<T extends TaskFormGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskFormGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskFormGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskFormGroupByOutputType[P]>
            : GetScalarType<T[P], TaskFormGroupByOutputType[P]>
        }
      >
    >


  export type TaskFormSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    task_form_id?: boolean
    task_form_name?: boolean
    task_form_description?: boolean
    task?: boolean | TaskForm$taskArgs<ExtArgs>
    _count?: boolean | TaskFormCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskForm"]>

  export type TaskFormSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    task_form_id?: boolean
    task_form_name?: boolean
    task_form_description?: boolean
  }, ExtArgs["result"]["taskForm"]>

  export type TaskFormSelectScalar = {
    task_form_id?: boolean
    task_form_name?: boolean
    task_form_description?: boolean
  }

  export type TaskFormInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskForm$taskArgs<ExtArgs>
    _count?: boolean | TaskFormCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskFormIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TaskFormPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskForm"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      task_form_id: number
      task_form_name: string
      task_form_description: string | null
    }, ExtArgs["result"]["taskForm"]>
    composites: {}
  }

  type TaskFormGetPayload<S extends boolean | null | undefined | TaskFormDefaultArgs> = $Result.GetResult<Prisma.$TaskFormPayload, S>

  type TaskFormCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskFormFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskFormCountAggregateInputType | true
    }

  export interface TaskFormDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskForm'], meta: { name: 'TaskForm' } }
    /**
     * Find zero or one TaskForm that matches the filter.
     * @param {TaskFormFindUniqueArgs} args - Arguments to find a TaskForm
     * @example
     * // Get one TaskForm
     * const taskForm = await prisma.taskForm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFormFindUniqueArgs>(args: SelectSubset<T, TaskFormFindUniqueArgs<ExtArgs>>): Prisma__TaskFormClient<$Result.GetResult<Prisma.$TaskFormPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskForm that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskFormFindUniqueOrThrowArgs} args - Arguments to find a TaskForm
     * @example
     * // Get one TaskForm
     * const taskForm = await prisma.taskForm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFormFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFormFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskFormClient<$Result.GetResult<Prisma.$TaskFormPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskForm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormFindFirstArgs} args - Arguments to find a TaskForm
     * @example
     * // Get one TaskForm
     * const taskForm = await prisma.taskForm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFormFindFirstArgs>(args?: SelectSubset<T, TaskFormFindFirstArgs<ExtArgs>>): Prisma__TaskFormClient<$Result.GetResult<Prisma.$TaskFormPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskForm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormFindFirstOrThrowArgs} args - Arguments to find a TaskForm
     * @example
     * // Get one TaskForm
     * const taskForm = await prisma.taskForm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFormFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFormFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskFormClient<$Result.GetResult<Prisma.$TaskFormPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskForms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskForms
     * const taskForms = await prisma.taskForm.findMany()
     * 
     * // Get first 10 TaskForms
     * const taskForms = await prisma.taskForm.findMany({ take: 10 })
     * 
     * // Only select the `task_form_id`
     * const taskFormWithTask_form_idOnly = await prisma.taskForm.findMany({ select: { task_form_id: true } })
     * 
     */
    findMany<T extends TaskFormFindManyArgs>(args?: SelectSubset<T, TaskFormFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskFormPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskForm.
     * @param {TaskFormCreateArgs} args - Arguments to create a TaskForm.
     * @example
     * // Create one TaskForm
     * const TaskForm = await prisma.taskForm.create({
     *   data: {
     *     // ... data to create a TaskForm
     *   }
     * })
     * 
     */
    create<T extends TaskFormCreateArgs>(args: SelectSubset<T, TaskFormCreateArgs<ExtArgs>>): Prisma__TaskFormClient<$Result.GetResult<Prisma.$TaskFormPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskForms.
     * @param {TaskFormCreateManyArgs} args - Arguments to create many TaskForms.
     * @example
     * // Create many TaskForms
     * const taskForm = await prisma.taskForm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskFormCreateManyArgs>(args?: SelectSubset<T, TaskFormCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskForms and returns the data saved in the database.
     * @param {TaskFormCreateManyAndReturnArgs} args - Arguments to create many TaskForms.
     * @example
     * // Create many TaskForms
     * const taskForm = await prisma.taskForm.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskForms and only return the `task_form_id`
     * const taskFormWithTask_form_idOnly = await prisma.taskForm.createManyAndReturn({ 
     *   select: { task_form_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskFormCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskFormCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskFormPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskForm.
     * @param {TaskFormDeleteArgs} args - Arguments to delete one TaskForm.
     * @example
     * // Delete one TaskForm
     * const TaskForm = await prisma.taskForm.delete({
     *   where: {
     *     // ... filter to delete one TaskForm
     *   }
     * })
     * 
     */
    delete<T extends TaskFormDeleteArgs>(args: SelectSubset<T, TaskFormDeleteArgs<ExtArgs>>): Prisma__TaskFormClient<$Result.GetResult<Prisma.$TaskFormPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskForm.
     * @param {TaskFormUpdateArgs} args - Arguments to update one TaskForm.
     * @example
     * // Update one TaskForm
     * const taskForm = await prisma.taskForm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskFormUpdateArgs>(args: SelectSubset<T, TaskFormUpdateArgs<ExtArgs>>): Prisma__TaskFormClient<$Result.GetResult<Prisma.$TaskFormPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskForms.
     * @param {TaskFormDeleteManyArgs} args - Arguments to filter TaskForms to delete.
     * @example
     * // Delete a few TaskForms
     * const { count } = await prisma.taskForm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskFormDeleteManyArgs>(args?: SelectSubset<T, TaskFormDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskForms
     * const taskForm = await prisma.taskForm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskFormUpdateManyArgs>(args: SelectSubset<T, TaskFormUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskForm.
     * @param {TaskFormUpsertArgs} args - Arguments to update or create a TaskForm.
     * @example
     * // Update or create a TaskForm
     * const taskForm = await prisma.taskForm.upsert({
     *   create: {
     *     // ... data to create a TaskForm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskForm we want to update
     *   }
     * })
     */
    upsert<T extends TaskFormUpsertArgs>(args: SelectSubset<T, TaskFormUpsertArgs<ExtArgs>>): Prisma__TaskFormClient<$Result.GetResult<Prisma.$TaskFormPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskForms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormCountArgs} args - Arguments to filter TaskForms to count.
     * @example
     * // Count the number of TaskForms
     * const count = await prisma.taskForm.count({
     *   where: {
     *     // ... the filter for the TaskForms we want to count
     *   }
     * })
    **/
    count<T extends TaskFormCountArgs>(
      args?: Subset<T, TaskFormCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskFormCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskFormAggregateArgs>(args: Subset<T, TaskFormAggregateArgs>): Prisma.PrismaPromise<GetTaskFormAggregateType<T>>

    /**
     * Group by TaskForm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFormGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskFormGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskFormGroupByArgs['orderBy'] }
        : { orderBy?: TaskFormGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskFormGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskFormGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskForm model
   */
  readonly fields: TaskFormFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskForm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskFormClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskForm$taskArgs<ExtArgs> = {}>(args?: Subset<T, TaskForm$taskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskForm model
   */ 
  interface TaskFormFieldRefs {
    readonly task_form_id: FieldRef<"TaskForm", 'Int'>
    readonly task_form_name: FieldRef<"TaskForm", 'String'>
    readonly task_form_description: FieldRef<"TaskForm", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskForm findUnique
   */
  export type TaskFormFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskForm
     */
    select?: TaskFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFormInclude<ExtArgs> | null
    /**
     * Filter, which TaskForm to fetch.
     */
    where: TaskFormWhereUniqueInput
  }

  /**
   * TaskForm findUniqueOrThrow
   */
  export type TaskFormFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskForm
     */
    select?: TaskFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFormInclude<ExtArgs> | null
    /**
     * Filter, which TaskForm to fetch.
     */
    where: TaskFormWhereUniqueInput
  }

  /**
   * TaskForm findFirst
   */
  export type TaskFormFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskForm
     */
    select?: TaskFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFormInclude<ExtArgs> | null
    /**
     * Filter, which TaskForm to fetch.
     */
    where?: TaskFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskForms to fetch.
     */
    orderBy?: TaskFormOrderByWithRelationInput | TaskFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskForms.
     */
    cursor?: TaskFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskForms.
     */
    distinct?: TaskFormScalarFieldEnum | TaskFormScalarFieldEnum[]
  }

  /**
   * TaskForm findFirstOrThrow
   */
  export type TaskFormFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskForm
     */
    select?: TaskFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFormInclude<ExtArgs> | null
    /**
     * Filter, which TaskForm to fetch.
     */
    where?: TaskFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskForms to fetch.
     */
    orderBy?: TaskFormOrderByWithRelationInput | TaskFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskForms.
     */
    cursor?: TaskFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskForms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskForms.
     */
    distinct?: TaskFormScalarFieldEnum | TaskFormScalarFieldEnum[]
  }

  /**
   * TaskForm findMany
   */
  export type TaskFormFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskForm
     */
    select?: TaskFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFormInclude<ExtArgs> | null
    /**
     * Filter, which TaskForms to fetch.
     */
    where?: TaskFormWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskForms to fetch.
     */
    orderBy?: TaskFormOrderByWithRelationInput | TaskFormOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskForms.
     */
    cursor?: TaskFormWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskForms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskForms.
     */
    skip?: number
    distinct?: TaskFormScalarFieldEnum | TaskFormScalarFieldEnum[]
  }

  /**
   * TaskForm create
   */
  export type TaskFormCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskForm
     */
    select?: TaskFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFormInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskForm.
     */
    data: XOR<TaskFormCreateInput, TaskFormUncheckedCreateInput>
  }

  /**
   * TaskForm createMany
   */
  export type TaskFormCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskForms.
     */
    data: TaskFormCreateManyInput | TaskFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskForm createManyAndReturn
   */
  export type TaskFormCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskForm
     */
    select?: TaskFormSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskForms.
     */
    data: TaskFormCreateManyInput | TaskFormCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskForm update
   */
  export type TaskFormUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskForm
     */
    select?: TaskFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFormInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskForm.
     */
    data: XOR<TaskFormUpdateInput, TaskFormUncheckedUpdateInput>
    /**
     * Choose, which TaskForm to update.
     */
    where: TaskFormWhereUniqueInput
  }

  /**
   * TaskForm updateMany
   */
  export type TaskFormUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskForms.
     */
    data: XOR<TaskFormUpdateManyMutationInput, TaskFormUncheckedUpdateManyInput>
    /**
     * Filter which TaskForms to update
     */
    where?: TaskFormWhereInput
  }

  /**
   * TaskForm upsert
   */
  export type TaskFormUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskForm
     */
    select?: TaskFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFormInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskForm to update in case it exists.
     */
    where: TaskFormWhereUniqueInput
    /**
     * In case the TaskForm found by the `where` argument doesn't exist, create a new TaskForm with this data.
     */
    create: XOR<TaskFormCreateInput, TaskFormUncheckedCreateInput>
    /**
     * In case the TaskForm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskFormUpdateInput, TaskFormUncheckedUpdateInput>
  }

  /**
   * TaskForm delete
   */
  export type TaskFormDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskForm
     */
    select?: TaskFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFormInclude<ExtArgs> | null
    /**
     * Filter which TaskForm to delete.
     */
    where: TaskFormWhereUniqueInput
  }

  /**
   * TaskForm deleteMany
   */
  export type TaskFormDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskForms to delete
     */
    where?: TaskFormWhereInput
  }

  /**
   * TaskForm.task
   */
  export type TaskForm$taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * TaskForm without action
   */
  export type TaskFormDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskForm
     */
    select?: TaskFormSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskFormInclude<ExtArgs> | null
  }


  /**
   * Model TaskContext
   */

  export type AggregateTaskContext = {
    _count: TaskContextCountAggregateOutputType | null
    _min: TaskContextMinAggregateOutputType | null
    _max: TaskContextMaxAggregateOutputType | null
  }

  export type TaskContextMinAggregateOutputType = {
    task_context_id: string | null
    task_context_name: string | null
    task_context_description: string | null
  }

  export type TaskContextMaxAggregateOutputType = {
    task_context_id: string | null
    task_context_name: string | null
    task_context_description: string | null
  }

  export type TaskContextCountAggregateOutputType = {
    task_context_id: number
    task_context_name: number
    task_context_description: number
    _all: number
  }


  export type TaskContextMinAggregateInputType = {
    task_context_id?: true
    task_context_name?: true
    task_context_description?: true
  }

  export type TaskContextMaxAggregateInputType = {
    task_context_id?: true
    task_context_name?: true
    task_context_description?: true
  }

  export type TaskContextCountAggregateInputType = {
    task_context_id?: true
    task_context_name?: true
    task_context_description?: true
    _all?: true
  }

  export type TaskContextAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskContext to aggregate.
     */
    where?: TaskContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskContexts to fetch.
     */
    orderBy?: TaskContextOrderByWithRelationInput | TaskContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskContexts
    **/
    _count?: true | TaskContextCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskContextMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskContextMaxAggregateInputType
  }

  export type GetTaskContextAggregateType<T extends TaskContextAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskContext]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskContext[P]>
      : GetScalarType<T[P], AggregateTaskContext[P]>
  }




  export type TaskContextGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskContextWhereInput
    orderBy?: TaskContextOrderByWithAggregationInput | TaskContextOrderByWithAggregationInput[]
    by: TaskContextScalarFieldEnum[] | TaskContextScalarFieldEnum
    having?: TaskContextScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskContextCountAggregateInputType | true
    _min?: TaskContextMinAggregateInputType
    _max?: TaskContextMaxAggregateInputType
  }

  export type TaskContextGroupByOutputType = {
    task_context_id: string
    task_context_name: string
    task_context_description: string | null
    _count: TaskContextCountAggregateOutputType | null
    _min: TaskContextMinAggregateOutputType | null
    _max: TaskContextMaxAggregateOutputType | null
  }

  type GetTaskContextGroupByPayload<T extends TaskContextGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskContextGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskContextGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskContextGroupByOutputType[P]>
            : GetScalarType<T[P], TaskContextGroupByOutputType[P]>
        }
      >
    >


  export type TaskContextSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    task_context_id?: boolean
    task_context_name?: boolean
    task_context_description?: boolean
    task?: boolean | TaskContext$taskArgs<ExtArgs>
    _count?: boolean | TaskContextCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskContext"]>

  export type TaskContextSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    task_context_id?: boolean
    task_context_name?: boolean
    task_context_description?: boolean
  }, ExtArgs["result"]["taskContext"]>

  export type TaskContextSelectScalar = {
    task_context_id?: boolean
    task_context_name?: boolean
    task_context_description?: boolean
  }

  export type TaskContextInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskContext$taskArgs<ExtArgs>
    _count?: boolean | TaskContextCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskContextIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TaskContextPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskContext"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      task_context_id: string
      task_context_name: string
      task_context_description: string | null
    }, ExtArgs["result"]["taskContext"]>
    composites: {}
  }

  type TaskContextGetPayload<S extends boolean | null | undefined | TaskContextDefaultArgs> = $Result.GetResult<Prisma.$TaskContextPayload, S>

  type TaskContextCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskContextFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskContextCountAggregateInputType | true
    }

  export interface TaskContextDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskContext'], meta: { name: 'TaskContext' } }
    /**
     * Find zero or one TaskContext that matches the filter.
     * @param {TaskContextFindUniqueArgs} args - Arguments to find a TaskContext
     * @example
     * // Get one TaskContext
     * const taskContext = await prisma.taskContext.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskContextFindUniqueArgs>(args: SelectSubset<T, TaskContextFindUniqueArgs<ExtArgs>>): Prisma__TaskContextClient<$Result.GetResult<Prisma.$TaskContextPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskContext that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskContextFindUniqueOrThrowArgs} args - Arguments to find a TaskContext
     * @example
     * // Get one TaskContext
     * const taskContext = await prisma.taskContext.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskContextFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskContextFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskContextClient<$Result.GetResult<Prisma.$TaskContextPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskContext that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskContextFindFirstArgs} args - Arguments to find a TaskContext
     * @example
     * // Get one TaskContext
     * const taskContext = await prisma.taskContext.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskContextFindFirstArgs>(args?: SelectSubset<T, TaskContextFindFirstArgs<ExtArgs>>): Prisma__TaskContextClient<$Result.GetResult<Prisma.$TaskContextPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskContext that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskContextFindFirstOrThrowArgs} args - Arguments to find a TaskContext
     * @example
     * // Get one TaskContext
     * const taskContext = await prisma.taskContext.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskContextFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskContextFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskContextClient<$Result.GetResult<Prisma.$TaskContextPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskContexts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskContextFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskContexts
     * const taskContexts = await prisma.taskContext.findMany()
     * 
     * // Get first 10 TaskContexts
     * const taskContexts = await prisma.taskContext.findMany({ take: 10 })
     * 
     * // Only select the `task_context_id`
     * const taskContextWithTask_context_idOnly = await prisma.taskContext.findMany({ select: { task_context_id: true } })
     * 
     */
    findMany<T extends TaskContextFindManyArgs>(args?: SelectSubset<T, TaskContextFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskContextPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskContext.
     * @param {TaskContextCreateArgs} args - Arguments to create a TaskContext.
     * @example
     * // Create one TaskContext
     * const TaskContext = await prisma.taskContext.create({
     *   data: {
     *     // ... data to create a TaskContext
     *   }
     * })
     * 
     */
    create<T extends TaskContextCreateArgs>(args: SelectSubset<T, TaskContextCreateArgs<ExtArgs>>): Prisma__TaskContextClient<$Result.GetResult<Prisma.$TaskContextPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskContexts.
     * @param {TaskContextCreateManyArgs} args - Arguments to create many TaskContexts.
     * @example
     * // Create many TaskContexts
     * const taskContext = await prisma.taskContext.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskContextCreateManyArgs>(args?: SelectSubset<T, TaskContextCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskContexts and returns the data saved in the database.
     * @param {TaskContextCreateManyAndReturnArgs} args - Arguments to create many TaskContexts.
     * @example
     * // Create many TaskContexts
     * const taskContext = await prisma.taskContext.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskContexts and only return the `task_context_id`
     * const taskContextWithTask_context_idOnly = await prisma.taskContext.createManyAndReturn({ 
     *   select: { task_context_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskContextCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskContextCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskContextPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskContext.
     * @param {TaskContextDeleteArgs} args - Arguments to delete one TaskContext.
     * @example
     * // Delete one TaskContext
     * const TaskContext = await prisma.taskContext.delete({
     *   where: {
     *     // ... filter to delete one TaskContext
     *   }
     * })
     * 
     */
    delete<T extends TaskContextDeleteArgs>(args: SelectSubset<T, TaskContextDeleteArgs<ExtArgs>>): Prisma__TaskContextClient<$Result.GetResult<Prisma.$TaskContextPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskContext.
     * @param {TaskContextUpdateArgs} args - Arguments to update one TaskContext.
     * @example
     * // Update one TaskContext
     * const taskContext = await prisma.taskContext.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskContextUpdateArgs>(args: SelectSubset<T, TaskContextUpdateArgs<ExtArgs>>): Prisma__TaskContextClient<$Result.GetResult<Prisma.$TaskContextPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskContexts.
     * @param {TaskContextDeleteManyArgs} args - Arguments to filter TaskContexts to delete.
     * @example
     * // Delete a few TaskContexts
     * const { count } = await prisma.taskContext.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskContextDeleteManyArgs>(args?: SelectSubset<T, TaskContextDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskContexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskContextUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskContexts
     * const taskContext = await prisma.taskContext.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskContextUpdateManyArgs>(args: SelectSubset<T, TaskContextUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskContext.
     * @param {TaskContextUpsertArgs} args - Arguments to update or create a TaskContext.
     * @example
     * // Update or create a TaskContext
     * const taskContext = await prisma.taskContext.upsert({
     *   create: {
     *     // ... data to create a TaskContext
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskContext we want to update
     *   }
     * })
     */
    upsert<T extends TaskContextUpsertArgs>(args: SelectSubset<T, TaskContextUpsertArgs<ExtArgs>>): Prisma__TaskContextClient<$Result.GetResult<Prisma.$TaskContextPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskContexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskContextCountArgs} args - Arguments to filter TaskContexts to count.
     * @example
     * // Count the number of TaskContexts
     * const count = await prisma.taskContext.count({
     *   where: {
     *     // ... the filter for the TaskContexts we want to count
     *   }
     * })
    **/
    count<T extends TaskContextCountArgs>(
      args?: Subset<T, TaskContextCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskContextCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskContext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskContextAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskContextAggregateArgs>(args: Subset<T, TaskContextAggregateArgs>): Prisma.PrismaPromise<GetTaskContextAggregateType<T>>

    /**
     * Group by TaskContext.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskContextGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskContextGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskContextGroupByArgs['orderBy'] }
        : { orderBy?: TaskContextGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskContextGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskContextGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskContext model
   */
  readonly fields: TaskContextFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskContext.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskContextClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskContext$taskArgs<ExtArgs> = {}>(args?: Subset<T, TaskContext$taskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskContext model
   */ 
  interface TaskContextFieldRefs {
    readonly task_context_id: FieldRef<"TaskContext", 'String'>
    readonly task_context_name: FieldRef<"TaskContext", 'String'>
    readonly task_context_description: FieldRef<"TaskContext", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskContext findUnique
   */
  export type TaskContextFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskContext
     */
    select?: TaskContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskContextInclude<ExtArgs> | null
    /**
     * Filter, which TaskContext to fetch.
     */
    where: TaskContextWhereUniqueInput
  }

  /**
   * TaskContext findUniqueOrThrow
   */
  export type TaskContextFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskContext
     */
    select?: TaskContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskContextInclude<ExtArgs> | null
    /**
     * Filter, which TaskContext to fetch.
     */
    where: TaskContextWhereUniqueInput
  }

  /**
   * TaskContext findFirst
   */
  export type TaskContextFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskContext
     */
    select?: TaskContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskContextInclude<ExtArgs> | null
    /**
     * Filter, which TaskContext to fetch.
     */
    where?: TaskContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskContexts to fetch.
     */
    orderBy?: TaskContextOrderByWithRelationInput | TaskContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskContexts.
     */
    cursor?: TaskContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskContexts.
     */
    distinct?: TaskContextScalarFieldEnum | TaskContextScalarFieldEnum[]
  }

  /**
   * TaskContext findFirstOrThrow
   */
  export type TaskContextFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskContext
     */
    select?: TaskContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskContextInclude<ExtArgs> | null
    /**
     * Filter, which TaskContext to fetch.
     */
    where?: TaskContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskContexts to fetch.
     */
    orderBy?: TaskContextOrderByWithRelationInput | TaskContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskContexts.
     */
    cursor?: TaskContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskContexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskContexts.
     */
    distinct?: TaskContextScalarFieldEnum | TaskContextScalarFieldEnum[]
  }

  /**
   * TaskContext findMany
   */
  export type TaskContextFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskContext
     */
    select?: TaskContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskContextInclude<ExtArgs> | null
    /**
     * Filter, which TaskContexts to fetch.
     */
    where?: TaskContextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskContexts to fetch.
     */
    orderBy?: TaskContextOrderByWithRelationInput | TaskContextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskContexts.
     */
    cursor?: TaskContextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskContexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskContexts.
     */
    skip?: number
    distinct?: TaskContextScalarFieldEnum | TaskContextScalarFieldEnum[]
  }

  /**
   * TaskContext create
   */
  export type TaskContextCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskContext
     */
    select?: TaskContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskContextInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskContext.
     */
    data: XOR<TaskContextCreateInput, TaskContextUncheckedCreateInput>
  }

  /**
   * TaskContext createMany
   */
  export type TaskContextCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskContexts.
     */
    data: TaskContextCreateManyInput | TaskContextCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskContext createManyAndReturn
   */
  export type TaskContextCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskContext
     */
    select?: TaskContextSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskContexts.
     */
    data: TaskContextCreateManyInput | TaskContextCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskContext update
   */
  export type TaskContextUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskContext
     */
    select?: TaskContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskContextInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskContext.
     */
    data: XOR<TaskContextUpdateInput, TaskContextUncheckedUpdateInput>
    /**
     * Choose, which TaskContext to update.
     */
    where: TaskContextWhereUniqueInput
  }

  /**
   * TaskContext updateMany
   */
  export type TaskContextUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskContexts.
     */
    data: XOR<TaskContextUpdateManyMutationInput, TaskContextUncheckedUpdateManyInput>
    /**
     * Filter which TaskContexts to update
     */
    where?: TaskContextWhereInput
  }

  /**
   * TaskContext upsert
   */
  export type TaskContextUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskContext
     */
    select?: TaskContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskContextInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskContext to update in case it exists.
     */
    where: TaskContextWhereUniqueInput
    /**
     * In case the TaskContext found by the `where` argument doesn't exist, create a new TaskContext with this data.
     */
    create: XOR<TaskContextCreateInput, TaskContextUncheckedCreateInput>
    /**
     * In case the TaskContext was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskContextUpdateInput, TaskContextUncheckedUpdateInput>
  }

  /**
   * TaskContext delete
   */
  export type TaskContextDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskContext
     */
    select?: TaskContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskContextInclude<ExtArgs> | null
    /**
     * Filter which TaskContext to delete.
     */
    where: TaskContextWhereUniqueInput
  }

  /**
   * TaskContext deleteMany
   */
  export type TaskContextDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskContexts to delete
     */
    where?: TaskContextWhereInput
  }

  /**
   * TaskContext.task
   */
  export type TaskContext$taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * TaskContext without action
   */
  export type TaskContextDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskContext
     */
    select?: TaskContextSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskContextInclude<ExtArgs> | null
  }


  /**
   * Model TaskOption
   */

  export type AggregateTaskOption = {
    _count: TaskOptionCountAggregateOutputType | null
    _avg: TaskOptionAvgAggregateOutputType | null
    _sum: TaskOptionSumAggregateOutputType | null
    _min: TaskOptionMinAggregateOutputType | null
    _max: TaskOptionMaxAggregateOutputType | null
  }

  export type TaskOptionAvgAggregateOutputType = {
    task_option_id: number | null
    task_id: number | null
    task_option_order: number | null
  }

  export type TaskOptionSumAggregateOutputType = {
    task_option_id: number | null
    task_id: number | null
    task_option_order: number | null
  }

  export type TaskOptionMinAggregateOutputType = {
    task_option_id: number | null
    task_id: number | null
    task_option_text: string | null
    task_option_order: number | null
    is_correct: boolean | null
  }

  export type TaskOptionMaxAggregateOutputType = {
    task_option_id: number | null
    task_id: number | null
    task_option_text: string | null
    task_option_order: number | null
    is_correct: boolean | null
  }

  export type TaskOptionCountAggregateOutputType = {
    task_option_id: number
    task_id: number
    task_option_text: number
    task_option_order: number
    is_correct: number
    _all: number
  }


  export type TaskOptionAvgAggregateInputType = {
    task_option_id?: true
    task_id?: true
    task_option_order?: true
  }

  export type TaskOptionSumAggregateInputType = {
    task_option_id?: true
    task_id?: true
    task_option_order?: true
  }

  export type TaskOptionMinAggregateInputType = {
    task_option_id?: true
    task_id?: true
    task_option_text?: true
    task_option_order?: true
    is_correct?: true
  }

  export type TaskOptionMaxAggregateInputType = {
    task_option_id?: true
    task_id?: true
    task_option_text?: true
    task_option_order?: true
    is_correct?: true
  }

  export type TaskOptionCountAggregateInputType = {
    task_option_id?: true
    task_id?: true
    task_option_text?: true
    task_option_order?: true
    is_correct?: true
    _all?: true
  }

  export type TaskOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskOption to aggregate.
     */
    where?: TaskOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskOptions to fetch.
     */
    orderBy?: TaskOptionOrderByWithRelationInput | TaskOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskOptions
    **/
    _count?: true | TaskOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskOptionMaxAggregateInputType
  }

  export type GetTaskOptionAggregateType<T extends TaskOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskOption[P]>
      : GetScalarType<T[P], AggregateTaskOption[P]>
  }




  export type TaskOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskOptionWhereInput
    orderBy?: TaskOptionOrderByWithAggregationInput | TaskOptionOrderByWithAggregationInput[]
    by: TaskOptionScalarFieldEnum[] | TaskOptionScalarFieldEnum
    having?: TaskOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskOptionCountAggregateInputType | true
    _avg?: TaskOptionAvgAggregateInputType
    _sum?: TaskOptionSumAggregateInputType
    _min?: TaskOptionMinAggregateInputType
    _max?: TaskOptionMaxAggregateInputType
  }

  export type TaskOptionGroupByOutputType = {
    task_option_id: number
    task_id: number
    task_option_text: string
    task_option_order: number | null
    is_correct: boolean
    _count: TaskOptionCountAggregateOutputType | null
    _avg: TaskOptionAvgAggregateOutputType | null
    _sum: TaskOptionSumAggregateOutputType | null
    _min: TaskOptionMinAggregateOutputType | null
    _max: TaskOptionMaxAggregateOutputType | null
  }

  type GetTaskOptionGroupByPayload<T extends TaskOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskOptionGroupByOutputType[P]>
            : GetScalarType<T[P], TaskOptionGroupByOutputType[P]>
        }
      >
    >


  export type TaskOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    task_option_id?: boolean
    task_id?: boolean
    task_option_text?: boolean
    task_option_order?: boolean
    is_correct?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskOption"]>

  export type TaskOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    task_option_id?: boolean
    task_id?: boolean
    task_option_text?: boolean
    task_option_order?: boolean
    is_correct?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskOption"]>

  export type TaskOptionSelectScalar = {
    task_option_id?: boolean
    task_id?: boolean
    task_option_text?: boolean
    task_option_order?: boolean
    is_correct?: boolean
  }

  export type TaskOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskOption"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      task_option_id: number
      task_id: number
      task_option_text: string
      task_option_order: number | null
      is_correct: boolean
    }, ExtArgs["result"]["taskOption"]>
    composites: {}
  }

  type TaskOptionGetPayload<S extends boolean | null | undefined | TaskOptionDefaultArgs> = $Result.GetResult<Prisma.$TaskOptionPayload, S>

  type TaskOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskOptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskOptionCountAggregateInputType | true
    }

  export interface TaskOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskOption'], meta: { name: 'TaskOption' } }
    /**
     * Find zero or one TaskOption that matches the filter.
     * @param {TaskOptionFindUniqueArgs} args - Arguments to find a TaskOption
     * @example
     * // Get one TaskOption
     * const taskOption = await prisma.taskOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskOptionFindUniqueArgs>(args: SelectSubset<T, TaskOptionFindUniqueArgs<ExtArgs>>): Prisma__TaskOptionClient<$Result.GetResult<Prisma.$TaskOptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskOption that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskOptionFindUniqueOrThrowArgs} args - Arguments to find a TaskOption
     * @example
     * // Get one TaskOption
     * const taskOption = await prisma.taskOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskOptionClient<$Result.GetResult<Prisma.$TaskOptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOptionFindFirstArgs} args - Arguments to find a TaskOption
     * @example
     * // Get one TaskOption
     * const taskOption = await prisma.taskOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskOptionFindFirstArgs>(args?: SelectSubset<T, TaskOptionFindFirstArgs<ExtArgs>>): Prisma__TaskOptionClient<$Result.GetResult<Prisma.$TaskOptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOptionFindFirstOrThrowArgs} args - Arguments to find a TaskOption
     * @example
     * // Get one TaskOption
     * const taskOption = await prisma.taskOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskOptionClient<$Result.GetResult<Prisma.$TaskOptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskOptions
     * const taskOptions = await prisma.taskOption.findMany()
     * 
     * // Get first 10 TaskOptions
     * const taskOptions = await prisma.taskOption.findMany({ take: 10 })
     * 
     * // Only select the `task_option_id`
     * const taskOptionWithTask_option_idOnly = await prisma.taskOption.findMany({ select: { task_option_id: true } })
     * 
     */
    findMany<T extends TaskOptionFindManyArgs>(args?: SelectSubset<T, TaskOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskOptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskOption.
     * @param {TaskOptionCreateArgs} args - Arguments to create a TaskOption.
     * @example
     * // Create one TaskOption
     * const TaskOption = await prisma.taskOption.create({
     *   data: {
     *     // ... data to create a TaskOption
     *   }
     * })
     * 
     */
    create<T extends TaskOptionCreateArgs>(args: SelectSubset<T, TaskOptionCreateArgs<ExtArgs>>): Prisma__TaskOptionClient<$Result.GetResult<Prisma.$TaskOptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskOptions.
     * @param {TaskOptionCreateManyArgs} args - Arguments to create many TaskOptions.
     * @example
     * // Create many TaskOptions
     * const taskOption = await prisma.taskOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskOptionCreateManyArgs>(args?: SelectSubset<T, TaskOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskOptions and returns the data saved in the database.
     * @param {TaskOptionCreateManyAndReturnArgs} args - Arguments to create many TaskOptions.
     * @example
     * // Create many TaskOptions
     * const taskOption = await prisma.taskOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskOptions and only return the `task_option_id`
     * const taskOptionWithTask_option_idOnly = await prisma.taskOption.createManyAndReturn({ 
     *   select: { task_option_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskOptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskOption.
     * @param {TaskOptionDeleteArgs} args - Arguments to delete one TaskOption.
     * @example
     * // Delete one TaskOption
     * const TaskOption = await prisma.taskOption.delete({
     *   where: {
     *     // ... filter to delete one TaskOption
     *   }
     * })
     * 
     */
    delete<T extends TaskOptionDeleteArgs>(args: SelectSubset<T, TaskOptionDeleteArgs<ExtArgs>>): Prisma__TaskOptionClient<$Result.GetResult<Prisma.$TaskOptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskOption.
     * @param {TaskOptionUpdateArgs} args - Arguments to update one TaskOption.
     * @example
     * // Update one TaskOption
     * const taskOption = await prisma.taskOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskOptionUpdateArgs>(args: SelectSubset<T, TaskOptionUpdateArgs<ExtArgs>>): Prisma__TaskOptionClient<$Result.GetResult<Prisma.$TaskOptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskOptions.
     * @param {TaskOptionDeleteManyArgs} args - Arguments to filter TaskOptions to delete.
     * @example
     * // Delete a few TaskOptions
     * const { count } = await prisma.taskOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskOptionDeleteManyArgs>(args?: SelectSubset<T, TaskOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskOptions
     * const taskOption = await prisma.taskOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskOptionUpdateManyArgs>(args: SelectSubset<T, TaskOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskOption.
     * @param {TaskOptionUpsertArgs} args - Arguments to update or create a TaskOption.
     * @example
     * // Update or create a TaskOption
     * const taskOption = await prisma.taskOption.upsert({
     *   create: {
     *     // ... data to create a TaskOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskOption we want to update
     *   }
     * })
     */
    upsert<T extends TaskOptionUpsertArgs>(args: SelectSubset<T, TaskOptionUpsertArgs<ExtArgs>>): Prisma__TaskOptionClient<$Result.GetResult<Prisma.$TaskOptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOptionCountArgs} args - Arguments to filter TaskOptions to count.
     * @example
     * // Count the number of TaskOptions
     * const count = await prisma.taskOption.count({
     *   where: {
     *     // ... the filter for the TaskOptions we want to count
     *   }
     * })
    **/
    count<T extends TaskOptionCountArgs>(
      args?: Subset<T, TaskOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskOptionAggregateArgs>(args: Subset<T, TaskOptionAggregateArgs>): Prisma.PrismaPromise<GetTaskOptionAggregateType<T>>

    /**
     * Group by TaskOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskOptionGroupByArgs['orderBy'] }
        : { orderBy?: TaskOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskOption model
   */
  readonly fields: TaskOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskOption model
   */ 
  interface TaskOptionFieldRefs {
    readonly task_option_id: FieldRef<"TaskOption", 'Int'>
    readonly task_id: FieldRef<"TaskOption", 'Int'>
    readonly task_option_text: FieldRef<"TaskOption", 'String'>
    readonly task_option_order: FieldRef<"TaskOption", 'Int'>
    readonly is_correct: FieldRef<"TaskOption", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TaskOption findUnique
   */
  export type TaskOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOption
     */
    select?: TaskOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOptionInclude<ExtArgs> | null
    /**
     * Filter, which TaskOption to fetch.
     */
    where: TaskOptionWhereUniqueInput
  }

  /**
   * TaskOption findUniqueOrThrow
   */
  export type TaskOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOption
     */
    select?: TaskOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOptionInclude<ExtArgs> | null
    /**
     * Filter, which TaskOption to fetch.
     */
    where: TaskOptionWhereUniqueInput
  }

  /**
   * TaskOption findFirst
   */
  export type TaskOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOption
     */
    select?: TaskOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOptionInclude<ExtArgs> | null
    /**
     * Filter, which TaskOption to fetch.
     */
    where?: TaskOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskOptions to fetch.
     */
    orderBy?: TaskOptionOrderByWithRelationInput | TaskOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskOptions.
     */
    cursor?: TaskOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskOptions.
     */
    distinct?: TaskOptionScalarFieldEnum | TaskOptionScalarFieldEnum[]
  }

  /**
   * TaskOption findFirstOrThrow
   */
  export type TaskOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOption
     */
    select?: TaskOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOptionInclude<ExtArgs> | null
    /**
     * Filter, which TaskOption to fetch.
     */
    where?: TaskOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskOptions to fetch.
     */
    orderBy?: TaskOptionOrderByWithRelationInput | TaskOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskOptions.
     */
    cursor?: TaskOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskOptions.
     */
    distinct?: TaskOptionScalarFieldEnum | TaskOptionScalarFieldEnum[]
  }

  /**
   * TaskOption findMany
   */
  export type TaskOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOption
     */
    select?: TaskOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOptionInclude<ExtArgs> | null
    /**
     * Filter, which TaskOptions to fetch.
     */
    where?: TaskOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskOptions to fetch.
     */
    orderBy?: TaskOptionOrderByWithRelationInput | TaskOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskOptions.
     */
    cursor?: TaskOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskOptions.
     */
    skip?: number
    distinct?: TaskOptionScalarFieldEnum | TaskOptionScalarFieldEnum[]
  }

  /**
   * TaskOption create
   */
  export type TaskOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOption
     */
    select?: TaskOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskOption.
     */
    data: XOR<TaskOptionCreateInput, TaskOptionUncheckedCreateInput>
  }

  /**
   * TaskOption createMany
   */
  export type TaskOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskOptions.
     */
    data: TaskOptionCreateManyInput | TaskOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskOption createManyAndReturn
   */
  export type TaskOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOption
     */
    select?: TaskOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskOptions.
     */
    data: TaskOptionCreateManyInput | TaskOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskOption update
   */
  export type TaskOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOption
     */
    select?: TaskOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskOption.
     */
    data: XOR<TaskOptionUpdateInput, TaskOptionUncheckedUpdateInput>
    /**
     * Choose, which TaskOption to update.
     */
    where: TaskOptionWhereUniqueInput
  }

  /**
   * TaskOption updateMany
   */
  export type TaskOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskOptions.
     */
    data: XOR<TaskOptionUpdateManyMutationInput, TaskOptionUncheckedUpdateManyInput>
    /**
     * Filter which TaskOptions to update
     */
    where?: TaskOptionWhereInput
  }

  /**
   * TaskOption upsert
   */
  export type TaskOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOption
     */
    select?: TaskOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskOption to update in case it exists.
     */
    where: TaskOptionWhereUniqueInput
    /**
     * In case the TaskOption found by the `where` argument doesn't exist, create a new TaskOption with this data.
     */
    create: XOR<TaskOptionCreateInput, TaskOptionUncheckedCreateInput>
    /**
     * In case the TaskOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskOptionUpdateInput, TaskOptionUncheckedUpdateInput>
  }

  /**
   * TaskOption delete
   */
  export type TaskOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOption
     */
    select?: TaskOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOptionInclude<ExtArgs> | null
    /**
     * Filter which TaskOption to delete.
     */
    where: TaskOptionWhereUniqueInput
  }

  /**
   * TaskOption deleteMany
   */
  export type TaskOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskOptions to delete
     */
    where?: TaskOptionWhereInput
  }

  /**
   * TaskOption without action
   */
  export type TaskOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskOption
     */
    select?: TaskOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskOptionInclude<ExtArgs> | null
  }


  /**
   * Model TaskType
   */

  export type AggregateTaskType = {
    _count: TaskTypeCountAggregateOutputType | null
    _avg: TaskTypeAvgAggregateOutputType | null
    _sum: TaskTypeSumAggregateOutputType | null
    _min: TaskTypeMinAggregateOutputType | null
    _max: TaskTypeMaxAggregateOutputType | null
  }

  export type TaskTypeAvgAggregateOutputType = {
    task_type_id: number | null
  }

  export type TaskTypeSumAggregateOutputType = {
    task_type_id: number | null
  }

  export type TaskTypeMinAggregateOutputType = {
    task_type_id: number | null
    task_type_name: string | null
    task_type_description: string | null
  }

  export type TaskTypeMaxAggregateOutputType = {
    task_type_id: number | null
    task_type_name: string | null
    task_type_description: string | null
  }

  export type TaskTypeCountAggregateOutputType = {
    task_type_id: number
    task_type_name: number
    task_type_description: number
    _all: number
  }


  export type TaskTypeAvgAggregateInputType = {
    task_type_id?: true
  }

  export type TaskTypeSumAggregateInputType = {
    task_type_id?: true
  }

  export type TaskTypeMinAggregateInputType = {
    task_type_id?: true
    task_type_name?: true
    task_type_description?: true
  }

  export type TaskTypeMaxAggregateInputType = {
    task_type_id?: true
    task_type_name?: true
    task_type_description?: true
  }

  export type TaskTypeCountAggregateInputType = {
    task_type_id?: true
    task_type_name?: true
    task_type_description?: true
    _all?: true
  }

  export type TaskTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskType to aggregate.
     */
    where?: TaskTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTypes to fetch.
     */
    orderBy?: TaskTypeOrderByWithRelationInput | TaskTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskTypes
    **/
    _count?: true | TaskTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskTypeMaxAggregateInputType
  }

  export type GetTaskTypeAggregateType<T extends TaskTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskType[P]>
      : GetScalarType<T[P], AggregateTaskType[P]>
  }




  export type TaskTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskTypeWhereInput
    orderBy?: TaskTypeOrderByWithAggregationInput | TaskTypeOrderByWithAggregationInput[]
    by: TaskTypeScalarFieldEnum[] | TaskTypeScalarFieldEnum
    having?: TaskTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskTypeCountAggregateInputType | true
    _avg?: TaskTypeAvgAggregateInputType
    _sum?: TaskTypeSumAggregateInputType
    _min?: TaskTypeMinAggregateInputType
    _max?: TaskTypeMaxAggregateInputType
  }

  export type TaskTypeGroupByOutputType = {
    task_type_id: number
    task_type_name: string
    task_type_description: string | null
    _count: TaskTypeCountAggregateOutputType | null
    _avg: TaskTypeAvgAggregateOutputType | null
    _sum: TaskTypeSumAggregateOutputType | null
    _min: TaskTypeMinAggregateOutputType | null
    _max: TaskTypeMaxAggregateOutputType | null
  }

  type GetTaskTypeGroupByPayload<T extends TaskTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskTypeGroupByOutputType[P]>
            : GetScalarType<T[P], TaskTypeGroupByOutputType[P]>
        }
      >
    >


  export type TaskTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    task_type_id?: boolean
    task_type_name?: boolean
    task_type_description?: boolean
    task?: boolean | TaskType$taskArgs<ExtArgs>
    _count?: boolean | TaskTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskType"]>

  export type TaskTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    task_type_id?: boolean
    task_type_name?: boolean
    task_type_description?: boolean
  }, ExtArgs["result"]["taskType"]>

  export type TaskTypeSelectScalar = {
    task_type_id?: boolean
    task_type_name?: boolean
    task_type_description?: boolean
  }

  export type TaskTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskType$taskArgs<ExtArgs>
    _count?: boolean | TaskTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TaskTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskType"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      task_type_id: number
      task_type_name: string
      task_type_description: string | null
    }, ExtArgs["result"]["taskType"]>
    composites: {}
  }

  type TaskTypeGetPayload<S extends boolean | null | undefined | TaskTypeDefaultArgs> = $Result.GetResult<Prisma.$TaskTypePayload, S>

  type TaskTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TaskTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TaskTypeCountAggregateInputType | true
    }

  export interface TaskTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskType'], meta: { name: 'TaskType' } }
    /**
     * Find zero or one TaskType that matches the filter.
     * @param {TaskTypeFindUniqueArgs} args - Arguments to find a TaskType
     * @example
     * // Get one TaskType
     * const taskType = await prisma.taskType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskTypeFindUniqueArgs>(args: SelectSubset<T, TaskTypeFindUniqueArgs<ExtArgs>>): Prisma__TaskTypeClient<$Result.GetResult<Prisma.$TaskTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TaskType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TaskTypeFindUniqueOrThrowArgs} args - Arguments to find a TaskType
     * @example
     * // Get one TaskType
     * const taskType = await prisma.taskType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskTypeClient<$Result.GetResult<Prisma.$TaskTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TaskType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTypeFindFirstArgs} args - Arguments to find a TaskType
     * @example
     * // Get one TaskType
     * const taskType = await prisma.taskType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskTypeFindFirstArgs>(args?: SelectSubset<T, TaskTypeFindFirstArgs<ExtArgs>>): Prisma__TaskTypeClient<$Result.GetResult<Prisma.$TaskTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TaskType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTypeFindFirstOrThrowArgs} args - Arguments to find a TaskType
     * @example
     * // Get one TaskType
     * const taskType = await prisma.taskType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskTypeClient<$Result.GetResult<Prisma.$TaskTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TaskTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskTypes
     * const taskTypes = await prisma.taskType.findMany()
     * 
     * // Get first 10 TaskTypes
     * const taskTypes = await prisma.taskType.findMany({ take: 10 })
     * 
     * // Only select the `task_type_id`
     * const taskTypeWithTask_type_idOnly = await prisma.taskType.findMany({ select: { task_type_id: true } })
     * 
     */
    findMany<T extends TaskTypeFindManyArgs>(args?: SelectSubset<T, TaskTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TaskType.
     * @param {TaskTypeCreateArgs} args - Arguments to create a TaskType.
     * @example
     * // Create one TaskType
     * const TaskType = await prisma.taskType.create({
     *   data: {
     *     // ... data to create a TaskType
     *   }
     * })
     * 
     */
    create<T extends TaskTypeCreateArgs>(args: SelectSubset<T, TaskTypeCreateArgs<ExtArgs>>): Prisma__TaskTypeClient<$Result.GetResult<Prisma.$TaskTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TaskTypes.
     * @param {TaskTypeCreateManyArgs} args - Arguments to create many TaskTypes.
     * @example
     * // Create many TaskTypes
     * const taskType = await prisma.taskType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskTypeCreateManyArgs>(args?: SelectSubset<T, TaskTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskTypes and returns the data saved in the database.
     * @param {TaskTypeCreateManyAndReturnArgs} args - Arguments to create many TaskTypes.
     * @example
     * // Create many TaskTypes
     * const taskType = await prisma.taskType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskTypes and only return the `task_type_id`
     * const taskTypeWithTask_type_idOnly = await prisma.taskType.createManyAndReturn({ 
     *   select: { task_type_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TaskType.
     * @param {TaskTypeDeleteArgs} args - Arguments to delete one TaskType.
     * @example
     * // Delete one TaskType
     * const TaskType = await prisma.taskType.delete({
     *   where: {
     *     // ... filter to delete one TaskType
     *   }
     * })
     * 
     */
    delete<T extends TaskTypeDeleteArgs>(args: SelectSubset<T, TaskTypeDeleteArgs<ExtArgs>>): Prisma__TaskTypeClient<$Result.GetResult<Prisma.$TaskTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TaskType.
     * @param {TaskTypeUpdateArgs} args - Arguments to update one TaskType.
     * @example
     * // Update one TaskType
     * const taskType = await prisma.taskType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskTypeUpdateArgs>(args: SelectSubset<T, TaskTypeUpdateArgs<ExtArgs>>): Prisma__TaskTypeClient<$Result.GetResult<Prisma.$TaskTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TaskTypes.
     * @param {TaskTypeDeleteManyArgs} args - Arguments to filter TaskTypes to delete.
     * @example
     * // Delete a few TaskTypes
     * const { count } = await prisma.taskType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskTypeDeleteManyArgs>(args?: SelectSubset<T, TaskTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskTypes
     * const taskType = await prisma.taskType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskTypeUpdateManyArgs>(args: SelectSubset<T, TaskTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskType.
     * @param {TaskTypeUpsertArgs} args - Arguments to update or create a TaskType.
     * @example
     * // Update or create a TaskType
     * const taskType = await prisma.taskType.upsert({
     *   create: {
     *     // ... data to create a TaskType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskType we want to update
     *   }
     * })
     */
    upsert<T extends TaskTypeUpsertArgs>(args: SelectSubset<T, TaskTypeUpsertArgs<ExtArgs>>): Prisma__TaskTypeClient<$Result.GetResult<Prisma.$TaskTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TaskTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTypeCountArgs} args - Arguments to filter TaskTypes to count.
     * @example
     * // Count the number of TaskTypes
     * const count = await prisma.taskType.count({
     *   where: {
     *     // ... the filter for the TaskTypes we want to count
     *   }
     * })
    **/
    count<T extends TaskTypeCountArgs>(
      args?: Subset<T, TaskTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskTypeAggregateArgs>(args: Subset<T, TaskTypeAggregateArgs>): Prisma.PrismaPromise<GetTaskTypeAggregateType<T>>

    /**
     * Group by TaskType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskTypeGroupByArgs['orderBy'] }
        : { orderBy?: TaskTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskType model
   */
  readonly fields: TaskTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskType$taskArgs<ExtArgs> = {}>(args?: Subset<T, TaskType$taskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskType model
   */ 
  interface TaskTypeFieldRefs {
    readonly task_type_id: FieldRef<"TaskType", 'Int'>
    readonly task_type_name: FieldRef<"TaskType", 'String'>
    readonly task_type_description: FieldRef<"TaskType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaskType findUnique
   */
  export type TaskTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskType
     */
    select?: TaskTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTypeInclude<ExtArgs> | null
    /**
     * Filter, which TaskType to fetch.
     */
    where: TaskTypeWhereUniqueInput
  }

  /**
   * TaskType findUniqueOrThrow
   */
  export type TaskTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskType
     */
    select?: TaskTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTypeInclude<ExtArgs> | null
    /**
     * Filter, which TaskType to fetch.
     */
    where: TaskTypeWhereUniqueInput
  }

  /**
   * TaskType findFirst
   */
  export type TaskTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskType
     */
    select?: TaskTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTypeInclude<ExtArgs> | null
    /**
     * Filter, which TaskType to fetch.
     */
    where?: TaskTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTypes to fetch.
     */
    orderBy?: TaskTypeOrderByWithRelationInput | TaskTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTypes.
     */
    cursor?: TaskTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTypes.
     */
    distinct?: TaskTypeScalarFieldEnum | TaskTypeScalarFieldEnum[]
  }

  /**
   * TaskType findFirstOrThrow
   */
  export type TaskTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskType
     */
    select?: TaskTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTypeInclude<ExtArgs> | null
    /**
     * Filter, which TaskType to fetch.
     */
    where?: TaskTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTypes to fetch.
     */
    orderBy?: TaskTypeOrderByWithRelationInput | TaskTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskTypes.
     */
    cursor?: TaskTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskTypes.
     */
    distinct?: TaskTypeScalarFieldEnum | TaskTypeScalarFieldEnum[]
  }

  /**
   * TaskType findMany
   */
  export type TaskTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskType
     */
    select?: TaskTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTypeInclude<ExtArgs> | null
    /**
     * Filter, which TaskTypes to fetch.
     */
    where?: TaskTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskTypes to fetch.
     */
    orderBy?: TaskTypeOrderByWithRelationInput | TaskTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskTypes.
     */
    cursor?: TaskTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskTypes.
     */
    skip?: number
    distinct?: TaskTypeScalarFieldEnum | TaskTypeScalarFieldEnum[]
  }

  /**
   * TaskType create
   */
  export type TaskTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskType
     */
    select?: TaskTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskType.
     */
    data: XOR<TaskTypeCreateInput, TaskTypeUncheckedCreateInput>
  }

  /**
   * TaskType createMany
   */
  export type TaskTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskTypes.
     */
    data: TaskTypeCreateManyInput | TaskTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskType createManyAndReturn
   */
  export type TaskTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskType
     */
    select?: TaskTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TaskTypes.
     */
    data: TaskTypeCreateManyInput | TaskTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskType update
   */
  export type TaskTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskType
     */
    select?: TaskTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskType.
     */
    data: XOR<TaskTypeUpdateInput, TaskTypeUncheckedUpdateInput>
    /**
     * Choose, which TaskType to update.
     */
    where: TaskTypeWhereUniqueInput
  }

  /**
   * TaskType updateMany
   */
  export type TaskTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskTypes.
     */
    data: XOR<TaskTypeUpdateManyMutationInput, TaskTypeUncheckedUpdateManyInput>
    /**
     * Filter which TaskTypes to update
     */
    where?: TaskTypeWhereInput
  }

  /**
   * TaskType upsert
   */
  export type TaskTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskType
     */
    select?: TaskTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskType to update in case it exists.
     */
    where: TaskTypeWhereUniqueInput
    /**
     * In case the TaskType found by the `where` argument doesn't exist, create a new TaskType with this data.
     */
    create: XOR<TaskTypeCreateInput, TaskTypeUncheckedCreateInput>
    /**
     * In case the TaskType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskTypeUpdateInput, TaskTypeUncheckedUpdateInput>
  }

  /**
   * TaskType delete
   */
  export type TaskTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskType
     */
    select?: TaskTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTypeInclude<ExtArgs> | null
    /**
     * Filter which TaskType to delete.
     */
    where: TaskTypeWhereUniqueInput
  }

  /**
   * TaskType deleteMany
   */
  export type TaskTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskTypes to delete
     */
    where?: TaskTypeWhereInput
  }

  /**
   * TaskType.task
   */
  export type TaskType$taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * TaskType without action
   */
  export type TaskTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskType
     */
    select?: TaskTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskTypeInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    user_email: 'user_email',
    created_at: 'created_at',
    updated_at: 'updated_at',
    first_name: 'first_name',
    last_name: 'last_name',
    nickname: 'nickname',
    deleted: 'deleted'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    role_id: 'role_id',
    role_name: 'role_name',
    role_description: 'role_description'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    user_email: 'user_email',
    role_id: 'role_id'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const UserApplicationPreferencesScalarFieldEnum: {
    user_email: 'user_email',
    application_id: 'application_id',
    accepted_privacy_policy: 'accepted_privacy_policy',
    accepted_cookies_policy: 'accepted_cookies_policy'
  };

  export type UserApplicationPreferencesScalarFieldEnum = (typeof UserApplicationPreferencesScalarFieldEnum)[keyof typeof UserApplicationPreferencesScalarFieldEnum]


  export const ApplicationScalarFieldEnum: {
    application_id: 'application_id',
    application_name: 'application_name',
    application_description: 'application_description',
    application_url: 'application_url'
  };

  export type ApplicationScalarFieldEnum = (typeof ApplicationScalarFieldEnum)[keyof typeof ApplicationScalarFieldEnum]


  export const DataRemovalRequestScalarFieldEnum: {
    data_removal_request_id: 'data_removal_request_id',
    user_email: 'user_email',
    data_removal_request: 'data_removal_request',
    data_removal_status: 'data_removal_status',
    data_removal_date: 'data_removal_date'
  };

  export type DataRemovalRequestScalarFieldEnum = (typeof DataRemovalRequestScalarFieldEnum)[keyof typeof DataRemovalRequestScalarFieldEnum]


  export const MeetingKindScalarFieldEnum: {
    meeting_kind_id: 'meeting_kind_id',
    meeting_kind_name: 'meeting_kind_name'
  };

  export type MeetingKindScalarFieldEnum = (typeof MeetingKindScalarFieldEnum)[keyof typeof MeetingKindScalarFieldEnum]


  export const CourseStructureScalarFieldEnum: {
    course_id: 'course_id',
    module_id: 'module_id',
    section_id: 'section_id',
    lesson_id: 'lesson_id'
  };

  export type CourseStructureScalarFieldEnum = (typeof CourseStructureScalarFieldEnum)[keyof typeof CourseStructureScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    class_id: 'class_id',
    class_code: 'class_code',
    course_id: 'course_id',
    start_date: 'start_date',
    end_date: 'end_date',
    tuition_lang_code: 'tuition_lang_code',
    time_of_day_id: 'time_of_day_id',
    start_time_gmt3: 'start_time_gmt3',
    created_date: 'created_date',
    updated_date: 'updated_date',
    deleted: 'deleted',
    classSizeClass_size_id: 'classSizeClass_size_id'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const ClassCallScalarFieldEnum: {
    class_call_id: 'class_call_id',
    class_id: 'class_id',
    call_date: 'call_date',
    created_date: 'created_date',
    updated_date: 'updated_date',
    deleted: 'deleted',
    meeting_kind_id: 'meeting_kind_id'
  };

  export type ClassCallScalarFieldEnum = (typeof ClassCallScalarFieldEnum)[keyof typeof ClassCallScalarFieldEnum]


  export const ClassSizeScalarFieldEnum: {
    class_size_id: 'class_size_id',
    class_size_name: 'class_size_name'
  };

  export type ClassSizeScalarFieldEnum = (typeof ClassSizeScalarFieldEnum)[keyof typeof ClassSizeScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    course_code: 'course_code',
    course_name: 'course_name',
    course_level_id: 'course_level_id',
    created_date: 'created_date',
    subject_code: 'subject_code'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const CourseAdviceScalarFieldEnum: {
    advice_id: 'advice_id',
    course_code: 'course_code',
    advice_text: 'advice_text',
    last_used_date: 'last_used_date',
    created_date: 'created_date'
  };

  export type CourseAdviceScalarFieldEnum = (typeof CourseAdviceScalarFieldEnum)[keyof typeof CourseAdviceScalarFieldEnum]


  export const CourseTaskScalarFieldEnum: {
    course_task_id: 'course_task_id',
    course_id: 'course_id',
    module_id: 'module_id',
    section_id: 'section_id',
    lesson_id: 'lesson_id',
    task_id: 'task_id',
    question: 'question'
  };

  export type CourseTaskScalarFieldEnum = (typeof CourseTaskScalarFieldEnum)[keyof typeof CourseTaskScalarFieldEnum]


  export const CourseLevelScalarFieldEnum: {
    course_level_id: 'course_level_id',
    course_level_name: 'course_level_name'
  };

  export type CourseLevelScalarFieldEnum = (typeof CourseLevelScalarFieldEnum)[keyof typeof CourseLevelScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    subject_code: 'subject_code',
    subject_name: 'subject_name'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const CourseLevelsPerSubjectScalarFieldEnum: {
    course_level_id: 'course_level_id',
    subject_code: 'subject_code'
  };

  export type CourseLevelsPerSubjectScalarFieldEnum = (typeof CourseLevelsPerSubjectScalarFieldEnum)[keyof typeof CourseLevelsPerSubjectScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    lesson_id: 'lesson_id',
    lesson_name: 'lesson_name',
    lesson_description: 'lesson_description',
    lesson_order: 'lesson_order',
    created_date: 'created_date',
    updated_date: 'updated_date',
    deleted: 'deleted',
    section_id: 'section_id',
    moduleModule_id: 'moduleModule_id'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const MentorScalarFieldEnum: {
    mentor_id: 'mentor_id',
    user_id: 'user_id',
    mentor_description_en: 'mentor_description_en',
    created_date: 'created_date',
    updated_date: 'updated_date',
    deleted: 'deleted'
  };

  export type MentorScalarFieldEnum = (typeof MentorScalarFieldEnum)[keyof typeof MentorScalarFieldEnum]


  export const MentorsClassesScalarFieldEnum: {
    mentor_id: 'mentor_id',
    class_id: 'class_id',
    created_date: 'created_date',
    updated_date: 'updated_date',
    deleted: 'deleted'
  };

  export type MentorsClassesScalarFieldEnum = (typeof MentorsClassesScalarFieldEnum)[keyof typeof MentorsClassesScalarFieldEnum]


  export const MentorPayModelScalarFieldEnum: {
    mentor_id: 'mentor_id',
    class_size_id: 'class_size_id',
    start_date: 'start_date',
    pay_rate_per_hour: 'pay_rate_per_hour',
    created_date: 'created_date',
    end_date: 'end_date',
    deleted: 'deleted'
  };

  export type MentorPayModelScalarFieldEnum = (typeof MentorPayModelScalarFieldEnum)[keyof typeof MentorPayModelScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    module_id: 'module_id',
    module_name: 'module_name',
    module_description: 'module_description',
    module_order: 'module_order',
    created_date: 'created_date',
    updated_date: 'updated_date',
    deleted: 'deleted',
    course_id: 'course_id'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const SectionScalarFieldEnum: {
    section_id: 'section_id',
    section_name: 'section_name',
    section_description: 'section_description',
    section_order: 'section_order',
    created_date: 'created_date',
    updated_date: 'updated_date',
    deleted: 'deleted',
    module_id: 'module_id'
  };

  export type SectionScalarFieldEnum = (typeof SectionScalarFieldEnum)[keyof typeof SectionScalarFieldEnum]


  export const TimeOfDayScalarFieldEnum: {
    time_of_day_id: 'time_of_day_id',
    time_of_day_name: 'time_of_day_name'
  };

  export type TimeOfDayScalarFieldEnum = (typeof TimeOfDayScalarFieldEnum)[keyof typeof TimeOfDayScalarFieldEnum]


  export const TuitionLangScalarFieldEnum: {
    tuition_lang_code: 'tuition_lang_code',
    tuition_lang_name: 'tuition_lang_name'
  };

  export type TuitionLangScalarFieldEnum = (typeof TuitionLangScalarFieldEnum)[keyof typeof TuitionLangScalarFieldEnum]


  export const DeckScalarFieldEnum: {
    deck_id: 'deck_id',
    user_id: 'user_id',
    deck_description: 'deck_description'
  };

  export type DeckScalarFieldEnum = (typeof DeckScalarFieldEnum)[keyof typeof DeckScalarFieldEnum]


  export const LessonCardScalarFieldEnum: {
    card_id: 'card_id',
    deck_id: 'deck_id',
    question: 'question',
    answer: 'answer',
    example: 'example',
    course_code: 'course_code',
    lesson_id: 'lesson_id'
  };

  export type LessonCardScalarFieldEnum = (typeof LessonCardScalarFieldEnum)[keyof typeof LessonCardScalarFieldEnum]


  export const UserCardScalarFieldEnum: {
    user_card_id: 'user_card_id',
    user_id: 'user_id',
    question: 'question',
    answer: 'answer',
    example: 'example',
    lesson_id: 'lesson_id'
  };

  export type UserCardScalarFieldEnum = (typeof UserCardScalarFieldEnum)[keyof typeof UserCardScalarFieldEnum]


  export const VocabularyScalarFieldEnum: {
    vocabulary_id: 'vocabulary_id',
    user_id: 'user_id'
  };

  export type VocabularyScalarFieldEnum = (typeof VocabularyScalarFieldEnum)[keyof typeof VocabularyScalarFieldEnum]


  export const VocabularyInboxScalarFieldEnum: {
    user_id: 'user_id',
    question: 'question',
    answer: 'answer'
  };

  export type VocabularyInboxScalarFieldEnum = (typeof VocabularyInboxScalarFieldEnum)[keyof typeof VocabularyInboxScalarFieldEnum]


  export const BookingRequestScalarFieldEnum: {
    booking_request_id: 'booking_request_id',
    class_id: 'class_id',
    booking_date: 'booking_date',
    booking_request_status: 'booking_request_status',
    user_stated_name: 'user_stated_name',
    user_stated_phone: 'user_stated_phone',
    user_stated_email: 'user_stated_email',
    user_stated_telegram_nickname: 'user_stated_telegram_nickname'
  };

  export type BookingRequestScalarFieldEnum = (typeof BookingRequestScalarFieldEnum)[keyof typeof BookingRequestScalarFieldEnum]


  export const ClassTaskScalarFieldEnum: {
    class_task_id: 'class_task_id',
    course_task_id: 'course_task_id',
    class_id: 'class_id'
  };

  export type ClassTaskScalarFieldEnum = (typeof ClassTaskScalarFieldEnum)[keyof typeof ClassTaskScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    student_id: 'student_id',
    user_id: 'user_id',
    student_nickname: 'student_nickname',
    enrolled_date: 'enrolled_date',
    left_date: 'left_date',
    created_date: 'created_date',
    updated_date: 'updated_date',
    deleted: 'deleted',
    class_id: 'class_id'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const StudentAnswerScalarFieldEnum: {
    student_answer_id: 'student_answer_id',
    student_id: 'student_id',
    class_task_id: 'class_task_id',
    answer: 'answer'
  };

  export type StudentAnswerScalarFieldEnum = (typeof StudentAnswerScalarFieldEnum)[keyof typeof StudentAnswerScalarFieldEnum]


  export const StudentTaskScalarFieldEnum: {
    student_task_id: 'student_task_id',
    student_id: 'student_id',
    class_task_id: 'class_task_id',
    task_status: 'task_status'
  };

  export type StudentTaskScalarFieldEnum = (typeof StudentTaskScalarFieldEnum)[keyof typeof StudentTaskScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    task_id: 'task_id',
    task_description: 'task_description',
    task_text: 'task_text',
    task_type_id: 'task_type_id',
    task_context_id: 'task_context_id',
    task_form_id: 'task_form_id',
    task_created_date: 'task_created_date',
    task_updated_date: 'task_updated_date',
    deleted: 'deleted',
    lesson_id: 'lesson_id',
    gap_map: 'gap_map'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TaskFormScalarFieldEnum: {
    task_form_id: 'task_form_id',
    task_form_name: 'task_form_name',
    task_form_description: 'task_form_description'
  };

  export type TaskFormScalarFieldEnum = (typeof TaskFormScalarFieldEnum)[keyof typeof TaskFormScalarFieldEnum]


  export const TaskContextScalarFieldEnum: {
    task_context_id: 'task_context_id',
    task_context_name: 'task_context_name',
    task_context_description: 'task_context_description'
  };

  export type TaskContextScalarFieldEnum = (typeof TaskContextScalarFieldEnum)[keyof typeof TaskContextScalarFieldEnum]


  export const TaskOptionScalarFieldEnum: {
    task_option_id: 'task_option_id',
    task_id: 'task_id',
    task_option_text: 'task_option_text',
    task_option_order: 'task_option_order',
    is_correct: 'is_correct'
  };

  export type TaskOptionScalarFieldEnum = (typeof TaskOptionScalarFieldEnum)[keyof typeof TaskOptionScalarFieldEnum]


  export const TaskTypeScalarFieldEnum: {
    task_type_id: 'task_type_id',
    task_type_name: 'task_type_name',
    task_type_description: 'task_type_description'
  };

  export type TaskTypeScalarFieldEnum = (typeof TaskTypeScalarFieldEnum)[keyof typeof TaskTypeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DataRemovalStatusEnum'
   */
  export type EnumDataRemovalStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataRemovalStatusEnum'>
    


  /**
   * Reference to a field of type 'DataRemovalStatusEnum[]'
   */
  export type ListEnumDataRemovalStatusEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataRemovalStatusEnum[]'>
    


  /**
   * Reference to a field of type 'ClassSizesEnum'
   */
  export type EnumClassSizesEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClassSizesEnum'>
    


  /**
   * Reference to a field of type 'ClassSizesEnum[]'
   */
  export type ListEnumClassSizesEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClassSizesEnum[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'BookingRequestStatus'
   */
  export type EnumBookingRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingRequestStatus'>
    


  /**
   * Reference to a field of type 'BookingRequestStatus[]'
   */
  export type ListEnumBookingRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingRequestStatus[]'>
    


  /**
   * Reference to a field of type 'StudentTaskStatus'
   */
  export type EnumStudentTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentTaskStatus'>
    


  /**
   * Reference to a field of type 'StudentTaskStatus[]'
   */
  export type ListEnumStudentTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StudentTaskStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    user_email?: StringFilter<"User"> | string
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeNullableFilter<"User"> | Date | string | null
    first_name?: StringFilter<"User"> | string
    last_name?: StringFilter<"User"> | string
    nickname?: StringNullableFilter<"User"> | string | null
    deleted?: BoolFilter<"User"> | boolean
    user_roles?: UserRoleListRelationFilter
    user_application_preferences?: UserApplicationPreferencesListRelationFilter
    mentor?: MentorListRelationFilter
    is_student_of?: StudentListRelationFilter
    DataRemovalRequest?: DataRemovalRequestListRelationFilter
    Deck?: DeckListRelationFilter
    UserCard?: UserCardListRelationFilter
    VocabularyInbox?: VocabularyInboxListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    user_email?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    nickname?: SortOrderInput | SortOrder
    deleted?: SortOrder
    user_roles?: UserRoleOrderByRelationAggregateInput
    user_application_preferences?: UserApplicationPreferencesOrderByRelationAggregateInput
    mentor?: MentorOrderByRelationAggregateInput
    is_student_of?: StudentOrderByRelationAggregateInput
    DataRemovalRequest?: DataRemovalRequestOrderByRelationAggregateInput
    Deck?: DeckOrderByRelationAggregateInput
    UserCard?: UserCardOrderByRelationAggregateInput
    VocabularyInbox?: VocabularyInboxOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    user_email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeNullableFilter<"User"> | Date | string | null
    first_name?: StringFilter<"User"> | string
    last_name?: StringFilter<"User"> | string
    nickname?: StringNullableFilter<"User"> | string | null
    deleted?: BoolFilter<"User"> | boolean
    user_roles?: UserRoleListRelationFilter
    user_application_preferences?: UserApplicationPreferencesListRelationFilter
    mentor?: MentorListRelationFilter
    is_student_of?: StudentListRelationFilter
    DataRemovalRequest?: DataRemovalRequestListRelationFilter
    Deck?: DeckListRelationFilter
    UserCard?: UserCardListRelationFilter
    VocabularyInbox?: VocabularyInboxListRelationFilter
  }, "user_email">

  export type UserOrderByWithAggregationInput = {
    user_email?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    nickname?: SortOrderInput | SortOrder
    deleted?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    user_email?: StringWithAggregatesFilter<"User"> | string
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    first_name?: StringWithAggregatesFilter<"User"> | string
    last_name?: StringWithAggregatesFilter<"User"> | string
    nickname?: StringNullableWithAggregatesFilter<"User"> | string | null
    deleted?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    role_id?: StringFilter<"Role"> | string
    role_name?: StringNullableFilter<"Role"> | string | null
    role_description?: StringNullableFilter<"Role"> | string | null
    user_roles?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    role_id?: SortOrder
    role_name?: SortOrderInput | SortOrder
    role_description?: SortOrderInput | SortOrder
    user_roles?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    role_id?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    role_name?: StringNullableFilter<"Role"> | string | null
    role_description?: StringNullableFilter<"Role"> | string | null
    user_roles?: UserRoleListRelationFilter
  }, "role_id">

  export type RoleOrderByWithAggregationInput = {
    role_id?: SortOrder
    role_name?: SortOrderInput | SortOrder
    role_description?: SortOrderInput | SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    role_id?: StringWithAggregatesFilter<"Role"> | string
    role_name?: StringNullableWithAggregatesFilter<"Role"> | string | null
    role_description?: StringNullableWithAggregatesFilter<"Role"> | string | null
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    user_email?: StringFilter<"UserRole"> | string
    role_id?: StringFilter<"UserRole"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    user_email?: SortOrder
    role_id?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    user_email_role_id?: UserRoleUser_emailRole_idCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    user_email?: StringFilter<"UserRole"> | string
    role_id?: StringFilter<"UserRole"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
  }, "user_email_role_id">

  export type UserRoleOrderByWithAggregationInput = {
    user_email?: SortOrder
    role_id?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    user_email?: StringWithAggregatesFilter<"UserRole"> | string
    role_id?: StringWithAggregatesFilter<"UserRole"> | string
  }

  export type UserApplicationPreferencesWhereInput = {
    AND?: UserApplicationPreferencesWhereInput | UserApplicationPreferencesWhereInput[]
    OR?: UserApplicationPreferencesWhereInput[]
    NOT?: UserApplicationPreferencesWhereInput | UserApplicationPreferencesWhereInput[]
    user_email?: StringFilter<"UserApplicationPreferences"> | string
    application_id?: StringFilter<"UserApplicationPreferences"> | string
    accepted_privacy_policy?: BoolFilter<"UserApplicationPreferences"> | boolean
    accepted_cookies_policy?: BoolFilter<"UserApplicationPreferences"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    application?: XOR<ApplicationRelationFilter, ApplicationWhereInput>
  }

  export type UserApplicationPreferencesOrderByWithRelationInput = {
    user_email?: SortOrder
    application_id?: SortOrder
    accepted_privacy_policy?: SortOrder
    accepted_cookies_policy?: SortOrder
    user?: UserOrderByWithRelationInput
    application?: ApplicationOrderByWithRelationInput
  }

  export type UserApplicationPreferencesWhereUniqueInput = Prisma.AtLeast<{
    user_email_application_id?: UserApplicationPreferencesUser_emailApplication_idCompoundUniqueInput
    AND?: UserApplicationPreferencesWhereInput | UserApplicationPreferencesWhereInput[]
    OR?: UserApplicationPreferencesWhereInput[]
    NOT?: UserApplicationPreferencesWhereInput | UserApplicationPreferencesWhereInput[]
    user_email?: StringFilter<"UserApplicationPreferences"> | string
    application_id?: StringFilter<"UserApplicationPreferences"> | string
    accepted_privacy_policy?: BoolFilter<"UserApplicationPreferences"> | boolean
    accepted_cookies_policy?: BoolFilter<"UserApplicationPreferences"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    application?: XOR<ApplicationRelationFilter, ApplicationWhereInput>
  }, "user_email_application_id">

  export type UserApplicationPreferencesOrderByWithAggregationInput = {
    user_email?: SortOrder
    application_id?: SortOrder
    accepted_privacy_policy?: SortOrder
    accepted_cookies_policy?: SortOrder
    _count?: UserApplicationPreferencesCountOrderByAggregateInput
    _max?: UserApplicationPreferencesMaxOrderByAggregateInput
    _min?: UserApplicationPreferencesMinOrderByAggregateInput
  }

  export type UserApplicationPreferencesScalarWhereWithAggregatesInput = {
    AND?: UserApplicationPreferencesScalarWhereWithAggregatesInput | UserApplicationPreferencesScalarWhereWithAggregatesInput[]
    OR?: UserApplicationPreferencesScalarWhereWithAggregatesInput[]
    NOT?: UserApplicationPreferencesScalarWhereWithAggregatesInput | UserApplicationPreferencesScalarWhereWithAggregatesInput[]
    user_email?: StringWithAggregatesFilter<"UserApplicationPreferences"> | string
    application_id?: StringWithAggregatesFilter<"UserApplicationPreferences"> | string
    accepted_privacy_policy?: BoolWithAggregatesFilter<"UserApplicationPreferences"> | boolean
    accepted_cookies_policy?: BoolWithAggregatesFilter<"UserApplicationPreferences"> | boolean
  }

  export type ApplicationWhereInput = {
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    application_id?: StringFilter<"Application"> | string
    application_name?: StringFilter<"Application"> | string
    application_description?: StringNullableFilter<"Application"> | string | null
    application_url?: StringNullableFilter<"Application"> | string | null
    user_application_preferences?: UserApplicationPreferencesListRelationFilter
  }

  export type ApplicationOrderByWithRelationInput = {
    application_id?: SortOrder
    application_name?: SortOrder
    application_description?: SortOrderInput | SortOrder
    application_url?: SortOrderInput | SortOrder
    user_application_preferences?: UserApplicationPreferencesOrderByRelationAggregateInput
  }

  export type ApplicationWhereUniqueInput = Prisma.AtLeast<{
    application_id?: string
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    application_name?: StringFilter<"Application"> | string
    application_description?: StringNullableFilter<"Application"> | string | null
    application_url?: StringNullableFilter<"Application"> | string | null
    user_application_preferences?: UserApplicationPreferencesListRelationFilter
  }, "application_id">

  export type ApplicationOrderByWithAggregationInput = {
    application_id?: SortOrder
    application_name?: SortOrder
    application_description?: SortOrderInput | SortOrder
    application_url?: SortOrderInput | SortOrder
    _count?: ApplicationCountOrderByAggregateInput
    _max?: ApplicationMaxOrderByAggregateInput
    _min?: ApplicationMinOrderByAggregateInput
  }

  export type ApplicationScalarWhereWithAggregatesInput = {
    AND?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    OR?: ApplicationScalarWhereWithAggregatesInput[]
    NOT?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    application_id?: StringWithAggregatesFilter<"Application"> | string
    application_name?: StringWithAggregatesFilter<"Application"> | string
    application_description?: StringNullableWithAggregatesFilter<"Application"> | string | null
    application_url?: StringNullableWithAggregatesFilter<"Application"> | string | null
  }

  export type DataRemovalRequestWhereInput = {
    AND?: DataRemovalRequestWhereInput | DataRemovalRequestWhereInput[]
    OR?: DataRemovalRequestWhereInput[]
    NOT?: DataRemovalRequestWhereInput | DataRemovalRequestWhereInput[]
    data_removal_request_id?: IntFilter<"DataRemovalRequest"> | number
    user_email?: StringFilter<"DataRemovalRequest"> | string
    data_removal_request?: StringFilter<"DataRemovalRequest"> | string
    data_removal_status?: EnumDataRemovalStatusEnumFilter<"DataRemovalRequest"> | $Enums.DataRemovalStatusEnum
    data_removal_date?: DateTimeFilter<"DataRemovalRequest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DataRemovalRequestOrderByWithRelationInput = {
    data_removal_request_id?: SortOrder
    user_email?: SortOrder
    data_removal_request?: SortOrder
    data_removal_status?: SortOrder
    data_removal_date?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DataRemovalRequestWhereUniqueInput = Prisma.AtLeast<{
    data_removal_request_id?: number
    AND?: DataRemovalRequestWhereInput | DataRemovalRequestWhereInput[]
    OR?: DataRemovalRequestWhereInput[]
    NOT?: DataRemovalRequestWhereInput | DataRemovalRequestWhereInput[]
    user_email?: StringFilter<"DataRemovalRequest"> | string
    data_removal_request?: StringFilter<"DataRemovalRequest"> | string
    data_removal_status?: EnumDataRemovalStatusEnumFilter<"DataRemovalRequest"> | $Enums.DataRemovalStatusEnum
    data_removal_date?: DateTimeFilter<"DataRemovalRequest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "data_removal_request_id">

  export type DataRemovalRequestOrderByWithAggregationInput = {
    data_removal_request_id?: SortOrder
    user_email?: SortOrder
    data_removal_request?: SortOrder
    data_removal_status?: SortOrder
    data_removal_date?: SortOrder
    _count?: DataRemovalRequestCountOrderByAggregateInput
    _avg?: DataRemovalRequestAvgOrderByAggregateInput
    _max?: DataRemovalRequestMaxOrderByAggregateInput
    _min?: DataRemovalRequestMinOrderByAggregateInput
    _sum?: DataRemovalRequestSumOrderByAggregateInput
  }

  export type DataRemovalRequestScalarWhereWithAggregatesInput = {
    AND?: DataRemovalRequestScalarWhereWithAggregatesInput | DataRemovalRequestScalarWhereWithAggregatesInput[]
    OR?: DataRemovalRequestScalarWhereWithAggregatesInput[]
    NOT?: DataRemovalRequestScalarWhereWithAggregatesInput | DataRemovalRequestScalarWhereWithAggregatesInput[]
    data_removal_request_id?: IntWithAggregatesFilter<"DataRemovalRequest"> | number
    user_email?: StringWithAggregatesFilter<"DataRemovalRequest"> | string
    data_removal_request?: StringWithAggregatesFilter<"DataRemovalRequest"> | string
    data_removal_status?: EnumDataRemovalStatusEnumWithAggregatesFilter<"DataRemovalRequest"> | $Enums.DataRemovalStatusEnum
    data_removal_date?: DateTimeWithAggregatesFilter<"DataRemovalRequest"> | Date | string
  }

  export type MeetingKindWhereInput = {
    AND?: MeetingKindWhereInput | MeetingKindWhereInput[]
    OR?: MeetingKindWhereInput[]
    NOT?: MeetingKindWhereInput | MeetingKindWhereInput[]
    meeting_kind_id?: StringFilter<"MeetingKind"> | string
    meeting_kind_name?: StringFilter<"MeetingKind"> | string
    class_calls?: ClassCallListRelationFilter
  }

  export type MeetingKindOrderByWithRelationInput = {
    meeting_kind_id?: SortOrder
    meeting_kind_name?: SortOrder
    class_calls?: ClassCallOrderByRelationAggregateInput
  }

  export type MeetingKindWhereUniqueInput = Prisma.AtLeast<{
    meeting_kind_id?: string
    meeting_kind_name?: string
    AND?: MeetingKindWhereInput | MeetingKindWhereInput[]
    OR?: MeetingKindWhereInput[]
    NOT?: MeetingKindWhereInput | MeetingKindWhereInput[]
    class_calls?: ClassCallListRelationFilter
  }, "meeting_kind_id" | "meeting_kind_name">

  export type MeetingKindOrderByWithAggregationInput = {
    meeting_kind_id?: SortOrder
    meeting_kind_name?: SortOrder
    _count?: MeetingKindCountOrderByAggregateInput
    _max?: MeetingKindMaxOrderByAggregateInput
    _min?: MeetingKindMinOrderByAggregateInput
  }

  export type MeetingKindScalarWhereWithAggregatesInput = {
    AND?: MeetingKindScalarWhereWithAggregatesInput | MeetingKindScalarWhereWithAggregatesInput[]
    OR?: MeetingKindScalarWhereWithAggregatesInput[]
    NOT?: MeetingKindScalarWhereWithAggregatesInput | MeetingKindScalarWhereWithAggregatesInput[]
    meeting_kind_id?: StringWithAggregatesFilter<"MeetingKind"> | string
    meeting_kind_name?: StringWithAggregatesFilter<"MeetingKind"> | string
  }

  export type CourseStructureWhereInput = {
    AND?: CourseStructureWhereInput | CourseStructureWhereInput[]
    OR?: CourseStructureWhereInput[]
    NOT?: CourseStructureWhereInput | CourseStructureWhereInput[]
    course_id?: StringFilter<"CourseStructure"> | string
    module_id?: IntFilter<"CourseStructure"> | number
    section_id?: IntFilter<"CourseStructure"> | number
    lesson_id?: IntFilter<"CourseStructure"> | number
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
    section?: XOR<SectionRelationFilter, SectionWhereInput>
    lesson?: XOR<LessonRelationFilter, LessonWhereInput>
  }

  export type CourseStructureOrderByWithRelationInput = {
    course_id?: SortOrder
    module_id?: SortOrder
    section_id?: SortOrder
    lesson_id?: SortOrder
    course?: CourseOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
    section?: SectionOrderByWithRelationInput
    lesson?: LessonOrderByWithRelationInput
  }

  export type CourseStructureWhereUniqueInput = Prisma.AtLeast<{
    course_id_module_id_section_id_lesson_id?: CourseStructureCourse_idModule_idSection_idLesson_idCompoundUniqueInput
    AND?: CourseStructureWhereInput | CourseStructureWhereInput[]
    OR?: CourseStructureWhereInput[]
    NOT?: CourseStructureWhereInput | CourseStructureWhereInput[]
    course_id?: StringFilter<"CourseStructure"> | string
    module_id?: IntFilter<"CourseStructure"> | number
    section_id?: IntFilter<"CourseStructure"> | number
    lesson_id?: IntFilter<"CourseStructure"> | number
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
    section?: XOR<SectionRelationFilter, SectionWhereInput>
    lesson?: XOR<LessonRelationFilter, LessonWhereInput>
  }, "course_id_module_id_section_id_lesson_id">

  export type CourseStructureOrderByWithAggregationInput = {
    course_id?: SortOrder
    module_id?: SortOrder
    section_id?: SortOrder
    lesson_id?: SortOrder
    _count?: CourseStructureCountOrderByAggregateInput
    _avg?: CourseStructureAvgOrderByAggregateInput
    _max?: CourseStructureMaxOrderByAggregateInput
    _min?: CourseStructureMinOrderByAggregateInput
    _sum?: CourseStructureSumOrderByAggregateInput
  }

  export type CourseStructureScalarWhereWithAggregatesInput = {
    AND?: CourseStructureScalarWhereWithAggregatesInput | CourseStructureScalarWhereWithAggregatesInput[]
    OR?: CourseStructureScalarWhereWithAggregatesInput[]
    NOT?: CourseStructureScalarWhereWithAggregatesInput | CourseStructureScalarWhereWithAggregatesInput[]
    course_id?: StringWithAggregatesFilter<"CourseStructure"> | string
    module_id?: IntWithAggregatesFilter<"CourseStructure"> | number
    section_id?: IntWithAggregatesFilter<"CourseStructure"> | number
    lesson_id?: IntWithAggregatesFilter<"CourseStructure"> | number
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    class_id?: StringFilter<"Class"> | string
    class_code?: StringNullableFilter<"Class"> | string | null
    course_id?: StringFilter<"Class"> | string
    start_date?: DateTimeFilter<"Class"> | Date | string
    end_date?: DateTimeNullableFilter<"Class"> | Date | string | null
    tuition_lang_code?: StringFilter<"Class"> | string
    time_of_day_id?: StringFilter<"Class"> | string
    start_time_gmt3?: StringFilter<"Class"> | string
    created_date?: DateTimeNullableFilter<"Class"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Class"> | Date | string | null
    deleted?: BoolFilter<"Class"> | boolean
    classSizeClass_size_id?: StringFilter<"Class"> | string
    class_size_id?: XOR<ClassSizeRelationFilter, ClassSizeWhereInput>
    is_instance_of_course?: XOR<CourseRelationFilter, CourseWhereInput>
    time_of_day?: XOR<TimeOfDayRelationFilter, TimeOfDayWhereInput>
    tuition_lang?: XOR<TuitionLangRelationFilter, TuitionLangWhereInput>
    mentor_classes?: MentorsClassesListRelationFilter
    students?: StudentListRelationFilter
    booking_requests?: BookingRequestListRelationFilter
    class_calls?: ClassCallListRelationFilter
    ClassTask?: ClassTaskListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    class_id?: SortOrder
    class_code?: SortOrderInput | SortOrder
    course_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrderInput | SortOrder
    tuition_lang_code?: SortOrder
    time_of_day_id?: SortOrder
    start_time_gmt3?: SortOrder
    created_date?: SortOrderInput | SortOrder
    updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    classSizeClass_size_id?: SortOrder
    class_size_id?: ClassSizeOrderByWithRelationInput
    is_instance_of_course?: CourseOrderByWithRelationInput
    time_of_day?: TimeOfDayOrderByWithRelationInput
    tuition_lang?: TuitionLangOrderByWithRelationInput
    mentor_classes?: MentorsClassesOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    booking_requests?: BookingRequestOrderByRelationAggregateInput
    class_calls?: ClassCallOrderByRelationAggregateInput
    ClassTask?: ClassTaskOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    class_id?: string
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    class_code?: StringNullableFilter<"Class"> | string | null
    course_id?: StringFilter<"Class"> | string
    start_date?: DateTimeFilter<"Class"> | Date | string
    end_date?: DateTimeNullableFilter<"Class"> | Date | string | null
    tuition_lang_code?: StringFilter<"Class"> | string
    time_of_day_id?: StringFilter<"Class"> | string
    start_time_gmt3?: StringFilter<"Class"> | string
    created_date?: DateTimeNullableFilter<"Class"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Class"> | Date | string | null
    deleted?: BoolFilter<"Class"> | boolean
    classSizeClass_size_id?: StringFilter<"Class"> | string
    class_size_id?: XOR<ClassSizeRelationFilter, ClassSizeWhereInput>
    is_instance_of_course?: XOR<CourseRelationFilter, CourseWhereInput>
    time_of_day?: XOR<TimeOfDayRelationFilter, TimeOfDayWhereInput>
    tuition_lang?: XOR<TuitionLangRelationFilter, TuitionLangWhereInput>
    mentor_classes?: MentorsClassesListRelationFilter
    students?: StudentListRelationFilter
    booking_requests?: BookingRequestListRelationFilter
    class_calls?: ClassCallListRelationFilter
    ClassTask?: ClassTaskListRelationFilter
  }, "class_id">

  export type ClassOrderByWithAggregationInput = {
    class_id?: SortOrder
    class_code?: SortOrderInput | SortOrder
    course_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrderInput | SortOrder
    tuition_lang_code?: SortOrder
    time_of_day_id?: SortOrder
    start_time_gmt3?: SortOrder
    created_date?: SortOrderInput | SortOrder
    updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    classSizeClass_size_id?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    class_id?: StringWithAggregatesFilter<"Class"> | string
    class_code?: StringNullableWithAggregatesFilter<"Class"> | string | null
    course_id?: StringWithAggregatesFilter<"Class"> | string
    start_date?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    end_date?: DateTimeNullableWithAggregatesFilter<"Class"> | Date | string | null
    tuition_lang_code?: StringWithAggregatesFilter<"Class"> | string
    time_of_day_id?: StringWithAggregatesFilter<"Class"> | string
    start_time_gmt3?: StringWithAggregatesFilter<"Class"> | string
    created_date?: DateTimeNullableWithAggregatesFilter<"Class"> | Date | string | null
    updated_date?: DateTimeNullableWithAggregatesFilter<"Class"> | Date | string | null
    deleted?: BoolWithAggregatesFilter<"Class"> | boolean
    classSizeClass_size_id?: StringWithAggregatesFilter<"Class"> | string
  }

  export type ClassCallWhereInput = {
    AND?: ClassCallWhereInput | ClassCallWhereInput[]
    OR?: ClassCallWhereInput[]
    NOT?: ClassCallWhereInput | ClassCallWhereInput[]
    class_call_id?: StringFilter<"ClassCall"> | string
    class_id?: StringFilter<"ClassCall"> | string
    call_date?: DateTimeFilter<"ClassCall"> | Date | string
    created_date?: DateTimeNullableFilter<"ClassCall"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"ClassCall"> | Date | string | null
    deleted?: BoolFilter<"ClassCall"> | boolean
    meeting_kind_id?: StringFilter<"ClassCall"> | string
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    meeting_kind?: XOR<MeetingKindRelationFilter, MeetingKindWhereInput>
  }

  export type ClassCallOrderByWithRelationInput = {
    class_call_id?: SortOrder
    class_id?: SortOrder
    call_date?: SortOrder
    created_date?: SortOrderInput | SortOrder
    updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    meeting_kind_id?: SortOrder
    class?: ClassOrderByWithRelationInput
    meeting_kind?: MeetingKindOrderByWithRelationInput
  }

  export type ClassCallWhereUniqueInput = Prisma.AtLeast<{
    class_call_id?: string
    AND?: ClassCallWhereInput | ClassCallWhereInput[]
    OR?: ClassCallWhereInput[]
    NOT?: ClassCallWhereInput | ClassCallWhereInput[]
    class_id?: StringFilter<"ClassCall"> | string
    call_date?: DateTimeFilter<"ClassCall"> | Date | string
    created_date?: DateTimeNullableFilter<"ClassCall"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"ClassCall"> | Date | string | null
    deleted?: BoolFilter<"ClassCall"> | boolean
    meeting_kind_id?: StringFilter<"ClassCall"> | string
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    meeting_kind?: XOR<MeetingKindRelationFilter, MeetingKindWhereInput>
  }, "class_call_id">

  export type ClassCallOrderByWithAggregationInput = {
    class_call_id?: SortOrder
    class_id?: SortOrder
    call_date?: SortOrder
    created_date?: SortOrderInput | SortOrder
    updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    meeting_kind_id?: SortOrder
    _count?: ClassCallCountOrderByAggregateInput
    _max?: ClassCallMaxOrderByAggregateInput
    _min?: ClassCallMinOrderByAggregateInput
  }

  export type ClassCallScalarWhereWithAggregatesInput = {
    AND?: ClassCallScalarWhereWithAggregatesInput | ClassCallScalarWhereWithAggregatesInput[]
    OR?: ClassCallScalarWhereWithAggregatesInput[]
    NOT?: ClassCallScalarWhereWithAggregatesInput | ClassCallScalarWhereWithAggregatesInput[]
    class_call_id?: StringWithAggregatesFilter<"ClassCall"> | string
    class_id?: StringWithAggregatesFilter<"ClassCall"> | string
    call_date?: DateTimeWithAggregatesFilter<"ClassCall"> | Date | string
    created_date?: DateTimeNullableWithAggregatesFilter<"ClassCall"> | Date | string | null
    updated_date?: DateTimeNullableWithAggregatesFilter<"ClassCall"> | Date | string | null
    deleted?: BoolWithAggregatesFilter<"ClassCall"> | boolean
    meeting_kind_id?: StringWithAggregatesFilter<"ClassCall"> | string
  }

  export type ClassSizeWhereInput = {
    AND?: ClassSizeWhereInput | ClassSizeWhereInput[]
    OR?: ClassSizeWhereInput[]
    NOT?: ClassSizeWhereInput | ClassSizeWhereInput[]
    class_size_id?: StringFilter<"ClassSize"> | string
    class_size_name?: EnumClassSizesEnumFilter<"ClassSize"> | $Enums.ClassSizesEnum
    classes?: ClassListRelationFilter
    MentorPayModel?: MentorPayModelListRelationFilter
  }

  export type ClassSizeOrderByWithRelationInput = {
    class_size_id?: SortOrder
    class_size_name?: SortOrder
    classes?: ClassOrderByRelationAggregateInput
    MentorPayModel?: MentorPayModelOrderByRelationAggregateInput
  }

  export type ClassSizeWhereUniqueInput = Prisma.AtLeast<{
    class_size_id?: string
    class_size_name?: $Enums.ClassSizesEnum
    AND?: ClassSizeWhereInput | ClassSizeWhereInput[]
    OR?: ClassSizeWhereInput[]
    NOT?: ClassSizeWhereInput | ClassSizeWhereInput[]
    classes?: ClassListRelationFilter
    MentorPayModel?: MentorPayModelListRelationFilter
  }, "class_size_id" | "class_size_name">

  export type ClassSizeOrderByWithAggregationInput = {
    class_size_id?: SortOrder
    class_size_name?: SortOrder
    _count?: ClassSizeCountOrderByAggregateInput
    _max?: ClassSizeMaxOrderByAggregateInput
    _min?: ClassSizeMinOrderByAggregateInput
  }

  export type ClassSizeScalarWhereWithAggregatesInput = {
    AND?: ClassSizeScalarWhereWithAggregatesInput | ClassSizeScalarWhereWithAggregatesInput[]
    OR?: ClassSizeScalarWhereWithAggregatesInput[]
    NOT?: ClassSizeScalarWhereWithAggregatesInput | ClassSizeScalarWhereWithAggregatesInput[]
    class_size_id?: StringWithAggregatesFilter<"ClassSize"> | string
    class_size_name?: EnumClassSizesEnumWithAggregatesFilter<"ClassSize"> | $Enums.ClassSizesEnum
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    course_code?: StringFilter<"Course"> | string
    course_name?: StringNullableFilter<"Course"> | string | null
    course_level_id?: StringFilter<"Course"> | string
    created_date?: DateTimeNullableFilter<"Course"> | Date | string | null
    subject_code?: StringFilter<"Course"> | string
    course_level?: XOR<CourseLevelRelationFilter, CourseLevelWhereInput>
    course_advice?: CourseAdviceListRelationFilter
    classes?: ClassListRelationFilter
    subject?: XOR<SubjectNullableRelationFilter, SubjectWhereInput> | null
    CourseStructure?: CourseStructureListRelationFilter
    CourseTask?: CourseTaskListRelationFilter
    Module?: ModuleListRelationFilter
    LessonCard?: LessonCardListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    course_code?: SortOrder
    course_name?: SortOrderInput | SortOrder
    course_level_id?: SortOrder
    created_date?: SortOrderInput | SortOrder
    subject_code?: SortOrder
    course_level?: CourseLevelOrderByWithRelationInput
    course_advice?: CourseAdviceOrderByRelationAggregateInput
    classes?: ClassOrderByRelationAggregateInput
    subject?: SubjectOrderByWithRelationInput
    CourseStructure?: CourseStructureOrderByRelationAggregateInput
    CourseTask?: CourseTaskOrderByRelationAggregateInput
    Module?: ModuleOrderByRelationAggregateInput
    LessonCard?: LessonCardOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    course_code?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    course_name?: StringNullableFilter<"Course"> | string | null
    course_level_id?: StringFilter<"Course"> | string
    created_date?: DateTimeNullableFilter<"Course"> | Date | string | null
    subject_code?: StringFilter<"Course"> | string
    course_level?: XOR<CourseLevelRelationFilter, CourseLevelWhereInput>
    course_advice?: CourseAdviceListRelationFilter
    classes?: ClassListRelationFilter
    subject?: XOR<SubjectNullableRelationFilter, SubjectWhereInput> | null
    CourseStructure?: CourseStructureListRelationFilter
    CourseTask?: CourseTaskListRelationFilter
    Module?: ModuleListRelationFilter
    LessonCard?: LessonCardListRelationFilter
  }, "course_code">

  export type CourseOrderByWithAggregationInput = {
    course_code?: SortOrder
    course_name?: SortOrderInput | SortOrder
    course_level_id?: SortOrder
    created_date?: SortOrderInput | SortOrder
    subject_code?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    course_code?: StringWithAggregatesFilter<"Course"> | string
    course_name?: StringNullableWithAggregatesFilter<"Course"> | string | null
    course_level_id?: StringWithAggregatesFilter<"Course"> | string
    created_date?: DateTimeNullableWithAggregatesFilter<"Course"> | Date | string | null
    subject_code?: StringWithAggregatesFilter<"Course"> | string
  }

  export type CourseAdviceWhereInput = {
    AND?: CourseAdviceWhereInput | CourseAdviceWhereInput[]
    OR?: CourseAdviceWhereInput[]
    NOT?: CourseAdviceWhereInput | CourseAdviceWhereInput[]
    advice_id?: StringFilter<"CourseAdvice"> | string
    course_code?: StringFilter<"CourseAdvice"> | string
    advice_text?: StringNullableFilter<"CourseAdvice"> | string | null
    last_used_date?: StringNullableFilter<"CourseAdvice"> | string | null
    created_date?: StringFilter<"CourseAdvice"> | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }

  export type CourseAdviceOrderByWithRelationInput = {
    advice_id?: SortOrder
    course_code?: SortOrder
    advice_text?: SortOrderInput | SortOrder
    last_used_date?: SortOrderInput | SortOrder
    created_date?: SortOrder
    course?: CourseOrderByWithRelationInput
  }

  export type CourseAdviceWhereUniqueInput = Prisma.AtLeast<{
    advice_id?: string
    AND?: CourseAdviceWhereInput | CourseAdviceWhereInput[]
    OR?: CourseAdviceWhereInput[]
    NOT?: CourseAdviceWhereInput | CourseAdviceWhereInput[]
    course_code?: StringFilter<"CourseAdvice"> | string
    advice_text?: StringNullableFilter<"CourseAdvice"> | string | null
    last_used_date?: StringNullableFilter<"CourseAdvice"> | string | null
    created_date?: StringFilter<"CourseAdvice"> | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }, "advice_id">

  export type CourseAdviceOrderByWithAggregationInput = {
    advice_id?: SortOrder
    course_code?: SortOrder
    advice_text?: SortOrderInput | SortOrder
    last_used_date?: SortOrderInput | SortOrder
    created_date?: SortOrder
    _count?: CourseAdviceCountOrderByAggregateInput
    _max?: CourseAdviceMaxOrderByAggregateInput
    _min?: CourseAdviceMinOrderByAggregateInput
  }

  export type CourseAdviceScalarWhereWithAggregatesInput = {
    AND?: CourseAdviceScalarWhereWithAggregatesInput | CourseAdviceScalarWhereWithAggregatesInput[]
    OR?: CourseAdviceScalarWhereWithAggregatesInput[]
    NOT?: CourseAdviceScalarWhereWithAggregatesInput | CourseAdviceScalarWhereWithAggregatesInput[]
    advice_id?: StringWithAggregatesFilter<"CourseAdvice"> | string
    course_code?: StringWithAggregatesFilter<"CourseAdvice"> | string
    advice_text?: StringNullableWithAggregatesFilter<"CourseAdvice"> | string | null
    last_used_date?: StringNullableWithAggregatesFilter<"CourseAdvice"> | string | null
    created_date?: StringWithAggregatesFilter<"CourseAdvice"> | string
  }

  export type CourseTaskWhereInput = {
    AND?: CourseTaskWhereInput | CourseTaskWhereInput[]
    OR?: CourseTaskWhereInput[]
    NOT?: CourseTaskWhereInput | CourseTaskWhereInput[]
    course_task_id?: StringFilter<"CourseTask"> | string
    course_id?: StringFilter<"CourseTask"> | string
    module_id?: IntFilter<"CourseTask"> | number
    section_id?: IntFilter<"CourseTask"> | number
    lesson_id?: IntFilter<"CourseTask"> | number
    task_id?: IntFilter<"CourseTask"> | number
    question?: StringFilter<"CourseTask"> | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
    section?: XOR<SectionRelationFilter, SectionWhereInput>
    lesson?: XOR<LessonRelationFilter, LessonWhereInput>
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    ClassTask?: ClassTaskListRelationFilter
  }

  export type CourseTaskOrderByWithRelationInput = {
    course_task_id?: SortOrder
    course_id?: SortOrder
    module_id?: SortOrder
    section_id?: SortOrder
    lesson_id?: SortOrder
    task_id?: SortOrder
    question?: SortOrder
    course?: CourseOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
    section?: SectionOrderByWithRelationInput
    lesson?: LessonOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
    ClassTask?: ClassTaskOrderByRelationAggregateInput
  }

  export type CourseTaskWhereUniqueInput = Prisma.AtLeast<{
    course_task_id?: string
    AND?: CourseTaskWhereInput | CourseTaskWhereInput[]
    OR?: CourseTaskWhereInput[]
    NOT?: CourseTaskWhereInput | CourseTaskWhereInput[]
    course_id?: StringFilter<"CourseTask"> | string
    module_id?: IntFilter<"CourseTask"> | number
    section_id?: IntFilter<"CourseTask"> | number
    lesson_id?: IntFilter<"CourseTask"> | number
    task_id?: IntFilter<"CourseTask"> | number
    question?: StringFilter<"CourseTask"> | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
    section?: XOR<SectionRelationFilter, SectionWhereInput>
    lesson?: XOR<LessonRelationFilter, LessonWhereInput>
    task?: XOR<TaskRelationFilter, TaskWhereInput>
    ClassTask?: ClassTaskListRelationFilter
  }, "course_task_id">

  export type CourseTaskOrderByWithAggregationInput = {
    course_task_id?: SortOrder
    course_id?: SortOrder
    module_id?: SortOrder
    section_id?: SortOrder
    lesson_id?: SortOrder
    task_id?: SortOrder
    question?: SortOrder
    _count?: CourseTaskCountOrderByAggregateInput
    _avg?: CourseTaskAvgOrderByAggregateInput
    _max?: CourseTaskMaxOrderByAggregateInput
    _min?: CourseTaskMinOrderByAggregateInput
    _sum?: CourseTaskSumOrderByAggregateInput
  }

  export type CourseTaskScalarWhereWithAggregatesInput = {
    AND?: CourseTaskScalarWhereWithAggregatesInput | CourseTaskScalarWhereWithAggregatesInput[]
    OR?: CourseTaskScalarWhereWithAggregatesInput[]
    NOT?: CourseTaskScalarWhereWithAggregatesInput | CourseTaskScalarWhereWithAggregatesInput[]
    course_task_id?: StringWithAggregatesFilter<"CourseTask"> | string
    course_id?: StringWithAggregatesFilter<"CourseTask"> | string
    module_id?: IntWithAggregatesFilter<"CourseTask"> | number
    section_id?: IntWithAggregatesFilter<"CourseTask"> | number
    lesson_id?: IntWithAggregatesFilter<"CourseTask"> | number
    task_id?: IntWithAggregatesFilter<"CourseTask"> | number
    question?: StringWithAggregatesFilter<"CourseTask"> | string
  }

  export type CourseLevelWhereInput = {
    AND?: CourseLevelWhereInput | CourseLevelWhereInput[]
    OR?: CourseLevelWhereInput[]
    NOT?: CourseLevelWhereInput | CourseLevelWhereInput[]
    course_level_id?: StringFilter<"CourseLevel"> | string
    course_level_name?: StringFilter<"CourseLevel"> | string
    course?: CourseListRelationFilter
    CourseLevelsPerSubject?: CourseLevelsPerSubjectListRelationFilter
  }

  export type CourseLevelOrderByWithRelationInput = {
    course_level_id?: SortOrder
    course_level_name?: SortOrder
    course?: CourseOrderByRelationAggregateInput
    CourseLevelsPerSubject?: CourseLevelsPerSubjectOrderByRelationAggregateInput
  }

  export type CourseLevelWhereUniqueInput = Prisma.AtLeast<{
    course_level_id?: string
    AND?: CourseLevelWhereInput | CourseLevelWhereInput[]
    OR?: CourseLevelWhereInput[]
    NOT?: CourseLevelWhereInput | CourseLevelWhereInput[]
    course_level_name?: StringFilter<"CourseLevel"> | string
    course?: CourseListRelationFilter
    CourseLevelsPerSubject?: CourseLevelsPerSubjectListRelationFilter
  }, "course_level_id">

  export type CourseLevelOrderByWithAggregationInput = {
    course_level_id?: SortOrder
    course_level_name?: SortOrder
    _count?: CourseLevelCountOrderByAggregateInput
    _max?: CourseLevelMaxOrderByAggregateInput
    _min?: CourseLevelMinOrderByAggregateInput
  }

  export type CourseLevelScalarWhereWithAggregatesInput = {
    AND?: CourseLevelScalarWhereWithAggregatesInput | CourseLevelScalarWhereWithAggregatesInput[]
    OR?: CourseLevelScalarWhereWithAggregatesInput[]
    NOT?: CourseLevelScalarWhereWithAggregatesInput | CourseLevelScalarWhereWithAggregatesInput[]
    course_level_id?: StringWithAggregatesFilter<"CourseLevel"> | string
    course_level_name?: StringWithAggregatesFilter<"CourseLevel"> | string
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    subject_code?: StringFilter<"Subject"> | string
    subject_name?: StringFilter<"Subject"> | string
    Course?: CourseListRelationFilter
    CourseLevelsPerSubject?: CourseLevelsPerSubjectListRelationFilter
  }

  export type SubjectOrderByWithRelationInput = {
    subject_code?: SortOrder
    subject_name?: SortOrder
    Course?: CourseOrderByRelationAggregateInput
    CourseLevelsPerSubject?: CourseLevelsPerSubjectOrderByRelationAggregateInput
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    subject_code?: string
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    subject_name?: StringFilter<"Subject"> | string
    Course?: CourseListRelationFilter
    CourseLevelsPerSubject?: CourseLevelsPerSubjectListRelationFilter
  }, "subject_code">

  export type SubjectOrderByWithAggregationInput = {
    subject_code?: SortOrder
    subject_name?: SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    subject_code?: StringWithAggregatesFilter<"Subject"> | string
    subject_name?: StringWithAggregatesFilter<"Subject"> | string
  }

  export type CourseLevelsPerSubjectWhereInput = {
    AND?: CourseLevelsPerSubjectWhereInput | CourseLevelsPerSubjectWhereInput[]
    OR?: CourseLevelsPerSubjectWhereInput[]
    NOT?: CourseLevelsPerSubjectWhereInput | CourseLevelsPerSubjectWhereInput[]
    course_level_id?: StringFilter<"CourseLevelsPerSubject"> | string
    subject_code?: StringFilter<"CourseLevelsPerSubject"> | string
    course_level?: XOR<CourseLevelRelationFilter, CourseLevelWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
  }

  export type CourseLevelsPerSubjectOrderByWithRelationInput = {
    course_level_id?: SortOrder
    subject_code?: SortOrder
    course_level?: CourseLevelOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
  }

  export type CourseLevelsPerSubjectWhereUniqueInput = Prisma.AtLeast<{
    course_level_id_subject_code?: CourseLevelsPerSubjectCourse_level_idSubject_codeCompoundUniqueInput
    AND?: CourseLevelsPerSubjectWhereInput | CourseLevelsPerSubjectWhereInput[]
    OR?: CourseLevelsPerSubjectWhereInput[]
    NOT?: CourseLevelsPerSubjectWhereInput | CourseLevelsPerSubjectWhereInput[]
    course_level_id?: StringFilter<"CourseLevelsPerSubject"> | string
    subject_code?: StringFilter<"CourseLevelsPerSubject"> | string
    course_level?: XOR<CourseLevelRelationFilter, CourseLevelWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
  }, "course_level_id_subject_code">

  export type CourseLevelsPerSubjectOrderByWithAggregationInput = {
    course_level_id?: SortOrder
    subject_code?: SortOrder
    _count?: CourseLevelsPerSubjectCountOrderByAggregateInput
    _max?: CourseLevelsPerSubjectMaxOrderByAggregateInput
    _min?: CourseLevelsPerSubjectMinOrderByAggregateInput
  }

  export type CourseLevelsPerSubjectScalarWhereWithAggregatesInput = {
    AND?: CourseLevelsPerSubjectScalarWhereWithAggregatesInput | CourseLevelsPerSubjectScalarWhereWithAggregatesInput[]
    OR?: CourseLevelsPerSubjectScalarWhereWithAggregatesInput[]
    NOT?: CourseLevelsPerSubjectScalarWhereWithAggregatesInput | CourseLevelsPerSubjectScalarWhereWithAggregatesInput[]
    course_level_id?: StringWithAggregatesFilter<"CourseLevelsPerSubject"> | string
    subject_code?: StringWithAggregatesFilter<"CourseLevelsPerSubject"> | string
  }

  export type LessonWhereInput = {
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    lesson_id?: IntFilter<"Lesson"> | number
    lesson_name?: StringFilter<"Lesson"> | string
    lesson_description?: StringNullableFilter<"Lesson"> | string | null
    lesson_order?: IntFilter<"Lesson"> | number
    created_date?: DateTimeNullableFilter<"Lesson"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Lesson"> | Date | string | null
    deleted?: BoolFilter<"Lesson"> | boolean
    section_id?: IntFilter<"Lesson"> | number
    moduleModule_id?: IntNullableFilter<"Lesson"> | number | null
    section?: XOR<SectionRelationFilter, SectionWhereInput>
    tasks?: TaskListRelationFilter
    CourseStructure?: CourseStructureListRelationFilter
    CourseTask?: CourseTaskListRelationFilter
    Module?: XOR<ModuleNullableRelationFilter, ModuleWhereInput> | null
    LessonCard?: LessonCardListRelationFilter
    UserCard?: UserCardListRelationFilter
  }

  export type LessonOrderByWithRelationInput = {
    lesson_id?: SortOrder
    lesson_name?: SortOrder
    lesson_description?: SortOrderInput | SortOrder
    lesson_order?: SortOrder
    created_date?: SortOrderInput | SortOrder
    updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    section_id?: SortOrder
    moduleModule_id?: SortOrderInput | SortOrder
    section?: SectionOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
    CourseStructure?: CourseStructureOrderByRelationAggregateInput
    CourseTask?: CourseTaskOrderByRelationAggregateInput
    Module?: ModuleOrderByWithRelationInput
    LessonCard?: LessonCardOrderByRelationAggregateInput
    UserCard?: UserCardOrderByRelationAggregateInput
  }

  export type LessonWhereUniqueInput = Prisma.AtLeast<{
    lesson_id?: number
    lesson_name?: string
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    lesson_description?: StringNullableFilter<"Lesson"> | string | null
    lesson_order?: IntFilter<"Lesson"> | number
    created_date?: DateTimeNullableFilter<"Lesson"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Lesson"> | Date | string | null
    deleted?: BoolFilter<"Lesson"> | boolean
    section_id?: IntFilter<"Lesson"> | number
    moduleModule_id?: IntNullableFilter<"Lesson"> | number | null
    section?: XOR<SectionRelationFilter, SectionWhereInput>
    tasks?: TaskListRelationFilter
    CourseStructure?: CourseStructureListRelationFilter
    CourseTask?: CourseTaskListRelationFilter
    Module?: XOR<ModuleNullableRelationFilter, ModuleWhereInput> | null
    LessonCard?: LessonCardListRelationFilter
    UserCard?: UserCardListRelationFilter
  }, "lesson_id" | "lesson_name">

  export type LessonOrderByWithAggregationInput = {
    lesson_id?: SortOrder
    lesson_name?: SortOrder
    lesson_description?: SortOrderInput | SortOrder
    lesson_order?: SortOrder
    created_date?: SortOrderInput | SortOrder
    updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    section_id?: SortOrder
    moduleModule_id?: SortOrderInput | SortOrder
    _count?: LessonCountOrderByAggregateInput
    _avg?: LessonAvgOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
    _sum?: LessonSumOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    OR?: LessonScalarWhereWithAggregatesInput[]
    NOT?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    lesson_id?: IntWithAggregatesFilter<"Lesson"> | number
    lesson_name?: StringWithAggregatesFilter<"Lesson"> | string
    lesson_description?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    lesson_order?: IntWithAggregatesFilter<"Lesson"> | number
    created_date?: DateTimeNullableWithAggregatesFilter<"Lesson"> | Date | string | null
    updated_date?: DateTimeNullableWithAggregatesFilter<"Lesson"> | Date | string | null
    deleted?: BoolWithAggregatesFilter<"Lesson"> | boolean
    section_id?: IntWithAggregatesFilter<"Lesson"> | number
    moduleModule_id?: IntNullableWithAggregatesFilter<"Lesson"> | number | null
  }

  export type MentorWhereInput = {
    AND?: MentorWhereInput | MentorWhereInput[]
    OR?: MentorWhereInput[]
    NOT?: MentorWhereInput | MentorWhereInput[]
    mentor_id?: StringFilter<"Mentor"> | string
    user_id?: StringFilter<"Mentor"> | string
    mentor_description_en?: StringNullableFilter<"Mentor"> | string | null
    created_date?: DateTimeNullableFilter<"Mentor"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Mentor"> | Date | string | null
    deleted?: BoolFilter<"Mentor"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    mentor_classes?: MentorsClassesListRelationFilter
    MentorPayModel?: MentorPayModelListRelationFilter
  }

  export type MentorOrderByWithRelationInput = {
    mentor_id?: SortOrder
    user_id?: SortOrder
    mentor_description_en?: SortOrderInput | SortOrder
    created_date?: SortOrderInput | SortOrder
    updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    user?: UserOrderByWithRelationInput
    mentor_classes?: MentorsClassesOrderByRelationAggregateInput
    MentorPayModel?: MentorPayModelOrderByRelationAggregateInput
  }

  export type MentorWhereUniqueInput = Prisma.AtLeast<{
    mentor_id?: string
    AND?: MentorWhereInput | MentorWhereInput[]
    OR?: MentorWhereInput[]
    NOT?: MentorWhereInput | MentorWhereInput[]
    user_id?: StringFilter<"Mentor"> | string
    mentor_description_en?: StringNullableFilter<"Mentor"> | string | null
    created_date?: DateTimeNullableFilter<"Mentor"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Mentor"> | Date | string | null
    deleted?: BoolFilter<"Mentor"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    mentor_classes?: MentorsClassesListRelationFilter
    MentorPayModel?: MentorPayModelListRelationFilter
  }, "mentor_id">

  export type MentorOrderByWithAggregationInput = {
    mentor_id?: SortOrder
    user_id?: SortOrder
    mentor_description_en?: SortOrderInput | SortOrder
    created_date?: SortOrderInput | SortOrder
    updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    _count?: MentorCountOrderByAggregateInput
    _max?: MentorMaxOrderByAggregateInput
    _min?: MentorMinOrderByAggregateInput
  }

  export type MentorScalarWhereWithAggregatesInput = {
    AND?: MentorScalarWhereWithAggregatesInput | MentorScalarWhereWithAggregatesInput[]
    OR?: MentorScalarWhereWithAggregatesInput[]
    NOT?: MentorScalarWhereWithAggregatesInput | MentorScalarWhereWithAggregatesInput[]
    mentor_id?: StringWithAggregatesFilter<"Mentor"> | string
    user_id?: StringWithAggregatesFilter<"Mentor"> | string
    mentor_description_en?: StringNullableWithAggregatesFilter<"Mentor"> | string | null
    created_date?: DateTimeNullableWithAggregatesFilter<"Mentor"> | Date | string | null
    updated_date?: DateTimeNullableWithAggregatesFilter<"Mentor"> | Date | string | null
    deleted?: BoolWithAggregatesFilter<"Mentor"> | boolean
  }

  export type MentorsClassesWhereInput = {
    AND?: MentorsClassesWhereInput | MentorsClassesWhereInput[]
    OR?: MentorsClassesWhereInput[]
    NOT?: MentorsClassesWhereInput | MentorsClassesWhereInput[]
    mentor_id?: StringFilter<"MentorsClasses"> | string
    class_id?: StringFilter<"MentorsClasses"> | string
    created_date?: DateTimeNullableFilter<"MentorsClasses"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"MentorsClasses"> | Date | string | null
    deleted?: BoolFilter<"MentorsClasses"> | boolean
    mentor?: XOR<MentorRelationFilter, MentorWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }

  export type MentorsClassesOrderByWithRelationInput = {
    mentor_id?: SortOrder
    class_id?: SortOrder
    created_date?: SortOrderInput | SortOrder
    updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    mentor?: MentorOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
  }

  export type MentorsClassesWhereUniqueInput = Prisma.AtLeast<{
    mentor_id_class_id?: MentorsClassesMentor_idClass_idCompoundUniqueInput
    AND?: MentorsClassesWhereInput | MentorsClassesWhereInput[]
    OR?: MentorsClassesWhereInput[]
    NOT?: MentorsClassesWhereInput | MentorsClassesWhereInput[]
    mentor_id?: StringFilter<"MentorsClasses"> | string
    class_id?: StringFilter<"MentorsClasses"> | string
    created_date?: DateTimeNullableFilter<"MentorsClasses"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"MentorsClasses"> | Date | string | null
    deleted?: BoolFilter<"MentorsClasses"> | boolean
    mentor?: XOR<MentorRelationFilter, MentorWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }, "mentor_id_class_id">

  export type MentorsClassesOrderByWithAggregationInput = {
    mentor_id?: SortOrder
    class_id?: SortOrder
    created_date?: SortOrderInput | SortOrder
    updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    _count?: MentorsClassesCountOrderByAggregateInput
    _max?: MentorsClassesMaxOrderByAggregateInput
    _min?: MentorsClassesMinOrderByAggregateInput
  }

  export type MentorsClassesScalarWhereWithAggregatesInput = {
    AND?: MentorsClassesScalarWhereWithAggregatesInput | MentorsClassesScalarWhereWithAggregatesInput[]
    OR?: MentorsClassesScalarWhereWithAggregatesInput[]
    NOT?: MentorsClassesScalarWhereWithAggregatesInput | MentorsClassesScalarWhereWithAggregatesInput[]
    mentor_id?: StringWithAggregatesFilter<"MentorsClasses"> | string
    class_id?: StringWithAggregatesFilter<"MentorsClasses"> | string
    created_date?: DateTimeNullableWithAggregatesFilter<"MentorsClasses"> | Date | string | null
    updated_date?: DateTimeNullableWithAggregatesFilter<"MentorsClasses"> | Date | string | null
    deleted?: BoolWithAggregatesFilter<"MentorsClasses"> | boolean
  }

  export type MentorPayModelWhereInput = {
    AND?: MentorPayModelWhereInput | MentorPayModelWhereInput[]
    OR?: MentorPayModelWhereInput[]
    NOT?: MentorPayModelWhereInput | MentorPayModelWhereInput[]
    mentor_id?: StringFilter<"MentorPayModel"> | string
    class_size_id?: StringFilter<"MentorPayModel"> | string
    start_date?: DateTimeFilter<"MentorPayModel"> | Date | string
    pay_rate_per_hour?: FloatFilter<"MentorPayModel"> | number
    created_date?: DateTimeNullableFilter<"MentorPayModel"> | Date | string | null
    end_date?: DateTimeNullableFilter<"MentorPayModel"> | Date | string | null
    deleted?: BoolFilter<"MentorPayModel"> | boolean
    mentor?: XOR<MentorRelationFilter, MentorWhereInput>
    class_size?: XOR<ClassSizeRelationFilter, ClassSizeWhereInput>
  }

  export type MentorPayModelOrderByWithRelationInput = {
    mentor_id?: SortOrder
    class_size_id?: SortOrder
    start_date?: SortOrder
    pay_rate_per_hour?: SortOrder
    created_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    mentor?: MentorOrderByWithRelationInput
    class_size?: ClassSizeOrderByWithRelationInput
  }

  export type MentorPayModelWhereUniqueInput = Prisma.AtLeast<{
    mentor_id_class_size_id_start_date?: MentorPayModelMentor_idClass_size_idStart_dateCompoundUniqueInput
    AND?: MentorPayModelWhereInput | MentorPayModelWhereInput[]
    OR?: MentorPayModelWhereInput[]
    NOT?: MentorPayModelWhereInput | MentorPayModelWhereInput[]
    mentor_id?: StringFilter<"MentorPayModel"> | string
    class_size_id?: StringFilter<"MentorPayModel"> | string
    start_date?: DateTimeFilter<"MentorPayModel"> | Date | string
    pay_rate_per_hour?: FloatFilter<"MentorPayModel"> | number
    created_date?: DateTimeNullableFilter<"MentorPayModel"> | Date | string | null
    end_date?: DateTimeNullableFilter<"MentorPayModel"> | Date | string | null
    deleted?: BoolFilter<"MentorPayModel"> | boolean
    mentor?: XOR<MentorRelationFilter, MentorWhereInput>
    class_size?: XOR<ClassSizeRelationFilter, ClassSizeWhereInput>
  }, "mentor_id_class_size_id_start_date">

  export type MentorPayModelOrderByWithAggregationInput = {
    mentor_id?: SortOrder
    class_size_id?: SortOrder
    start_date?: SortOrder
    pay_rate_per_hour?: SortOrder
    created_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    _count?: MentorPayModelCountOrderByAggregateInput
    _avg?: MentorPayModelAvgOrderByAggregateInput
    _max?: MentorPayModelMaxOrderByAggregateInput
    _min?: MentorPayModelMinOrderByAggregateInput
    _sum?: MentorPayModelSumOrderByAggregateInput
  }

  export type MentorPayModelScalarWhereWithAggregatesInput = {
    AND?: MentorPayModelScalarWhereWithAggregatesInput | MentorPayModelScalarWhereWithAggregatesInput[]
    OR?: MentorPayModelScalarWhereWithAggregatesInput[]
    NOT?: MentorPayModelScalarWhereWithAggregatesInput | MentorPayModelScalarWhereWithAggregatesInput[]
    mentor_id?: StringWithAggregatesFilter<"MentorPayModel"> | string
    class_size_id?: StringWithAggregatesFilter<"MentorPayModel"> | string
    start_date?: DateTimeWithAggregatesFilter<"MentorPayModel"> | Date | string
    pay_rate_per_hour?: FloatWithAggregatesFilter<"MentorPayModel"> | number
    created_date?: DateTimeNullableWithAggregatesFilter<"MentorPayModel"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"MentorPayModel"> | Date | string | null
    deleted?: BoolWithAggregatesFilter<"MentorPayModel"> | boolean
  }

  export type ModuleWhereInput = {
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    module_id?: IntFilter<"Module"> | number
    module_name?: StringFilter<"Module"> | string
    module_description?: StringNullableFilter<"Module"> | string | null
    module_order?: IntFilter<"Module"> | number
    created_date?: DateTimeNullableFilter<"Module"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Module"> | Date | string | null
    deleted?: BoolFilter<"Module"> | boolean
    course_id?: StringFilter<"Module"> | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    sections?: SectionListRelationFilter
    lessons?: LessonListRelationFilter
    CourseStructure?: CourseStructureListRelationFilter
    CourseTask?: CourseTaskListRelationFilter
  }

  export type ModuleOrderByWithRelationInput = {
    module_id?: SortOrder
    module_name?: SortOrder
    module_description?: SortOrderInput | SortOrder
    module_order?: SortOrder
    created_date?: SortOrderInput | SortOrder
    updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    course_id?: SortOrder
    course?: CourseOrderByWithRelationInput
    sections?: SectionOrderByRelationAggregateInput
    lessons?: LessonOrderByRelationAggregateInput
    CourseStructure?: CourseStructureOrderByRelationAggregateInput
    CourseTask?: CourseTaskOrderByRelationAggregateInput
  }

  export type ModuleWhereUniqueInput = Prisma.AtLeast<{
    module_id?: number
    module_name?: string
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    module_description?: StringNullableFilter<"Module"> | string | null
    module_order?: IntFilter<"Module"> | number
    created_date?: DateTimeNullableFilter<"Module"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Module"> | Date | string | null
    deleted?: BoolFilter<"Module"> | boolean
    course_id?: StringFilter<"Module"> | string
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    sections?: SectionListRelationFilter
    lessons?: LessonListRelationFilter
    CourseStructure?: CourseStructureListRelationFilter
    CourseTask?: CourseTaskListRelationFilter
  }, "module_id" | "module_name">

  export type ModuleOrderByWithAggregationInput = {
    module_id?: SortOrder
    module_name?: SortOrder
    module_description?: SortOrderInput | SortOrder
    module_order?: SortOrder
    created_date?: SortOrderInput | SortOrder
    updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    course_id?: SortOrder
    _count?: ModuleCountOrderByAggregateInput
    _avg?: ModuleAvgOrderByAggregateInput
    _max?: ModuleMaxOrderByAggregateInput
    _min?: ModuleMinOrderByAggregateInput
    _sum?: ModuleSumOrderByAggregateInput
  }

  export type ModuleScalarWhereWithAggregatesInput = {
    AND?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    OR?: ModuleScalarWhereWithAggregatesInput[]
    NOT?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    module_id?: IntWithAggregatesFilter<"Module"> | number
    module_name?: StringWithAggregatesFilter<"Module"> | string
    module_description?: StringNullableWithAggregatesFilter<"Module"> | string | null
    module_order?: IntWithAggregatesFilter<"Module"> | number
    created_date?: DateTimeNullableWithAggregatesFilter<"Module"> | Date | string | null
    updated_date?: DateTimeNullableWithAggregatesFilter<"Module"> | Date | string | null
    deleted?: BoolWithAggregatesFilter<"Module"> | boolean
    course_id?: StringWithAggregatesFilter<"Module"> | string
  }

  export type SectionWhereInput = {
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    section_id?: IntFilter<"Section"> | number
    section_name?: StringFilter<"Section"> | string
    section_description?: StringNullableFilter<"Section"> | string | null
    section_order?: IntFilter<"Section"> | number
    created_date?: DateTimeNullableFilter<"Section"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Section"> | Date | string | null
    deleted?: BoolFilter<"Section"> | boolean
    module_id?: IntFilter<"Section"> | number
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
    CourseStructure?: CourseStructureListRelationFilter
    CourseTask?: CourseTaskListRelationFilter
    Lesson?: LessonListRelationFilter
  }

  export type SectionOrderByWithRelationInput = {
    section_id?: SortOrder
    section_name?: SortOrder
    section_description?: SortOrderInput | SortOrder
    section_order?: SortOrder
    created_date?: SortOrderInput | SortOrder
    updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    module_id?: SortOrder
    module?: ModuleOrderByWithRelationInput
    CourseStructure?: CourseStructureOrderByRelationAggregateInput
    CourseTask?: CourseTaskOrderByRelationAggregateInput
    Lesson?: LessonOrderByRelationAggregateInput
  }

  export type SectionWhereUniqueInput = Prisma.AtLeast<{
    section_id?: number
    section_name?: string
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    section_description?: StringNullableFilter<"Section"> | string | null
    section_order?: IntFilter<"Section"> | number
    created_date?: DateTimeNullableFilter<"Section"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Section"> | Date | string | null
    deleted?: BoolFilter<"Section"> | boolean
    module_id?: IntFilter<"Section"> | number
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
    CourseStructure?: CourseStructureListRelationFilter
    CourseTask?: CourseTaskListRelationFilter
    Lesson?: LessonListRelationFilter
  }, "section_id" | "section_name">

  export type SectionOrderByWithAggregationInput = {
    section_id?: SortOrder
    section_name?: SortOrder
    section_description?: SortOrderInput | SortOrder
    section_order?: SortOrder
    created_date?: SortOrderInput | SortOrder
    updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    module_id?: SortOrder
    _count?: SectionCountOrderByAggregateInput
    _avg?: SectionAvgOrderByAggregateInput
    _max?: SectionMaxOrderByAggregateInput
    _min?: SectionMinOrderByAggregateInput
    _sum?: SectionSumOrderByAggregateInput
  }

  export type SectionScalarWhereWithAggregatesInput = {
    AND?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    OR?: SectionScalarWhereWithAggregatesInput[]
    NOT?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    section_id?: IntWithAggregatesFilter<"Section"> | number
    section_name?: StringWithAggregatesFilter<"Section"> | string
    section_description?: StringNullableWithAggregatesFilter<"Section"> | string | null
    section_order?: IntWithAggregatesFilter<"Section"> | number
    created_date?: DateTimeNullableWithAggregatesFilter<"Section"> | Date | string | null
    updated_date?: DateTimeNullableWithAggregatesFilter<"Section"> | Date | string | null
    deleted?: BoolWithAggregatesFilter<"Section"> | boolean
    module_id?: IntWithAggregatesFilter<"Section"> | number
  }

  export type TimeOfDayWhereInput = {
    AND?: TimeOfDayWhereInput | TimeOfDayWhereInput[]
    OR?: TimeOfDayWhereInput[]
    NOT?: TimeOfDayWhereInput | TimeOfDayWhereInput[]
    time_of_day_id?: StringFilter<"TimeOfDay"> | string
    time_of_day_name?: StringFilter<"TimeOfDay"> | string
    classes?: ClassListRelationFilter
  }

  export type TimeOfDayOrderByWithRelationInput = {
    time_of_day_id?: SortOrder
    time_of_day_name?: SortOrder
    classes?: ClassOrderByRelationAggregateInput
  }

  export type TimeOfDayWhereUniqueInput = Prisma.AtLeast<{
    time_of_day_id?: string
    time_of_day_name?: string
    AND?: TimeOfDayWhereInput | TimeOfDayWhereInput[]
    OR?: TimeOfDayWhereInput[]
    NOT?: TimeOfDayWhereInput | TimeOfDayWhereInput[]
    classes?: ClassListRelationFilter
  }, "time_of_day_id" | "time_of_day_name">

  export type TimeOfDayOrderByWithAggregationInput = {
    time_of_day_id?: SortOrder
    time_of_day_name?: SortOrder
    _count?: TimeOfDayCountOrderByAggregateInput
    _max?: TimeOfDayMaxOrderByAggregateInput
    _min?: TimeOfDayMinOrderByAggregateInput
  }

  export type TimeOfDayScalarWhereWithAggregatesInput = {
    AND?: TimeOfDayScalarWhereWithAggregatesInput | TimeOfDayScalarWhereWithAggregatesInput[]
    OR?: TimeOfDayScalarWhereWithAggregatesInput[]
    NOT?: TimeOfDayScalarWhereWithAggregatesInput | TimeOfDayScalarWhereWithAggregatesInput[]
    time_of_day_id?: StringWithAggregatesFilter<"TimeOfDay"> | string
    time_of_day_name?: StringWithAggregatesFilter<"TimeOfDay"> | string
  }

  export type TuitionLangWhereInput = {
    AND?: TuitionLangWhereInput | TuitionLangWhereInput[]
    OR?: TuitionLangWhereInput[]
    NOT?: TuitionLangWhereInput | TuitionLangWhereInput[]
    tuition_lang_code?: StringFilter<"TuitionLang"> | string
    tuition_lang_name?: StringFilter<"TuitionLang"> | string
    classes?: ClassListRelationFilter
  }

  export type TuitionLangOrderByWithRelationInput = {
    tuition_lang_code?: SortOrder
    tuition_lang_name?: SortOrder
    classes?: ClassOrderByRelationAggregateInput
  }

  export type TuitionLangWhereUniqueInput = Prisma.AtLeast<{
    tuition_lang_code?: string
    tuition_lang_name?: string
    AND?: TuitionLangWhereInput | TuitionLangWhereInput[]
    OR?: TuitionLangWhereInput[]
    NOT?: TuitionLangWhereInput | TuitionLangWhereInput[]
    classes?: ClassListRelationFilter
  }, "tuition_lang_code" | "tuition_lang_name">

  export type TuitionLangOrderByWithAggregationInput = {
    tuition_lang_code?: SortOrder
    tuition_lang_name?: SortOrder
    _count?: TuitionLangCountOrderByAggregateInput
    _max?: TuitionLangMaxOrderByAggregateInput
    _min?: TuitionLangMinOrderByAggregateInput
  }

  export type TuitionLangScalarWhereWithAggregatesInput = {
    AND?: TuitionLangScalarWhereWithAggregatesInput | TuitionLangScalarWhereWithAggregatesInput[]
    OR?: TuitionLangScalarWhereWithAggregatesInput[]
    NOT?: TuitionLangScalarWhereWithAggregatesInput | TuitionLangScalarWhereWithAggregatesInput[]
    tuition_lang_code?: StringWithAggregatesFilter<"TuitionLang"> | string
    tuition_lang_name?: StringWithAggregatesFilter<"TuitionLang"> | string
  }

  export type DeckWhereInput = {
    AND?: DeckWhereInput | DeckWhereInput[]
    OR?: DeckWhereInput[]
    NOT?: DeckWhereInput | DeckWhereInput[]
    deck_id?: StringFilter<"Deck"> | string
    user_id?: StringFilter<"Deck"> | string
    deck_description?: StringNullableFilter<"Deck"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    Card?: LessonCardListRelationFilter
  }

  export type DeckOrderByWithRelationInput = {
    deck_id?: SortOrder
    user_id?: SortOrder
    deck_description?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    Card?: LessonCardOrderByRelationAggregateInput
  }

  export type DeckWhereUniqueInput = Prisma.AtLeast<{
    deck_id?: string
    AND?: DeckWhereInput | DeckWhereInput[]
    OR?: DeckWhereInput[]
    NOT?: DeckWhereInput | DeckWhereInput[]
    user_id?: StringFilter<"Deck"> | string
    deck_description?: StringNullableFilter<"Deck"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    Card?: LessonCardListRelationFilter
  }, "deck_id">

  export type DeckOrderByWithAggregationInput = {
    deck_id?: SortOrder
    user_id?: SortOrder
    deck_description?: SortOrderInput | SortOrder
    _count?: DeckCountOrderByAggregateInput
    _max?: DeckMaxOrderByAggregateInput
    _min?: DeckMinOrderByAggregateInput
  }

  export type DeckScalarWhereWithAggregatesInput = {
    AND?: DeckScalarWhereWithAggregatesInput | DeckScalarWhereWithAggregatesInput[]
    OR?: DeckScalarWhereWithAggregatesInput[]
    NOT?: DeckScalarWhereWithAggregatesInput | DeckScalarWhereWithAggregatesInput[]
    deck_id?: StringWithAggregatesFilter<"Deck"> | string
    user_id?: StringWithAggregatesFilter<"Deck"> | string
    deck_description?: StringNullableWithAggregatesFilter<"Deck"> | string | null
  }

  export type LessonCardWhereInput = {
    AND?: LessonCardWhereInput | LessonCardWhereInput[]
    OR?: LessonCardWhereInput[]
    NOT?: LessonCardWhereInput | LessonCardWhereInput[]
    card_id?: StringFilter<"LessonCard"> | string
    deck_id?: StringFilter<"LessonCard"> | string
    question?: StringFilter<"LessonCard"> | string
    answer?: StringFilter<"LessonCard"> | string
    example?: StringNullableFilter<"LessonCard"> | string | null
    course_code?: StringFilter<"LessonCard"> | string
    lesson_id?: IntFilter<"LessonCard"> | number
    deck?: XOR<DeckRelationFilter, DeckWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    lesson?: XOR<LessonRelationFilter, LessonWhereInput>
  }

  export type LessonCardOrderByWithRelationInput = {
    card_id?: SortOrder
    deck_id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    example?: SortOrderInput | SortOrder
    course_code?: SortOrder
    lesson_id?: SortOrder
    deck?: DeckOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    lesson?: LessonOrderByWithRelationInput
  }

  export type LessonCardWhereUniqueInput = Prisma.AtLeast<{
    card_id?: string
    AND?: LessonCardWhereInput | LessonCardWhereInput[]
    OR?: LessonCardWhereInput[]
    NOT?: LessonCardWhereInput | LessonCardWhereInput[]
    deck_id?: StringFilter<"LessonCard"> | string
    question?: StringFilter<"LessonCard"> | string
    answer?: StringFilter<"LessonCard"> | string
    example?: StringNullableFilter<"LessonCard"> | string | null
    course_code?: StringFilter<"LessonCard"> | string
    lesson_id?: IntFilter<"LessonCard"> | number
    deck?: XOR<DeckRelationFilter, DeckWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    lesson?: XOR<LessonRelationFilter, LessonWhereInput>
  }, "card_id">

  export type LessonCardOrderByWithAggregationInput = {
    card_id?: SortOrder
    deck_id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    example?: SortOrderInput | SortOrder
    course_code?: SortOrder
    lesson_id?: SortOrder
    _count?: LessonCardCountOrderByAggregateInput
    _avg?: LessonCardAvgOrderByAggregateInput
    _max?: LessonCardMaxOrderByAggregateInput
    _min?: LessonCardMinOrderByAggregateInput
    _sum?: LessonCardSumOrderByAggregateInput
  }

  export type LessonCardScalarWhereWithAggregatesInput = {
    AND?: LessonCardScalarWhereWithAggregatesInput | LessonCardScalarWhereWithAggregatesInput[]
    OR?: LessonCardScalarWhereWithAggregatesInput[]
    NOT?: LessonCardScalarWhereWithAggregatesInput | LessonCardScalarWhereWithAggregatesInput[]
    card_id?: StringWithAggregatesFilter<"LessonCard"> | string
    deck_id?: StringWithAggregatesFilter<"LessonCard"> | string
    question?: StringWithAggregatesFilter<"LessonCard"> | string
    answer?: StringWithAggregatesFilter<"LessonCard"> | string
    example?: StringNullableWithAggregatesFilter<"LessonCard"> | string | null
    course_code?: StringWithAggregatesFilter<"LessonCard"> | string
    lesson_id?: IntWithAggregatesFilter<"LessonCard"> | number
  }

  export type UserCardWhereInput = {
    AND?: UserCardWhereInput | UserCardWhereInput[]
    OR?: UserCardWhereInput[]
    NOT?: UserCardWhereInput | UserCardWhereInput[]
    user_card_id?: StringFilter<"UserCard"> | string
    user_id?: StringFilter<"UserCard"> | string
    question?: StringFilter<"UserCard"> | string
    answer?: StringFilter<"UserCard"> | string
    example?: StringNullableFilter<"UserCard"> | string | null
    lesson_id?: IntNullableFilter<"UserCard"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    lesson?: XOR<LessonNullableRelationFilter, LessonWhereInput> | null
  }

  export type UserCardOrderByWithRelationInput = {
    user_card_id?: SortOrder
    user_id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    example?: SortOrderInput | SortOrder
    lesson_id?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    lesson?: LessonOrderByWithRelationInput
  }

  export type UserCardWhereUniqueInput = Prisma.AtLeast<{
    user_card_id?: string
    AND?: UserCardWhereInput | UserCardWhereInput[]
    OR?: UserCardWhereInput[]
    NOT?: UserCardWhereInput | UserCardWhereInput[]
    user_id?: StringFilter<"UserCard"> | string
    question?: StringFilter<"UserCard"> | string
    answer?: StringFilter<"UserCard"> | string
    example?: StringNullableFilter<"UserCard"> | string | null
    lesson_id?: IntNullableFilter<"UserCard"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    lesson?: XOR<LessonNullableRelationFilter, LessonWhereInput> | null
  }, "user_card_id">

  export type UserCardOrderByWithAggregationInput = {
    user_card_id?: SortOrder
    user_id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    example?: SortOrderInput | SortOrder
    lesson_id?: SortOrderInput | SortOrder
    _count?: UserCardCountOrderByAggregateInput
    _avg?: UserCardAvgOrderByAggregateInput
    _max?: UserCardMaxOrderByAggregateInput
    _min?: UserCardMinOrderByAggregateInput
    _sum?: UserCardSumOrderByAggregateInput
  }

  export type UserCardScalarWhereWithAggregatesInput = {
    AND?: UserCardScalarWhereWithAggregatesInput | UserCardScalarWhereWithAggregatesInput[]
    OR?: UserCardScalarWhereWithAggregatesInput[]
    NOT?: UserCardScalarWhereWithAggregatesInput | UserCardScalarWhereWithAggregatesInput[]
    user_card_id?: StringWithAggregatesFilter<"UserCard"> | string
    user_id?: StringWithAggregatesFilter<"UserCard"> | string
    question?: StringWithAggregatesFilter<"UserCard"> | string
    answer?: StringWithAggregatesFilter<"UserCard"> | string
    example?: StringNullableWithAggregatesFilter<"UserCard"> | string | null
    lesson_id?: IntNullableWithAggregatesFilter<"UserCard"> | number | null
  }

  export type VocabularyWhereInput = {
    AND?: VocabularyWhereInput | VocabularyWhereInput[]
    OR?: VocabularyWhereInput[]
    NOT?: VocabularyWhereInput | VocabularyWhereInput[]
    vocabulary_id?: StringFilter<"Vocabulary"> | string
    user_id?: StringFilter<"Vocabulary"> | string
  }

  export type VocabularyOrderByWithRelationInput = {
    vocabulary_id?: SortOrder
    user_id?: SortOrder
  }

  export type VocabularyWhereUniqueInput = Prisma.AtLeast<{
    vocabulary_id?: string
    AND?: VocabularyWhereInput | VocabularyWhereInput[]
    OR?: VocabularyWhereInput[]
    NOT?: VocabularyWhereInput | VocabularyWhereInput[]
    user_id?: StringFilter<"Vocabulary"> | string
  }, "vocabulary_id">

  export type VocabularyOrderByWithAggregationInput = {
    vocabulary_id?: SortOrder
    user_id?: SortOrder
    _count?: VocabularyCountOrderByAggregateInput
    _max?: VocabularyMaxOrderByAggregateInput
    _min?: VocabularyMinOrderByAggregateInput
  }

  export type VocabularyScalarWhereWithAggregatesInput = {
    AND?: VocabularyScalarWhereWithAggregatesInput | VocabularyScalarWhereWithAggregatesInput[]
    OR?: VocabularyScalarWhereWithAggregatesInput[]
    NOT?: VocabularyScalarWhereWithAggregatesInput | VocabularyScalarWhereWithAggregatesInput[]
    vocabulary_id?: StringWithAggregatesFilter<"Vocabulary"> | string
    user_id?: StringWithAggregatesFilter<"Vocabulary"> | string
  }

  export type VocabularyInboxWhereInput = {
    AND?: VocabularyInboxWhereInput | VocabularyInboxWhereInput[]
    OR?: VocabularyInboxWhereInput[]
    NOT?: VocabularyInboxWhereInput | VocabularyInboxWhereInput[]
    user_id?: StringFilter<"VocabularyInbox"> | string
    question?: StringFilter<"VocabularyInbox"> | string
    answer?: StringFilter<"VocabularyInbox"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type VocabularyInboxOrderByWithRelationInput = {
    user_id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type VocabularyInboxWhereUniqueInput = Prisma.AtLeast<{
    user_id_question?: VocabularyInboxUser_idQuestionCompoundUniqueInput
    AND?: VocabularyInboxWhereInput | VocabularyInboxWhereInput[]
    OR?: VocabularyInboxWhereInput[]
    NOT?: VocabularyInboxWhereInput | VocabularyInboxWhereInput[]
    user_id?: StringFilter<"VocabularyInbox"> | string
    question?: StringFilter<"VocabularyInbox"> | string
    answer?: StringFilter<"VocabularyInbox"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "user_id_question">

  export type VocabularyInboxOrderByWithAggregationInput = {
    user_id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    _count?: VocabularyInboxCountOrderByAggregateInput
    _max?: VocabularyInboxMaxOrderByAggregateInput
    _min?: VocabularyInboxMinOrderByAggregateInput
  }

  export type VocabularyInboxScalarWhereWithAggregatesInput = {
    AND?: VocabularyInboxScalarWhereWithAggregatesInput | VocabularyInboxScalarWhereWithAggregatesInput[]
    OR?: VocabularyInboxScalarWhereWithAggregatesInput[]
    NOT?: VocabularyInboxScalarWhereWithAggregatesInput | VocabularyInboxScalarWhereWithAggregatesInput[]
    user_id?: StringWithAggregatesFilter<"VocabularyInbox"> | string
    question?: StringWithAggregatesFilter<"VocabularyInbox"> | string
    answer?: StringWithAggregatesFilter<"VocabularyInbox"> | string
  }

  export type BookingRequestWhereInput = {
    AND?: BookingRequestWhereInput | BookingRequestWhereInput[]
    OR?: BookingRequestWhereInput[]
    NOT?: BookingRequestWhereInput | BookingRequestWhereInput[]
    booking_request_id?: StringFilter<"BookingRequest"> | string
    class_id?: StringFilter<"BookingRequest"> | string
    booking_date?: DateTimeFilter<"BookingRequest"> | Date | string
    booking_request_status?: EnumBookingRequestStatusFilter<"BookingRequest"> | $Enums.BookingRequestStatus
    user_stated_name?: StringNullableFilter<"BookingRequest"> | string | null
    user_stated_phone?: StringNullableFilter<"BookingRequest"> | string | null
    user_stated_email?: StringNullableFilter<"BookingRequest"> | string | null
    user_stated_telegram_nickname?: StringNullableFilter<"BookingRequest"> | string | null
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }

  export type BookingRequestOrderByWithRelationInput = {
    booking_request_id?: SortOrder
    class_id?: SortOrder
    booking_date?: SortOrder
    booking_request_status?: SortOrder
    user_stated_name?: SortOrderInput | SortOrder
    user_stated_phone?: SortOrderInput | SortOrder
    user_stated_email?: SortOrderInput | SortOrder
    user_stated_telegram_nickname?: SortOrderInput | SortOrder
    class?: ClassOrderByWithRelationInput
  }

  export type BookingRequestWhereUniqueInput = Prisma.AtLeast<{
    booking_request_id?: string
    AND?: BookingRequestWhereInput | BookingRequestWhereInput[]
    OR?: BookingRequestWhereInput[]
    NOT?: BookingRequestWhereInput | BookingRequestWhereInput[]
    class_id?: StringFilter<"BookingRequest"> | string
    booking_date?: DateTimeFilter<"BookingRequest"> | Date | string
    booking_request_status?: EnumBookingRequestStatusFilter<"BookingRequest"> | $Enums.BookingRequestStatus
    user_stated_name?: StringNullableFilter<"BookingRequest"> | string | null
    user_stated_phone?: StringNullableFilter<"BookingRequest"> | string | null
    user_stated_email?: StringNullableFilter<"BookingRequest"> | string | null
    user_stated_telegram_nickname?: StringNullableFilter<"BookingRequest"> | string | null
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }, "booking_request_id">

  export type BookingRequestOrderByWithAggregationInput = {
    booking_request_id?: SortOrder
    class_id?: SortOrder
    booking_date?: SortOrder
    booking_request_status?: SortOrder
    user_stated_name?: SortOrderInput | SortOrder
    user_stated_phone?: SortOrderInput | SortOrder
    user_stated_email?: SortOrderInput | SortOrder
    user_stated_telegram_nickname?: SortOrderInput | SortOrder
    _count?: BookingRequestCountOrderByAggregateInput
    _max?: BookingRequestMaxOrderByAggregateInput
    _min?: BookingRequestMinOrderByAggregateInput
  }

  export type BookingRequestScalarWhereWithAggregatesInput = {
    AND?: BookingRequestScalarWhereWithAggregatesInput | BookingRequestScalarWhereWithAggregatesInput[]
    OR?: BookingRequestScalarWhereWithAggregatesInput[]
    NOT?: BookingRequestScalarWhereWithAggregatesInput | BookingRequestScalarWhereWithAggregatesInput[]
    booking_request_id?: StringWithAggregatesFilter<"BookingRequest"> | string
    class_id?: StringWithAggregatesFilter<"BookingRequest"> | string
    booking_date?: DateTimeWithAggregatesFilter<"BookingRequest"> | Date | string
    booking_request_status?: EnumBookingRequestStatusWithAggregatesFilter<"BookingRequest"> | $Enums.BookingRequestStatus
    user_stated_name?: StringNullableWithAggregatesFilter<"BookingRequest"> | string | null
    user_stated_phone?: StringNullableWithAggregatesFilter<"BookingRequest"> | string | null
    user_stated_email?: StringNullableWithAggregatesFilter<"BookingRequest"> | string | null
    user_stated_telegram_nickname?: StringNullableWithAggregatesFilter<"BookingRequest"> | string | null
  }

  export type ClassTaskWhereInput = {
    AND?: ClassTaskWhereInput | ClassTaskWhereInput[]
    OR?: ClassTaskWhereInput[]
    NOT?: ClassTaskWhereInput | ClassTaskWhereInput[]
    class_task_id?: IntFilter<"ClassTask"> | number
    course_task_id?: StringFilter<"ClassTask"> | string
    class_id?: StringFilter<"ClassTask"> | string
    course_task?: XOR<CourseTaskRelationFilter, CourseTaskWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    student_tasks?: StudentTaskListRelationFilter
    student_answer?: StudentAnswerListRelationFilter
  }

  export type ClassTaskOrderByWithRelationInput = {
    class_task_id?: SortOrder
    course_task_id?: SortOrder
    class_id?: SortOrder
    course_task?: CourseTaskOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    student_tasks?: StudentTaskOrderByRelationAggregateInput
    student_answer?: StudentAnswerOrderByRelationAggregateInput
  }

  export type ClassTaskWhereUniqueInput = Prisma.AtLeast<{
    class_task_id?: number
    AND?: ClassTaskWhereInput | ClassTaskWhereInput[]
    OR?: ClassTaskWhereInput[]
    NOT?: ClassTaskWhereInput | ClassTaskWhereInput[]
    course_task_id?: StringFilter<"ClassTask"> | string
    class_id?: StringFilter<"ClassTask"> | string
    course_task?: XOR<CourseTaskRelationFilter, CourseTaskWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    student_tasks?: StudentTaskListRelationFilter
    student_answer?: StudentAnswerListRelationFilter
  }, "class_task_id">

  export type ClassTaskOrderByWithAggregationInput = {
    class_task_id?: SortOrder
    course_task_id?: SortOrder
    class_id?: SortOrder
    _count?: ClassTaskCountOrderByAggregateInput
    _avg?: ClassTaskAvgOrderByAggregateInput
    _max?: ClassTaskMaxOrderByAggregateInput
    _min?: ClassTaskMinOrderByAggregateInput
    _sum?: ClassTaskSumOrderByAggregateInput
  }

  export type ClassTaskScalarWhereWithAggregatesInput = {
    AND?: ClassTaskScalarWhereWithAggregatesInput | ClassTaskScalarWhereWithAggregatesInput[]
    OR?: ClassTaskScalarWhereWithAggregatesInput[]
    NOT?: ClassTaskScalarWhereWithAggregatesInput | ClassTaskScalarWhereWithAggregatesInput[]
    class_task_id?: IntWithAggregatesFilter<"ClassTask"> | number
    course_task_id?: StringWithAggregatesFilter<"ClassTask"> | string
    class_id?: StringWithAggregatesFilter<"ClassTask"> | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    student_id?: StringFilter<"Student"> | string
    user_id?: StringFilter<"Student"> | string
    student_nickname?: StringNullableFilter<"Student"> | string | null
    enrolled_date?: DateTimeNullableFilter<"Student"> | Date | string | null
    left_date?: DateTimeNullableFilter<"Student"> | Date | string | null
    created_date?: DateTimeNullableFilter<"Student"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Student"> | Date | string | null
    deleted?: BoolFilter<"Student"> | boolean
    class_id?: StringFilter<"Student"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    student_task?: StudentTaskListRelationFilter
    student_answers?: StudentAnswerListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    student_id?: SortOrder
    user_id?: SortOrder
    student_nickname?: SortOrderInput | SortOrder
    enrolled_date?: SortOrderInput | SortOrder
    left_date?: SortOrderInput | SortOrder
    created_date?: SortOrderInput | SortOrder
    updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    class_id?: SortOrder
    user?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    student_task?: StudentTaskOrderByRelationAggregateInput
    student_answers?: StudentAnswerOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    student_id?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    user_id?: StringFilter<"Student"> | string
    student_nickname?: StringNullableFilter<"Student"> | string | null
    enrolled_date?: DateTimeNullableFilter<"Student"> | Date | string | null
    left_date?: DateTimeNullableFilter<"Student"> | Date | string | null
    created_date?: DateTimeNullableFilter<"Student"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Student"> | Date | string | null
    deleted?: BoolFilter<"Student"> | boolean
    class_id?: StringFilter<"Student"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    student_task?: StudentTaskListRelationFilter
    student_answers?: StudentAnswerListRelationFilter
  }, "student_id">

  export type StudentOrderByWithAggregationInput = {
    student_id?: SortOrder
    user_id?: SortOrder
    student_nickname?: SortOrderInput | SortOrder
    enrolled_date?: SortOrderInput | SortOrder
    left_date?: SortOrderInput | SortOrder
    created_date?: SortOrderInput | SortOrder
    updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    class_id?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    student_id?: StringWithAggregatesFilter<"Student"> | string
    user_id?: StringWithAggregatesFilter<"Student"> | string
    student_nickname?: StringNullableWithAggregatesFilter<"Student"> | string | null
    enrolled_date?: DateTimeNullableWithAggregatesFilter<"Student"> | Date | string | null
    left_date?: DateTimeNullableWithAggregatesFilter<"Student"> | Date | string | null
    created_date?: DateTimeNullableWithAggregatesFilter<"Student"> | Date | string | null
    updated_date?: DateTimeNullableWithAggregatesFilter<"Student"> | Date | string | null
    deleted?: BoolWithAggregatesFilter<"Student"> | boolean
    class_id?: StringWithAggregatesFilter<"Student"> | string
  }

  export type StudentAnswerWhereInput = {
    AND?: StudentAnswerWhereInput | StudentAnswerWhereInput[]
    OR?: StudentAnswerWhereInput[]
    NOT?: StudentAnswerWhereInput | StudentAnswerWhereInput[]
    student_answer_id?: IntFilter<"StudentAnswer"> | number
    student_id?: StringFilter<"StudentAnswer"> | string
    class_task_id?: IntFilter<"StudentAnswer"> | number
    answer?: StringFilter<"StudentAnswer"> | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    class_task?: XOR<ClassTaskRelationFilter, ClassTaskWhereInput>
  }

  export type StudentAnswerOrderByWithRelationInput = {
    student_answer_id?: SortOrder
    student_id?: SortOrder
    class_task_id?: SortOrder
    answer?: SortOrder
    student?: StudentOrderByWithRelationInput
    class_task?: ClassTaskOrderByWithRelationInput
  }

  export type StudentAnswerWhereUniqueInput = Prisma.AtLeast<{
    student_answer_id?: number
    AND?: StudentAnswerWhereInput | StudentAnswerWhereInput[]
    OR?: StudentAnswerWhereInput[]
    NOT?: StudentAnswerWhereInput | StudentAnswerWhereInput[]
    student_id?: StringFilter<"StudentAnswer"> | string
    class_task_id?: IntFilter<"StudentAnswer"> | number
    answer?: StringFilter<"StudentAnswer"> | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    class_task?: XOR<ClassTaskRelationFilter, ClassTaskWhereInput>
  }, "student_answer_id">

  export type StudentAnswerOrderByWithAggregationInput = {
    student_answer_id?: SortOrder
    student_id?: SortOrder
    class_task_id?: SortOrder
    answer?: SortOrder
    _count?: StudentAnswerCountOrderByAggregateInput
    _avg?: StudentAnswerAvgOrderByAggregateInput
    _max?: StudentAnswerMaxOrderByAggregateInput
    _min?: StudentAnswerMinOrderByAggregateInput
    _sum?: StudentAnswerSumOrderByAggregateInput
  }

  export type StudentAnswerScalarWhereWithAggregatesInput = {
    AND?: StudentAnswerScalarWhereWithAggregatesInput | StudentAnswerScalarWhereWithAggregatesInput[]
    OR?: StudentAnswerScalarWhereWithAggregatesInput[]
    NOT?: StudentAnswerScalarWhereWithAggregatesInput | StudentAnswerScalarWhereWithAggregatesInput[]
    student_answer_id?: IntWithAggregatesFilter<"StudentAnswer"> | number
    student_id?: StringWithAggregatesFilter<"StudentAnswer"> | string
    class_task_id?: IntWithAggregatesFilter<"StudentAnswer"> | number
    answer?: StringWithAggregatesFilter<"StudentAnswer"> | string
  }

  export type StudentTaskWhereInput = {
    AND?: StudentTaskWhereInput | StudentTaskWhereInput[]
    OR?: StudentTaskWhereInput[]
    NOT?: StudentTaskWhereInput | StudentTaskWhereInput[]
    student_task_id?: IntFilter<"StudentTask"> | number
    student_id?: StringFilter<"StudentTask"> | string
    class_task_id?: IntFilter<"StudentTask"> | number
    task_status?: EnumStudentTaskStatusFilter<"StudentTask"> | $Enums.StudentTaskStatus
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    class_task?: XOR<ClassTaskRelationFilter, ClassTaskWhereInput>
  }

  export type StudentTaskOrderByWithRelationInput = {
    student_task_id?: SortOrder
    student_id?: SortOrder
    class_task_id?: SortOrder
    task_status?: SortOrder
    student?: StudentOrderByWithRelationInput
    class_task?: ClassTaskOrderByWithRelationInput
  }

  export type StudentTaskWhereUniqueInput = Prisma.AtLeast<{
    student_task_id?: number
    AND?: StudentTaskWhereInput | StudentTaskWhereInput[]
    OR?: StudentTaskWhereInput[]
    NOT?: StudentTaskWhereInput | StudentTaskWhereInput[]
    student_id?: StringFilter<"StudentTask"> | string
    class_task_id?: IntFilter<"StudentTask"> | number
    task_status?: EnumStudentTaskStatusFilter<"StudentTask"> | $Enums.StudentTaskStatus
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    class_task?: XOR<ClassTaskRelationFilter, ClassTaskWhereInput>
  }, "student_task_id">

  export type StudentTaskOrderByWithAggregationInput = {
    student_task_id?: SortOrder
    student_id?: SortOrder
    class_task_id?: SortOrder
    task_status?: SortOrder
    _count?: StudentTaskCountOrderByAggregateInput
    _avg?: StudentTaskAvgOrderByAggregateInput
    _max?: StudentTaskMaxOrderByAggregateInput
    _min?: StudentTaskMinOrderByAggregateInput
    _sum?: StudentTaskSumOrderByAggregateInput
  }

  export type StudentTaskScalarWhereWithAggregatesInput = {
    AND?: StudentTaskScalarWhereWithAggregatesInput | StudentTaskScalarWhereWithAggregatesInput[]
    OR?: StudentTaskScalarWhereWithAggregatesInput[]
    NOT?: StudentTaskScalarWhereWithAggregatesInput | StudentTaskScalarWhereWithAggregatesInput[]
    student_task_id?: IntWithAggregatesFilter<"StudentTask"> | number
    student_id?: StringWithAggregatesFilter<"StudentTask"> | string
    class_task_id?: IntWithAggregatesFilter<"StudentTask"> | number
    task_status?: EnumStudentTaskStatusWithAggregatesFilter<"StudentTask"> | $Enums.StudentTaskStatus
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    task_id?: IntFilter<"Task"> | number
    task_description?: StringNullableFilter<"Task"> | string | null
    task_text?: StringNullableFilter<"Task"> | string | null
    task_type_id?: IntFilter<"Task"> | number
    task_context_id?: StringFilter<"Task"> | string
    task_form_id?: IntNullableFilter<"Task"> | number | null
    task_created_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    task_updated_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    deleted?: BoolFilter<"Task"> | boolean
    lesson_id?: IntFilter<"Task"> | number
    gap_map?: StringNullableFilter<"Task"> | string | null
    task_type?: XOR<TaskTypeRelationFilter, TaskTypeWhereInput>
    task_context?: XOR<TaskContextRelationFilter, TaskContextWhereInput>
    lesson?: XOR<LessonRelationFilter, LessonWhereInput>
    task_forms?: TaskFormListRelationFilter
    task_options?: TaskOptionListRelationFilter
    CourseTask?: CourseTaskListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    task_id?: SortOrder
    task_description?: SortOrderInput | SortOrder
    task_text?: SortOrderInput | SortOrder
    task_type_id?: SortOrder
    task_context_id?: SortOrder
    task_form_id?: SortOrderInput | SortOrder
    task_created_date?: SortOrderInput | SortOrder
    task_updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    lesson_id?: SortOrder
    gap_map?: SortOrderInput | SortOrder
    task_type?: TaskTypeOrderByWithRelationInput
    task_context?: TaskContextOrderByWithRelationInput
    lesson?: LessonOrderByWithRelationInput
    task_forms?: TaskFormOrderByRelationAggregateInput
    task_options?: TaskOptionOrderByRelationAggregateInput
    CourseTask?: CourseTaskOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    task_id?: number
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    task_description?: StringNullableFilter<"Task"> | string | null
    task_text?: StringNullableFilter<"Task"> | string | null
    task_type_id?: IntFilter<"Task"> | number
    task_context_id?: StringFilter<"Task"> | string
    task_form_id?: IntNullableFilter<"Task"> | number | null
    task_created_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    task_updated_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    deleted?: BoolFilter<"Task"> | boolean
    lesson_id?: IntFilter<"Task"> | number
    gap_map?: StringNullableFilter<"Task"> | string | null
    task_type?: XOR<TaskTypeRelationFilter, TaskTypeWhereInput>
    task_context?: XOR<TaskContextRelationFilter, TaskContextWhereInput>
    lesson?: XOR<LessonRelationFilter, LessonWhereInput>
    task_forms?: TaskFormListRelationFilter
    task_options?: TaskOptionListRelationFilter
    CourseTask?: CourseTaskListRelationFilter
  }, "task_id">

  export type TaskOrderByWithAggregationInput = {
    task_id?: SortOrder
    task_description?: SortOrderInput | SortOrder
    task_text?: SortOrderInput | SortOrder
    task_type_id?: SortOrder
    task_context_id?: SortOrder
    task_form_id?: SortOrderInput | SortOrder
    task_created_date?: SortOrderInput | SortOrder
    task_updated_date?: SortOrderInput | SortOrder
    deleted?: SortOrder
    lesson_id?: SortOrder
    gap_map?: SortOrderInput | SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    task_id?: IntWithAggregatesFilter<"Task"> | number
    task_description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    task_text?: StringNullableWithAggregatesFilter<"Task"> | string | null
    task_type_id?: IntWithAggregatesFilter<"Task"> | number
    task_context_id?: StringWithAggregatesFilter<"Task"> | string
    task_form_id?: IntNullableWithAggregatesFilter<"Task"> | number | null
    task_created_date?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    task_updated_date?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    deleted?: BoolWithAggregatesFilter<"Task"> | boolean
    lesson_id?: IntWithAggregatesFilter<"Task"> | number
    gap_map?: StringNullableWithAggregatesFilter<"Task"> | string | null
  }

  export type TaskFormWhereInput = {
    AND?: TaskFormWhereInput | TaskFormWhereInput[]
    OR?: TaskFormWhereInput[]
    NOT?: TaskFormWhereInput | TaskFormWhereInput[]
    task_form_id?: IntFilter<"TaskForm"> | number
    task_form_name?: StringFilter<"TaskForm"> | string
    task_form_description?: StringNullableFilter<"TaskForm"> | string | null
    task?: TaskListRelationFilter
  }

  export type TaskFormOrderByWithRelationInput = {
    task_form_id?: SortOrder
    task_form_name?: SortOrder
    task_form_description?: SortOrderInput | SortOrder
    task?: TaskOrderByRelationAggregateInput
  }

  export type TaskFormWhereUniqueInput = Prisma.AtLeast<{
    task_form_id?: number
    AND?: TaskFormWhereInput | TaskFormWhereInput[]
    OR?: TaskFormWhereInput[]
    NOT?: TaskFormWhereInput | TaskFormWhereInput[]
    task_form_name?: StringFilter<"TaskForm"> | string
    task_form_description?: StringNullableFilter<"TaskForm"> | string | null
    task?: TaskListRelationFilter
  }, "task_form_id">

  export type TaskFormOrderByWithAggregationInput = {
    task_form_id?: SortOrder
    task_form_name?: SortOrder
    task_form_description?: SortOrderInput | SortOrder
    _count?: TaskFormCountOrderByAggregateInput
    _avg?: TaskFormAvgOrderByAggregateInput
    _max?: TaskFormMaxOrderByAggregateInput
    _min?: TaskFormMinOrderByAggregateInput
    _sum?: TaskFormSumOrderByAggregateInput
  }

  export type TaskFormScalarWhereWithAggregatesInput = {
    AND?: TaskFormScalarWhereWithAggregatesInput | TaskFormScalarWhereWithAggregatesInput[]
    OR?: TaskFormScalarWhereWithAggregatesInput[]
    NOT?: TaskFormScalarWhereWithAggregatesInput | TaskFormScalarWhereWithAggregatesInput[]
    task_form_id?: IntWithAggregatesFilter<"TaskForm"> | number
    task_form_name?: StringWithAggregatesFilter<"TaskForm"> | string
    task_form_description?: StringNullableWithAggregatesFilter<"TaskForm"> | string | null
  }

  export type TaskContextWhereInput = {
    AND?: TaskContextWhereInput | TaskContextWhereInput[]
    OR?: TaskContextWhereInput[]
    NOT?: TaskContextWhereInput | TaskContextWhereInput[]
    task_context_id?: StringFilter<"TaskContext"> | string
    task_context_name?: StringFilter<"TaskContext"> | string
    task_context_description?: StringNullableFilter<"TaskContext"> | string | null
    task?: TaskListRelationFilter
  }

  export type TaskContextOrderByWithRelationInput = {
    task_context_id?: SortOrder
    task_context_name?: SortOrder
    task_context_description?: SortOrderInput | SortOrder
    task?: TaskOrderByRelationAggregateInput
  }

  export type TaskContextWhereUniqueInput = Prisma.AtLeast<{
    task_context_id?: string
    AND?: TaskContextWhereInput | TaskContextWhereInput[]
    OR?: TaskContextWhereInput[]
    NOT?: TaskContextWhereInput | TaskContextWhereInput[]
    task_context_name?: StringFilter<"TaskContext"> | string
    task_context_description?: StringNullableFilter<"TaskContext"> | string | null
    task?: TaskListRelationFilter
  }, "task_context_id">

  export type TaskContextOrderByWithAggregationInput = {
    task_context_id?: SortOrder
    task_context_name?: SortOrder
    task_context_description?: SortOrderInput | SortOrder
    _count?: TaskContextCountOrderByAggregateInput
    _max?: TaskContextMaxOrderByAggregateInput
    _min?: TaskContextMinOrderByAggregateInput
  }

  export type TaskContextScalarWhereWithAggregatesInput = {
    AND?: TaskContextScalarWhereWithAggregatesInput | TaskContextScalarWhereWithAggregatesInput[]
    OR?: TaskContextScalarWhereWithAggregatesInput[]
    NOT?: TaskContextScalarWhereWithAggregatesInput | TaskContextScalarWhereWithAggregatesInput[]
    task_context_id?: StringWithAggregatesFilter<"TaskContext"> | string
    task_context_name?: StringWithAggregatesFilter<"TaskContext"> | string
    task_context_description?: StringNullableWithAggregatesFilter<"TaskContext"> | string | null
  }

  export type TaskOptionWhereInput = {
    AND?: TaskOptionWhereInput | TaskOptionWhereInput[]
    OR?: TaskOptionWhereInput[]
    NOT?: TaskOptionWhereInput | TaskOptionWhereInput[]
    task_option_id?: IntFilter<"TaskOption"> | number
    task_id?: IntFilter<"TaskOption"> | number
    task_option_text?: StringFilter<"TaskOption"> | string
    task_option_order?: IntNullableFilter<"TaskOption"> | number | null
    is_correct?: BoolFilter<"TaskOption"> | boolean
    task?: XOR<TaskRelationFilter, TaskWhereInput>
  }

  export type TaskOptionOrderByWithRelationInput = {
    task_option_id?: SortOrder
    task_id?: SortOrder
    task_option_text?: SortOrder
    task_option_order?: SortOrderInput | SortOrder
    is_correct?: SortOrder
    task?: TaskOrderByWithRelationInput
  }

  export type TaskOptionWhereUniqueInput = Prisma.AtLeast<{
    task_option_id?: number
    AND?: TaskOptionWhereInput | TaskOptionWhereInput[]
    OR?: TaskOptionWhereInput[]
    NOT?: TaskOptionWhereInput | TaskOptionWhereInput[]
    task_id?: IntFilter<"TaskOption"> | number
    task_option_text?: StringFilter<"TaskOption"> | string
    task_option_order?: IntNullableFilter<"TaskOption"> | number | null
    is_correct?: BoolFilter<"TaskOption"> | boolean
    task?: XOR<TaskRelationFilter, TaskWhereInput>
  }, "task_option_id">

  export type TaskOptionOrderByWithAggregationInput = {
    task_option_id?: SortOrder
    task_id?: SortOrder
    task_option_text?: SortOrder
    task_option_order?: SortOrderInput | SortOrder
    is_correct?: SortOrder
    _count?: TaskOptionCountOrderByAggregateInput
    _avg?: TaskOptionAvgOrderByAggregateInput
    _max?: TaskOptionMaxOrderByAggregateInput
    _min?: TaskOptionMinOrderByAggregateInput
    _sum?: TaskOptionSumOrderByAggregateInput
  }

  export type TaskOptionScalarWhereWithAggregatesInput = {
    AND?: TaskOptionScalarWhereWithAggregatesInput | TaskOptionScalarWhereWithAggregatesInput[]
    OR?: TaskOptionScalarWhereWithAggregatesInput[]
    NOT?: TaskOptionScalarWhereWithAggregatesInput | TaskOptionScalarWhereWithAggregatesInput[]
    task_option_id?: IntWithAggregatesFilter<"TaskOption"> | number
    task_id?: IntWithAggregatesFilter<"TaskOption"> | number
    task_option_text?: StringWithAggregatesFilter<"TaskOption"> | string
    task_option_order?: IntNullableWithAggregatesFilter<"TaskOption"> | number | null
    is_correct?: BoolWithAggregatesFilter<"TaskOption"> | boolean
  }

  export type TaskTypeWhereInput = {
    AND?: TaskTypeWhereInput | TaskTypeWhereInput[]
    OR?: TaskTypeWhereInput[]
    NOT?: TaskTypeWhereInput | TaskTypeWhereInput[]
    task_type_id?: IntFilter<"TaskType"> | number
    task_type_name?: StringFilter<"TaskType"> | string
    task_type_description?: StringNullableFilter<"TaskType"> | string | null
    task?: TaskListRelationFilter
  }

  export type TaskTypeOrderByWithRelationInput = {
    task_type_id?: SortOrder
    task_type_name?: SortOrder
    task_type_description?: SortOrderInput | SortOrder
    task?: TaskOrderByRelationAggregateInput
  }

  export type TaskTypeWhereUniqueInput = Prisma.AtLeast<{
    task_type_id?: number
    AND?: TaskTypeWhereInput | TaskTypeWhereInput[]
    OR?: TaskTypeWhereInput[]
    NOT?: TaskTypeWhereInput | TaskTypeWhereInput[]
    task_type_name?: StringFilter<"TaskType"> | string
    task_type_description?: StringNullableFilter<"TaskType"> | string | null
    task?: TaskListRelationFilter
  }, "task_type_id">

  export type TaskTypeOrderByWithAggregationInput = {
    task_type_id?: SortOrder
    task_type_name?: SortOrder
    task_type_description?: SortOrderInput | SortOrder
    _count?: TaskTypeCountOrderByAggregateInput
    _avg?: TaskTypeAvgOrderByAggregateInput
    _max?: TaskTypeMaxOrderByAggregateInput
    _min?: TaskTypeMinOrderByAggregateInput
    _sum?: TaskTypeSumOrderByAggregateInput
  }

  export type TaskTypeScalarWhereWithAggregatesInput = {
    AND?: TaskTypeScalarWhereWithAggregatesInput | TaskTypeScalarWhereWithAggregatesInput[]
    OR?: TaskTypeScalarWhereWithAggregatesInput[]
    NOT?: TaskTypeScalarWhereWithAggregatesInput | TaskTypeScalarWhereWithAggregatesInput[]
    task_type_id?: IntWithAggregatesFilter<"TaskType"> | number
    task_type_name?: StringWithAggregatesFilter<"TaskType"> | string
    task_type_description?: StringNullableWithAggregatesFilter<"TaskType"> | string | null
  }

  export type UserCreateInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_roles?: UserRoleCreateNestedManyWithoutUserInput
    user_application_preferences?: UserApplicationPreferencesCreateNestedManyWithoutUserInput
    mentor?: MentorCreateNestedManyWithoutUserInput
    is_student_of?: StudentCreateNestedManyWithoutUserInput
    DataRemovalRequest?: DataRemovalRequestCreateNestedManyWithoutUserInput
    Deck?: DeckCreateNestedManyWithoutUserInput
    UserCard?: UserCardCreateNestedManyWithoutUserInput
    VocabularyInbox?: VocabularyInboxCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    user_application_preferences?: UserApplicationPreferencesUncheckedCreateNestedManyWithoutUserInput
    mentor?: MentorUncheckedCreateNestedManyWithoutUserInput
    is_student_of?: StudentUncheckedCreateNestedManyWithoutUserInput
    DataRemovalRequest?: DataRemovalRequestUncheckedCreateNestedManyWithoutUserInput
    Deck?: DeckUncheckedCreateNestedManyWithoutUserInput
    UserCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    VocabularyInbox?: VocabularyInboxUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_roles?: UserRoleUpdateManyWithoutUserNestedInput
    user_application_preferences?: UserApplicationPreferencesUpdateManyWithoutUserNestedInput
    mentor?: MentorUpdateManyWithoutUserNestedInput
    is_student_of?: StudentUpdateManyWithoutUserNestedInput
    DataRemovalRequest?: DataRemovalRequestUpdateManyWithoutUserNestedInput
    Deck?: DeckUpdateManyWithoutUserNestedInput
    UserCard?: UserCardUpdateManyWithoutUserNestedInput
    VocabularyInbox?: VocabularyInboxUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    user_application_preferences?: UserApplicationPreferencesUncheckedUpdateManyWithoutUserNestedInput
    mentor?: MentorUncheckedUpdateManyWithoutUserNestedInput
    is_student_of?: StudentUncheckedUpdateManyWithoutUserNestedInput
    DataRemovalRequest?: DataRemovalRequestUncheckedUpdateManyWithoutUserNestedInput
    Deck?: DeckUncheckedUpdateManyWithoutUserNestedInput
    UserCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    VocabularyInbox?: VocabularyInboxUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
  }

  export type UserUpdateManyMutationInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoleCreateInput = {
    role_id: string
    role_name?: string | null
    role_description?: string | null
    user_roles?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    role_id: string
    role_name?: string | null
    role_description?: string | null
    user_roles?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    role_id?: StringFieldUpdateOperationsInput | string
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    role_description?: NullableStringFieldUpdateOperationsInput | string | null
    user_roles?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    role_id?: StringFieldUpdateOperationsInput | string
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    role_description?: NullableStringFieldUpdateOperationsInput | string | null
    user_roles?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    role_id: string
    role_name?: string | null
    role_description?: string | null
  }

  export type RoleUpdateManyMutationInput = {
    role_id?: StringFieldUpdateOperationsInput | string
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    role_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleUncheckedUpdateManyInput = {
    role_id?: StringFieldUpdateOperationsInput | string
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    role_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleCreateInput = {
    user: UserCreateNestedOneWithoutUser_rolesInput
    role: RoleCreateNestedOneWithoutUser_rolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    user_email: string
    role_id: string
  }

  export type UserRoleUpdateInput = {
    user?: UserUpdateOneRequiredWithoutUser_rolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUser_rolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateManyInput = {
    user_email: string
    role_id: string
  }

  export type UserRoleUpdateManyMutationInput = {

  }

  export type UserRoleUncheckedUpdateManyInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type UserApplicationPreferencesCreateInput = {
    accepted_privacy_policy: boolean
    accepted_cookies_policy: boolean
    user: UserCreateNestedOneWithoutUser_application_preferencesInput
    application: ApplicationCreateNestedOneWithoutUser_application_preferencesInput
  }

  export type UserApplicationPreferencesUncheckedCreateInput = {
    user_email: string
    application_id: string
    accepted_privacy_policy: boolean
    accepted_cookies_policy: boolean
  }

  export type UserApplicationPreferencesUpdateInput = {
    accepted_privacy_policy?: BoolFieldUpdateOperationsInput | boolean
    accepted_cookies_policy?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutUser_application_preferencesNestedInput
    application?: ApplicationUpdateOneRequiredWithoutUser_application_preferencesNestedInput
  }

  export type UserApplicationPreferencesUncheckedUpdateInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    application_id?: StringFieldUpdateOperationsInput | string
    accepted_privacy_policy?: BoolFieldUpdateOperationsInput | boolean
    accepted_cookies_policy?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserApplicationPreferencesCreateManyInput = {
    user_email: string
    application_id: string
    accepted_privacy_policy: boolean
    accepted_cookies_policy: boolean
  }

  export type UserApplicationPreferencesUpdateManyMutationInput = {
    accepted_privacy_policy?: BoolFieldUpdateOperationsInput | boolean
    accepted_cookies_policy?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserApplicationPreferencesUncheckedUpdateManyInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    application_id?: StringFieldUpdateOperationsInput | string
    accepted_privacy_policy?: BoolFieldUpdateOperationsInput | boolean
    accepted_cookies_policy?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApplicationCreateInput = {
    application_id: string
    application_name: string
    application_description?: string | null
    application_url?: string | null
    user_application_preferences?: UserApplicationPreferencesCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUncheckedCreateInput = {
    application_id: string
    application_name: string
    application_description?: string | null
    application_url?: string | null
    user_application_preferences?: UserApplicationPreferencesUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type ApplicationUpdateInput = {
    application_id?: StringFieldUpdateOperationsInput | string
    application_name?: StringFieldUpdateOperationsInput | string
    application_description?: NullableStringFieldUpdateOperationsInput | string | null
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    user_application_preferences?: UserApplicationPreferencesUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationUncheckedUpdateInput = {
    application_id?: StringFieldUpdateOperationsInput | string
    application_name?: StringFieldUpdateOperationsInput | string
    application_description?: NullableStringFieldUpdateOperationsInput | string | null
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
    user_application_preferences?: UserApplicationPreferencesUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type ApplicationCreateManyInput = {
    application_id: string
    application_name: string
    application_description?: string | null
    application_url?: string | null
  }

  export type ApplicationUpdateManyMutationInput = {
    application_id?: StringFieldUpdateOperationsInput | string
    application_name?: StringFieldUpdateOperationsInput | string
    application_description?: NullableStringFieldUpdateOperationsInput | string | null
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationUncheckedUpdateManyInput = {
    application_id?: StringFieldUpdateOperationsInput | string
    application_name?: StringFieldUpdateOperationsInput | string
    application_description?: NullableStringFieldUpdateOperationsInput | string | null
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataRemovalRequestCreateInput = {
    data_removal_request: string
    data_removal_status?: $Enums.DataRemovalStatusEnum
    data_removal_date: Date | string
    user: UserCreateNestedOneWithoutDataRemovalRequestInput
  }

  export type DataRemovalRequestUncheckedCreateInput = {
    data_removal_request_id?: number
    user_email: string
    data_removal_request: string
    data_removal_status?: $Enums.DataRemovalStatusEnum
    data_removal_date: Date | string
  }

  export type DataRemovalRequestUpdateInput = {
    data_removal_request?: StringFieldUpdateOperationsInput | string
    data_removal_status?: EnumDataRemovalStatusEnumFieldUpdateOperationsInput | $Enums.DataRemovalStatusEnum
    data_removal_date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDataRemovalRequestNestedInput
  }

  export type DataRemovalRequestUncheckedUpdateInput = {
    data_removal_request_id?: IntFieldUpdateOperationsInput | number
    user_email?: StringFieldUpdateOperationsInput | string
    data_removal_request?: StringFieldUpdateOperationsInput | string
    data_removal_status?: EnumDataRemovalStatusEnumFieldUpdateOperationsInput | $Enums.DataRemovalStatusEnum
    data_removal_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRemovalRequestCreateManyInput = {
    data_removal_request_id?: number
    user_email: string
    data_removal_request: string
    data_removal_status?: $Enums.DataRemovalStatusEnum
    data_removal_date: Date | string
  }

  export type DataRemovalRequestUpdateManyMutationInput = {
    data_removal_request?: StringFieldUpdateOperationsInput | string
    data_removal_status?: EnumDataRemovalStatusEnumFieldUpdateOperationsInput | $Enums.DataRemovalStatusEnum
    data_removal_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRemovalRequestUncheckedUpdateManyInput = {
    data_removal_request_id?: IntFieldUpdateOperationsInput | number
    user_email?: StringFieldUpdateOperationsInput | string
    data_removal_request?: StringFieldUpdateOperationsInput | string
    data_removal_status?: EnumDataRemovalStatusEnumFieldUpdateOperationsInput | $Enums.DataRemovalStatusEnum
    data_removal_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingKindCreateInput = {
    meeting_kind_id: string
    meeting_kind_name: string
    class_calls?: ClassCallCreateNestedManyWithoutMeeting_kindInput
  }

  export type MeetingKindUncheckedCreateInput = {
    meeting_kind_id: string
    meeting_kind_name: string
    class_calls?: ClassCallUncheckedCreateNestedManyWithoutMeeting_kindInput
  }

  export type MeetingKindUpdateInput = {
    meeting_kind_id?: StringFieldUpdateOperationsInput | string
    meeting_kind_name?: StringFieldUpdateOperationsInput | string
    class_calls?: ClassCallUpdateManyWithoutMeeting_kindNestedInput
  }

  export type MeetingKindUncheckedUpdateInput = {
    meeting_kind_id?: StringFieldUpdateOperationsInput | string
    meeting_kind_name?: StringFieldUpdateOperationsInput | string
    class_calls?: ClassCallUncheckedUpdateManyWithoutMeeting_kindNestedInput
  }

  export type MeetingKindCreateManyInput = {
    meeting_kind_id: string
    meeting_kind_name: string
  }

  export type MeetingKindUpdateManyMutationInput = {
    meeting_kind_id?: StringFieldUpdateOperationsInput | string
    meeting_kind_name?: StringFieldUpdateOperationsInput | string
  }

  export type MeetingKindUncheckedUpdateManyInput = {
    meeting_kind_id?: StringFieldUpdateOperationsInput | string
    meeting_kind_name?: StringFieldUpdateOperationsInput | string
  }

  export type CourseStructureCreateInput = {
    course: CourseCreateNestedOneWithoutCourseStructureInput
    module: ModuleCreateNestedOneWithoutCourseStructureInput
    section: SectionCreateNestedOneWithoutCourseStructureInput
    lesson: LessonCreateNestedOneWithoutCourseStructureInput
  }

  export type CourseStructureUncheckedCreateInput = {
    course_id: string
    module_id: number
    section_id: number
    lesson_id: number
  }

  export type CourseStructureUpdateInput = {
    course?: CourseUpdateOneRequiredWithoutCourseStructureNestedInput
    module?: ModuleUpdateOneRequiredWithoutCourseStructureNestedInput
    section?: SectionUpdateOneRequiredWithoutCourseStructureNestedInput
    lesson?: LessonUpdateOneRequiredWithoutCourseStructureNestedInput
  }

  export type CourseStructureUncheckedUpdateInput = {
    course_id?: StringFieldUpdateOperationsInput | string
    module_id?: IntFieldUpdateOperationsInput | number
    section_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
  }

  export type CourseStructureCreateManyInput = {
    course_id: string
    module_id: number
    section_id: number
    lesson_id: number
  }

  export type CourseStructureUpdateManyMutationInput = {

  }

  export type CourseStructureUncheckedUpdateManyInput = {
    course_id?: StringFieldUpdateOperationsInput | string
    module_id?: IntFieldUpdateOperationsInput | number
    section_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClassCreateInput = {
    class_id: string
    class_code?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class_size_id: ClassSizeCreateNestedOneWithoutClassesInput
    is_instance_of_course: CourseCreateNestedOneWithoutClassesInput
    time_of_day: TimeOfDayCreateNestedOneWithoutClassesInput
    tuition_lang: TuitionLangCreateNestedOneWithoutClassesInput
    mentor_classes?: MentorsClassesCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestCreateNestedManyWithoutClassInput
    class_calls?: ClassCallCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    class_id: string
    class_code?: string | null
    course_id: string
    start_date: Date | string
    end_date?: Date | string | null
    tuition_lang_code: string
    time_of_day_id: string
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    classSizeClass_size_id: string
    mentor_classes?: MentorsClassesUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestUncheckedCreateNestedManyWithoutClassInput
    class_calls?: ClassCallUncheckedCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class_size_id?: ClassSizeUpdateOneRequiredWithoutClassesNestedInput
    is_instance_of_course?: CourseUpdateOneRequiredWithoutClassesNestedInput
    time_of_day?: TimeOfDayUpdateOneRequiredWithoutClassesNestedInput
    tuition_lang?: TuitionLangUpdateOneRequiredWithoutClassesNestedInput
    mentor_classes?: MentorsClassesUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    course_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    classSizeClass_size_id?: StringFieldUpdateOperationsInput | string
    mentor_classes?: MentorsClassesUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUncheckedUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUncheckedUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    class_id: string
    class_code?: string | null
    course_id: string
    start_date: Date | string
    end_date?: Date | string | null
    tuition_lang_code: string
    time_of_day_id: string
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    classSizeClass_size_id: string
  }

  export type ClassUpdateManyMutationInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassUncheckedUpdateManyInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    course_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    classSizeClass_size_id?: StringFieldUpdateOperationsInput | string
  }

  export type ClassCallCreateInput = {
    class_call_id: string
    call_date: Date | string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class: ClassCreateNestedOneWithoutClass_callsInput
    meeting_kind: MeetingKindCreateNestedOneWithoutClass_callsInput
  }

  export type ClassCallUncheckedCreateInput = {
    class_call_id: string
    class_id: string
    call_date: Date | string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    meeting_kind_id: string
  }

  export type ClassCallUpdateInput = {
    class_call_id?: StringFieldUpdateOperationsInput | string
    call_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassUpdateOneRequiredWithoutClass_callsNestedInput
    meeting_kind?: MeetingKindUpdateOneRequiredWithoutClass_callsNestedInput
  }

  export type ClassCallUncheckedUpdateInput = {
    class_call_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    call_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    meeting_kind_id?: StringFieldUpdateOperationsInput | string
  }

  export type ClassCallCreateManyInput = {
    class_call_id: string
    class_id: string
    call_date: Date | string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    meeting_kind_id: string
  }

  export type ClassCallUpdateManyMutationInput = {
    class_call_id?: StringFieldUpdateOperationsInput | string
    call_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassCallUncheckedUpdateManyInput = {
    class_call_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    call_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    meeting_kind_id?: StringFieldUpdateOperationsInput | string
  }

  export type ClassSizeCreateInput = {
    class_size_id: string
    class_size_name: $Enums.ClassSizesEnum
    classes?: ClassCreateNestedManyWithoutClass_size_idInput
    MentorPayModel?: MentorPayModelCreateNestedManyWithoutClass_sizeInput
  }

  export type ClassSizeUncheckedCreateInput = {
    class_size_id: string
    class_size_name: $Enums.ClassSizesEnum
    classes?: ClassUncheckedCreateNestedManyWithoutClass_size_idInput
    MentorPayModel?: MentorPayModelUncheckedCreateNestedManyWithoutClass_sizeInput
  }

  export type ClassSizeUpdateInput = {
    class_size_id?: StringFieldUpdateOperationsInput | string
    class_size_name?: EnumClassSizesEnumFieldUpdateOperationsInput | $Enums.ClassSizesEnum
    classes?: ClassUpdateManyWithoutClass_size_idNestedInput
    MentorPayModel?: MentorPayModelUpdateManyWithoutClass_sizeNestedInput
  }

  export type ClassSizeUncheckedUpdateInput = {
    class_size_id?: StringFieldUpdateOperationsInput | string
    class_size_name?: EnumClassSizesEnumFieldUpdateOperationsInput | $Enums.ClassSizesEnum
    classes?: ClassUncheckedUpdateManyWithoutClass_size_idNestedInput
    MentorPayModel?: MentorPayModelUncheckedUpdateManyWithoutClass_sizeNestedInput
  }

  export type ClassSizeCreateManyInput = {
    class_size_id: string
    class_size_name: $Enums.ClassSizesEnum
  }

  export type ClassSizeUpdateManyMutationInput = {
    class_size_id?: StringFieldUpdateOperationsInput | string
    class_size_name?: EnumClassSizesEnumFieldUpdateOperationsInput | $Enums.ClassSizesEnum
  }

  export type ClassSizeUncheckedUpdateManyInput = {
    class_size_id?: StringFieldUpdateOperationsInput | string
    class_size_name?: EnumClassSizesEnumFieldUpdateOperationsInput | $Enums.ClassSizesEnum
  }

  export type CourseCreateInput = {
    course_code: string
    course_name?: string | null
    created_date?: Date | string | null
    course_level: CourseLevelCreateNestedOneWithoutCourseInput
    course_advice?: CourseAdviceCreateNestedManyWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutIs_instance_of_courseInput
    subject?: SubjectCreateNestedOneWithoutCourseInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutCourseInput
    CourseTask?: CourseTaskCreateNestedManyWithoutCourseInput
    Module?: ModuleCreateNestedManyWithoutCourseInput
    LessonCard?: LessonCardCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    course_code: string
    course_name?: string | null
    course_level_id: string
    created_date?: Date | string | null
    subject_code: string
    course_advice?: CourseAdviceUncheckedCreateNestedManyWithoutCourseInput
    classes?: ClassUncheckedCreateNestedManyWithoutIs_instance_of_courseInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutCourseInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutCourseInput
    Module?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    LessonCard?: LessonCardUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_level?: CourseLevelUpdateOneRequiredWithoutCourseNestedInput
    course_advice?: CourseAdviceUpdateManyWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutIs_instance_of_courseNestedInput
    subject?: SubjectUpdateOneWithoutCourseNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutCourseNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutCourseNestedInput
    Module?: ModuleUpdateManyWithoutCourseNestedInput
    LessonCard?: LessonCardUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    course_level_id?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject_code?: StringFieldUpdateOperationsInput | string
    course_advice?: CourseAdviceUncheckedUpdateManyWithoutCourseNestedInput
    classes?: ClassUncheckedUpdateManyWithoutIs_instance_of_courseNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutCourseNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutCourseNestedInput
    Module?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    LessonCard?: LessonCardUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    course_code: string
    course_name?: string | null
    course_level_id: string
    created_date?: Date | string | null
    subject_code: string
  }

  export type CourseUpdateManyMutationInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseUncheckedUpdateManyInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    course_level_id?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject_code?: StringFieldUpdateOperationsInput | string
  }

  export type CourseAdviceCreateInput = {
    advice_id: string
    advice_text?: string | null
    last_used_date?: string | null
    created_date: string
    course: CourseCreateNestedOneWithoutCourse_adviceInput
  }

  export type CourseAdviceUncheckedCreateInput = {
    advice_id: string
    course_code: string
    advice_text?: string | null
    last_used_date?: string | null
    created_date: string
  }

  export type CourseAdviceUpdateInput = {
    advice_id?: StringFieldUpdateOperationsInput | string
    advice_text?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutCourse_adviceNestedInput
  }

  export type CourseAdviceUncheckedUpdateInput = {
    advice_id?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    advice_text?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: StringFieldUpdateOperationsInput | string
  }

  export type CourseAdviceCreateManyInput = {
    advice_id: string
    course_code: string
    advice_text?: string | null
    last_used_date?: string | null
    created_date: string
  }

  export type CourseAdviceUpdateManyMutationInput = {
    advice_id?: StringFieldUpdateOperationsInput | string
    advice_text?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: StringFieldUpdateOperationsInput | string
  }

  export type CourseAdviceUncheckedUpdateManyInput = {
    advice_id?: StringFieldUpdateOperationsInput | string
    course_code?: StringFieldUpdateOperationsInput | string
    advice_text?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: StringFieldUpdateOperationsInput | string
  }

  export type CourseTaskCreateInput = {
    course_task_id: string
    question: string
    course: CourseCreateNestedOneWithoutCourseTaskInput
    module: ModuleCreateNestedOneWithoutCourseTaskInput
    section: SectionCreateNestedOneWithoutCourseTaskInput
    lesson: LessonCreateNestedOneWithoutCourseTaskInput
    task: TaskCreateNestedOneWithoutCourseTaskInput
    ClassTask?: ClassTaskCreateNestedManyWithoutCourse_taskInput
  }

  export type CourseTaskUncheckedCreateInput = {
    course_task_id: string
    course_id: string
    module_id: number
    section_id: number
    lesson_id: number
    task_id: number
    question: string
    ClassTask?: ClassTaskUncheckedCreateNestedManyWithoutCourse_taskInput
  }

  export type CourseTaskUpdateInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutCourseTaskNestedInput
    module?: ModuleUpdateOneRequiredWithoutCourseTaskNestedInput
    section?: SectionUpdateOneRequiredWithoutCourseTaskNestedInput
    lesson?: LessonUpdateOneRequiredWithoutCourseTaskNestedInput
    task?: TaskUpdateOneRequiredWithoutCourseTaskNestedInput
    ClassTask?: ClassTaskUpdateManyWithoutCourse_taskNestedInput
  }

  export type CourseTaskUncheckedUpdateInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    module_id?: IntFieldUpdateOperationsInput | number
    section_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    ClassTask?: ClassTaskUncheckedUpdateManyWithoutCourse_taskNestedInput
  }

  export type CourseTaskCreateManyInput = {
    course_task_id: string
    course_id: string
    module_id: number
    section_id: number
    lesson_id: number
    task_id: number
    question: string
  }

  export type CourseTaskUpdateManyMutationInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
  }

  export type CourseTaskUncheckedUpdateManyInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    module_id?: IntFieldUpdateOperationsInput | number
    section_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
  }

  export type CourseLevelCreateInput = {
    course_level_id: string
    course_level_name: string
    course?: CourseCreateNestedManyWithoutCourse_levelInput
    CourseLevelsPerSubject?: CourseLevelsPerSubjectCreateNestedManyWithoutCourse_levelInput
  }

  export type CourseLevelUncheckedCreateInput = {
    course_level_id: string
    course_level_name: string
    course?: CourseUncheckedCreateNestedManyWithoutCourse_levelInput
    CourseLevelsPerSubject?: CourseLevelsPerSubjectUncheckedCreateNestedManyWithoutCourse_levelInput
  }

  export type CourseLevelUpdateInput = {
    course_level_id?: StringFieldUpdateOperationsInput | string
    course_level_name?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateManyWithoutCourse_levelNestedInput
    CourseLevelsPerSubject?: CourseLevelsPerSubjectUpdateManyWithoutCourse_levelNestedInput
  }

  export type CourseLevelUncheckedUpdateInput = {
    course_level_id?: StringFieldUpdateOperationsInput | string
    course_level_name?: StringFieldUpdateOperationsInput | string
    course?: CourseUncheckedUpdateManyWithoutCourse_levelNestedInput
    CourseLevelsPerSubject?: CourseLevelsPerSubjectUncheckedUpdateManyWithoutCourse_levelNestedInput
  }

  export type CourseLevelCreateManyInput = {
    course_level_id: string
    course_level_name: string
  }

  export type CourseLevelUpdateManyMutationInput = {
    course_level_id?: StringFieldUpdateOperationsInput | string
    course_level_name?: StringFieldUpdateOperationsInput | string
  }

  export type CourseLevelUncheckedUpdateManyInput = {
    course_level_id?: StringFieldUpdateOperationsInput | string
    course_level_name?: StringFieldUpdateOperationsInput | string
  }

  export type SubjectCreateInput = {
    subject_code: string
    subject_name: string
    Course?: CourseCreateNestedManyWithoutSubjectInput
    CourseLevelsPerSubject?: CourseLevelsPerSubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateInput = {
    subject_code: string
    subject_name: string
    Course?: CourseUncheckedCreateNestedManyWithoutSubjectInput
    CourseLevelsPerSubject?: CourseLevelsPerSubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUpdateInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
    subject_name?: StringFieldUpdateOperationsInput | string
    Course?: CourseUpdateManyWithoutSubjectNestedInput
    CourseLevelsPerSubject?: CourseLevelsPerSubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
    subject_name?: StringFieldUpdateOperationsInput | string
    Course?: CourseUncheckedUpdateManyWithoutSubjectNestedInput
    CourseLevelsPerSubject?: CourseLevelsPerSubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateManyInput = {
    subject_code: string
    subject_name: string
  }

  export type SubjectUpdateManyMutationInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
    subject_name?: StringFieldUpdateOperationsInput | string
  }

  export type SubjectUncheckedUpdateManyInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
    subject_name?: StringFieldUpdateOperationsInput | string
  }

  export type CourseLevelsPerSubjectCreateInput = {
    course_level: CourseLevelCreateNestedOneWithoutCourseLevelsPerSubjectInput
    subject: SubjectCreateNestedOneWithoutCourseLevelsPerSubjectInput
  }

  export type CourseLevelsPerSubjectUncheckedCreateInput = {
    course_level_id: string
    subject_code: string
  }

  export type CourseLevelsPerSubjectUpdateInput = {
    course_level?: CourseLevelUpdateOneRequiredWithoutCourseLevelsPerSubjectNestedInput
    subject?: SubjectUpdateOneRequiredWithoutCourseLevelsPerSubjectNestedInput
  }

  export type CourseLevelsPerSubjectUncheckedUpdateInput = {
    course_level_id?: StringFieldUpdateOperationsInput | string
    subject_code?: StringFieldUpdateOperationsInput | string
  }

  export type CourseLevelsPerSubjectCreateManyInput = {
    course_level_id: string
    subject_code: string
  }

  export type CourseLevelsPerSubjectUpdateManyMutationInput = {

  }

  export type CourseLevelsPerSubjectUncheckedUpdateManyInput = {
    course_level_id?: StringFieldUpdateOperationsInput | string
    subject_code?: StringFieldUpdateOperationsInput | string
  }

  export type LessonCreateInput = {
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    section: SectionCreateNestedOneWithoutLessonInput
    tasks?: TaskCreateNestedManyWithoutLessonInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutLessonInput
    CourseTask?: CourseTaskCreateNestedManyWithoutLessonInput
    Module?: ModuleCreateNestedOneWithoutLessonsInput
    LessonCard?: LessonCardCreateNestedManyWithoutLessonInput
    UserCard?: UserCardCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateInput = {
    lesson_id?: number
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    section_id: number
    moduleModule_id?: number | null
    tasks?: TaskUncheckedCreateNestedManyWithoutLessonInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutLessonInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutLessonInput
    LessonCard?: LessonCardUncheckedCreateNestedManyWithoutLessonInput
    UserCard?: UserCardUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonUpdateInput = {
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    section?: SectionUpdateOneRequiredWithoutLessonNestedInput
    tasks?: TaskUpdateManyWithoutLessonNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutLessonNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutLessonNestedInput
    Module?: ModuleUpdateOneWithoutLessonsNestedInput
    LessonCard?: LessonCardUpdateManyWithoutLessonNestedInput
    UserCard?: UserCardUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    lesson_id?: IntFieldUpdateOperationsInput | number
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    section_id?: IntFieldUpdateOperationsInput | number
    moduleModule_id?: NullableIntFieldUpdateOperationsInput | number | null
    tasks?: TaskUncheckedUpdateManyWithoutLessonNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutLessonNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutLessonNestedInput
    LessonCard?: LessonCardUncheckedUpdateManyWithoutLessonNestedInput
    UserCard?: UserCardUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonCreateManyInput = {
    lesson_id?: number
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    section_id: number
    moduleModule_id?: number | null
  }

  export type LessonUpdateManyMutationInput = {
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LessonUncheckedUpdateManyInput = {
    lesson_id?: IntFieldUpdateOperationsInput | number
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    section_id?: IntFieldUpdateOperationsInput | number
    moduleModule_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MentorCreateInput = {
    mentor_id: string
    mentor_description_en?: string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    user: UserCreateNestedOneWithoutMentorInput
    mentor_classes?: MentorsClassesCreateNestedManyWithoutMentorInput
    MentorPayModel?: MentorPayModelCreateNestedManyWithoutMentorInput
  }

  export type MentorUncheckedCreateInput = {
    mentor_id: string
    user_id: string
    mentor_description_en?: string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    mentor_classes?: MentorsClassesUncheckedCreateNestedManyWithoutMentorInput
    MentorPayModel?: MentorPayModelUncheckedCreateNestedManyWithoutMentorInput
  }

  export type MentorUpdateInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    mentor_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutMentorNestedInput
    mentor_classes?: MentorsClassesUpdateManyWithoutMentorNestedInput
    MentorPayModel?: MentorPayModelUpdateManyWithoutMentorNestedInput
  }

  export type MentorUncheckedUpdateInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    mentor_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    mentor_classes?: MentorsClassesUncheckedUpdateManyWithoutMentorNestedInput
    MentorPayModel?: MentorPayModelUncheckedUpdateManyWithoutMentorNestedInput
  }

  export type MentorCreateManyInput = {
    mentor_id: string
    user_id: string
    mentor_description_en?: string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
  }

  export type MentorUpdateManyMutationInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    mentor_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorUncheckedUpdateManyInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    mentor_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorsClassesCreateInput = {
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    mentor: MentorCreateNestedOneWithoutMentor_classesInput
    class: ClassCreateNestedOneWithoutMentor_classesInput
  }

  export type MentorsClassesUncheckedCreateInput = {
    mentor_id: string
    class_id: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
  }

  export type MentorsClassesUpdateInput = {
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    mentor?: MentorUpdateOneRequiredWithoutMentor_classesNestedInput
    class?: ClassUpdateOneRequiredWithoutMentor_classesNestedInput
  }

  export type MentorsClassesUncheckedUpdateInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorsClassesCreateManyInput = {
    mentor_id: string
    class_id: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
  }

  export type MentorsClassesUpdateManyMutationInput = {
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorsClassesUncheckedUpdateManyInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorPayModelCreateInput = {
    start_date: Date | string
    pay_rate_per_hour: number
    created_date?: Date | string | null
    end_date?: Date | string | null
    deleted?: boolean
    mentor: MentorCreateNestedOneWithoutMentorPayModelInput
    class_size: ClassSizeCreateNestedOneWithoutMentorPayModelInput
  }

  export type MentorPayModelUncheckedCreateInput = {
    mentor_id: string
    class_size_id: string
    start_date: Date | string
    pay_rate_per_hour: number
    created_date?: Date | string | null
    end_date?: Date | string | null
    deleted?: boolean
  }

  export type MentorPayModelUpdateInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pay_rate_per_hour?: FloatFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    mentor?: MentorUpdateOneRequiredWithoutMentorPayModelNestedInput
    class_size?: ClassSizeUpdateOneRequiredWithoutMentorPayModelNestedInput
  }

  export type MentorPayModelUncheckedUpdateInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    class_size_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pay_rate_per_hour?: FloatFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorPayModelCreateManyInput = {
    mentor_id: string
    class_size_id: string
    start_date: Date | string
    pay_rate_per_hour: number
    created_date?: Date | string | null
    end_date?: Date | string | null
    deleted?: boolean
  }

  export type MentorPayModelUpdateManyMutationInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pay_rate_per_hour?: FloatFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorPayModelUncheckedUpdateManyInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    class_size_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pay_rate_per_hour?: FloatFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuleCreateInput = {
    module_name: string
    module_description?: string | null
    module_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    course: CourseCreateNestedOneWithoutModuleInput
    sections?: SectionCreateNestedManyWithoutModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutModuleInput
    CourseTask?: CourseTaskCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateInput = {
    module_id?: number
    module_name: string
    module_description?: string | null
    module_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    course_id: string
    sections?: SectionUncheckedCreateNestedManyWithoutModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutModuleInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleUpdateInput = {
    module_name?: StringFieldUpdateOperationsInput | string
    module_description?: NullableStringFieldUpdateOperationsInput | string | null
    module_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneRequiredWithoutModuleNestedInput
    sections?: SectionUpdateManyWithoutModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutModuleNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateInput = {
    module_id?: IntFieldUpdateOperationsInput | number
    module_name?: StringFieldUpdateOperationsInput | string
    module_description?: NullableStringFieldUpdateOperationsInput | string | null
    module_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    course_id?: StringFieldUpdateOperationsInput | string
    sections?: SectionUncheckedUpdateManyWithoutModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutModuleNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleCreateManyInput = {
    module_id?: number
    module_name: string
    module_description?: string | null
    module_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    course_id: string
  }

  export type ModuleUpdateManyMutationInput = {
    module_name?: StringFieldUpdateOperationsInput | string
    module_description?: NullableStringFieldUpdateOperationsInput | string | null
    module_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuleUncheckedUpdateManyInput = {
    module_id?: IntFieldUpdateOperationsInput | number
    module_name?: StringFieldUpdateOperationsInput | string
    module_description?: NullableStringFieldUpdateOperationsInput | string | null
    module_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    course_id?: StringFieldUpdateOperationsInput | string
  }

  export type SectionCreateInput = {
    section_name: string
    section_description?: string | null
    section_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    module: ModuleCreateNestedOneWithoutSectionsInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutSectionInput
    CourseTask?: CourseTaskCreateNestedManyWithoutSectionInput
    Lesson?: LessonCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateInput = {
    section_id?: number
    section_name: string
    section_description?: string | null
    section_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    module_id: number
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutSectionInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutSectionInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionUpdateInput = {
    section_name?: StringFieldUpdateOperationsInput | string
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    section_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    module?: ModuleUpdateOneRequiredWithoutSectionsNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutSectionNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutSectionNestedInput
    Lesson?: LessonUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateInput = {
    section_id?: IntFieldUpdateOperationsInput | number
    section_name?: StringFieldUpdateOperationsInput | string
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    section_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    module_id?: IntFieldUpdateOperationsInput | number
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutSectionNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutSectionNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionCreateManyInput = {
    section_id?: number
    section_name: string
    section_description?: string | null
    section_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    module_id: number
  }

  export type SectionUpdateManyMutationInput = {
    section_name?: StringFieldUpdateOperationsInput | string
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    section_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SectionUncheckedUpdateManyInput = {
    section_id?: IntFieldUpdateOperationsInput | number
    section_name?: StringFieldUpdateOperationsInput | string
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    section_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    module_id?: IntFieldUpdateOperationsInput | number
  }

  export type TimeOfDayCreateInput = {
    time_of_day_id?: string
    time_of_day_name: string
    classes?: ClassCreateNestedManyWithoutTime_of_dayInput
  }

  export type TimeOfDayUncheckedCreateInput = {
    time_of_day_id?: string
    time_of_day_name: string
    classes?: ClassUncheckedCreateNestedManyWithoutTime_of_dayInput
  }

  export type TimeOfDayUpdateInput = {
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    time_of_day_name?: StringFieldUpdateOperationsInput | string
    classes?: ClassUpdateManyWithoutTime_of_dayNestedInput
  }

  export type TimeOfDayUncheckedUpdateInput = {
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    time_of_day_name?: StringFieldUpdateOperationsInput | string
    classes?: ClassUncheckedUpdateManyWithoutTime_of_dayNestedInput
  }

  export type TimeOfDayCreateManyInput = {
    time_of_day_id?: string
    time_of_day_name: string
  }

  export type TimeOfDayUpdateManyMutationInput = {
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    time_of_day_name?: StringFieldUpdateOperationsInput | string
  }

  export type TimeOfDayUncheckedUpdateManyInput = {
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    time_of_day_name?: StringFieldUpdateOperationsInput | string
  }

  export type TuitionLangCreateInput = {
    tuition_lang_code?: string
    tuition_lang_name: string
    classes?: ClassCreateNestedManyWithoutTuition_langInput
  }

  export type TuitionLangUncheckedCreateInput = {
    tuition_lang_code?: string
    tuition_lang_name: string
    classes?: ClassUncheckedCreateNestedManyWithoutTuition_langInput
  }

  export type TuitionLangUpdateInput = {
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    tuition_lang_name?: StringFieldUpdateOperationsInput | string
    classes?: ClassUpdateManyWithoutTuition_langNestedInput
  }

  export type TuitionLangUncheckedUpdateInput = {
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    tuition_lang_name?: StringFieldUpdateOperationsInput | string
    classes?: ClassUncheckedUpdateManyWithoutTuition_langNestedInput
  }

  export type TuitionLangCreateManyInput = {
    tuition_lang_code?: string
    tuition_lang_name: string
  }

  export type TuitionLangUpdateManyMutationInput = {
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    tuition_lang_name?: StringFieldUpdateOperationsInput | string
  }

  export type TuitionLangUncheckedUpdateManyInput = {
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    tuition_lang_name?: StringFieldUpdateOperationsInput | string
  }

  export type DeckCreateInput = {
    deck_id: string
    deck_description?: string | null
    user: UserCreateNestedOneWithoutDeckInput
    Card?: LessonCardCreateNestedManyWithoutDeckInput
  }

  export type DeckUncheckedCreateInput = {
    deck_id: string
    user_id: string
    deck_description?: string | null
    Card?: LessonCardUncheckedCreateNestedManyWithoutDeckInput
  }

  export type DeckUpdateInput = {
    deck_id?: StringFieldUpdateOperationsInput | string
    deck_description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutDeckNestedInput
    Card?: LessonCardUpdateManyWithoutDeckNestedInput
  }

  export type DeckUncheckedUpdateInput = {
    deck_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    deck_description?: NullableStringFieldUpdateOperationsInput | string | null
    Card?: LessonCardUncheckedUpdateManyWithoutDeckNestedInput
  }

  export type DeckCreateManyInput = {
    deck_id: string
    user_id: string
    deck_description?: string | null
  }

  export type DeckUpdateManyMutationInput = {
    deck_id?: StringFieldUpdateOperationsInput | string
    deck_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeckUncheckedUpdateManyInput = {
    deck_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    deck_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LessonCardCreateInput = {
    card_id: string
    question: string
    answer: string
    example?: string | null
    deck: DeckCreateNestedOneWithoutCardInput
    course: CourseCreateNestedOneWithoutLessonCardInput
    lesson: LessonCreateNestedOneWithoutLessonCardInput
  }

  export type LessonCardUncheckedCreateInput = {
    card_id: string
    deck_id: string
    question: string
    answer: string
    example?: string | null
    course_code: string
    lesson_id: number
  }

  export type LessonCardUpdateInput = {
    card_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    deck?: DeckUpdateOneRequiredWithoutCardNestedInput
    course?: CourseUpdateOneRequiredWithoutLessonCardNestedInput
    lesson?: LessonUpdateOneRequiredWithoutLessonCardNestedInput
  }

  export type LessonCardUncheckedUpdateInput = {
    card_id?: StringFieldUpdateOperationsInput | string
    deck_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    course_code?: StringFieldUpdateOperationsInput | string
    lesson_id?: IntFieldUpdateOperationsInput | number
  }

  export type LessonCardCreateManyInput = {
    card_id: string
    deck_id: string
    question: string
    answer: string
    example?: string | null
    course_code: string
    lesson_id: number
  }

  export type LessonCardUpdateManyMutationInput = {
    card_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LessonCardUncheckedUpdateManyInput = {
    card_id?: StringFieldUpdateOperationsInput | string
    deck_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    course_code?: StringFieldUpdateOperationsInput | string
    lesson_id?: IntFieldUpdateOperationsInput | number
  }

  export type UserCardCreateInput = {
    user_card_id: string
    question: string
    answer: string
    example?: string | null
    user: UserCreateNestedOneWithoutUserCardInput
    lesson?: LessonCreateNestedOneWithoutUserCardInput
  }

  export type UserCardUncheckedCreateInput = {
    user_card_id: string
    user_id: string
    question: string
    answer: string
    example?: string | null
    lesson_id?: number | null
  }

  export type UserCardUpdateInput = {
    user_card_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserCardNestedInput
    lesson?: LessonUpdateOneWithoutUserCardNestedInput
  }

  export type UserCardUncheckedUpdateInput = {
    user_card_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCardCreateManyInput = {
    user_card_id: string
    user_id: string
    question: string
    answer: string
    example?: string | null
    lesson_id?: number | null
  }

  export type UserCardUpdateManyMutationInput = {
    user_card_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCardUncheckedUpdateManyInput = {
    user_card_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VocabularyCreateInput = {
    vocabulary_id: string
    user_id: string
  }

  export type VocabularyUncheckedCreateInput = {
    vocabulary_id: string
    user_id: string
  }

  export type VocabularyUpdateInput = {
    vocabulary_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type VocabularyUncheckedUpdateInput = {
    vocabulary_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type VocabularyCreateManyInput = {
    vocabulary_id: string
    user_id: string
  }

  export type VocabularyUpdateManyMutationInput = {
    vocabulary_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type VocabularyUncheckedUpdateManyInput = {
    vocabulary_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type VocabularyInboxCreateInput = {
    question: string
    answer: string
    user: UserCreateNestedOneWithoutVocabularyInboxInput
  }

  export type VocabularyInboxUncheckedCreateInput = {
    user_id: string
    question: string
    answer: string
  }

  export type VocabularyInboxUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutVocabularyInboxNestedInput
  }

  export type VocabularyInboxUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type VocabularyInboxCreateManyInput = {
    user_id: string
    question: string
    answer: string
  }

  export type VocabularyInboxUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type VocabularyInboxUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type BookingRequestCreateInput = {
    booking_request_id: string
    booking_date: Date | string
    booking_request_status?: $Enums.BookingRequestStatus
    user_stated_name?: string | null
    user_stated_phone?: string | null
    user_stated_email?: string | null
    user_stated_telegram_nickname?: string | null
    class: ClassCreateNestedOneWithoutBooking_requestsInput
  }

  export type BookingRequestUncheckedCreateInput = {
    booking_request_id: string
    class_id: string
    booking_date: Date | string
    booking_request_status?: $Enums.BookingRequestStatus
    user_stated_name?: string | null
    user_stated_phone?: string | null
    user_stated_email?: string | null
    user_stated_telegram_nickname?: string | null
  }

  export type BookingRequestUpdateInput = {
    booking_request_id?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_request_status?: EnumBookingRequestStatusFieldUpdateOperationsInput | $Enums.BookingRequestStatus
    user_stated_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_phone?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_telegram_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    class?: ClassUpdateOneRequiredWithoutBooking_requestsNestedInput
  }

  export type BookingRequestUncheckedUpdateInput = {
    booking_request_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_request_status?: EnumBookingRequestStatusFieldUpdateOperationsInput | $Enums.BookingRequestStatus
    user_stated_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_phone?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_telegram_nickname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingRequestCreateManyInput = {
    booking_request_id: string
    class_id: string
    booking_date: Date | string
    booking_request_status?: $Enums.BookingRequestStatus
    user_stated_name?: string | null
    user_stated_phone?: string | null
    user_stated_email?: string | null
    user_stated_telegram_nickname?: string | null
  }

  export type BookingRequestUpdateManyMutationInput = {
    booking_request_id?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_request_status?: EnumBookingRequestStatusFieldUpdateOperationsInput | $Enums.BookingRequestStatus
    user_stated_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_phone?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_telegram_nickname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingRequestUncheckedUpdateManyInput = {
    booking_request_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_request_status?: EnumBookingRequestStatusFieldUpdateOperationsInput | $Enums.BookingRequestStatus
    user_stated_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_phone?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_telegram_nickname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassTaskCreateInput = {
    course_task: CourseTaskCreateNestedOneWithoutClassTaskInput
    class: ClassCreateNestedOneWithoutClassTaskInput
    student_tasks?: StudentTaskCreateNestedManyWithoutClass_taskInput
    student_answer?: StudentAnswerCreateNestedManyWithoutClass_taskInput
  }

  export type ClassTaskUncheckedCreateInput = {
    class_task_id?: number
    course_task_id: string
    class_id: string
    student_tasks?: StudentTaskUncheckedCreateNestedManyWithoutClass_taskInput
    student_answer?: StudentAnswerUncheckedCreateNestedManyWithoutClass_taskInput
  }

  export type ClassTaskUpdateInput = {
    course_task?: CourseTaskUpdateOneRequiredWithoutClassTaskNestedInput
    class?: ClassUpdateOneRequiredWithoutClassTaskNestedInput
    student_tasks?: StudentTaskUpdateManyWithoutClass_taskNestedInput
    student_answer?: StudentAnswerUpdateManyWithoutClass_taskNestedInput
  }

  export type ClassTaskUncheckedUpdateInput = {
    class_task_id?: IntFieldUpdateOperationsInput | number
    course_task_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    student_tasks?: StudentTaskUncheckedUpdateManyWithoutClass_taskNestedInput
    student_answer?: StudentAnswerUncheckedUpdateManyWithoutClass_taskNestedInput
  }

  export type ClassTaskCreateManyInput = {
    class_task_id?: number
    course_task_id: string
    class_id: string
  }

  export type ClassTaskUpdateManyMutationInput = {

  }

  export type ClassTaskUncheckedUpdateManyInput = {
    class_task_id?: IntFieldUpdateOperationsInput | number
    course_task_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
  }

  export type StudentCreateInput = {
    student_id: string
    student_nickname?: string | null
    enrolled_date?: Date | string | null
    left_date?: Date | string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    user: UserCreateNestedOneWithoutIs_student_ofInput
    class: ClassCreateNestedOneWithoutStudentsInput
    student_task?: StudentTaskCreateNestedManyWithoutStudentInput
    student_answers?: StudentAnswerCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    student_id: string
    user_id: string
    student_nickname?: string | null
    enrolled_date?: Date | string | null
    left_date?: Date | string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class_id: string
    student_task?: StudentTaskUncheckedCreateNestedManyWithoutStudentInput
    student_answers?: StudentAnswerUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    student_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutIs_student_ofNestedInput
    class?: ClassUpdateOneRequiredWithoutStudentsNestedInput
    student_task?: StudentTaskUpdateManyWithoutStudentNestedInput
    student_answers?: StudentAnswerUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    student_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class_id?: StringFieldUpdateOperationsInput | string
    student_task?: StudentTaskUncheckedUpdateManyWithoutStudentNestedInput
    student_answers?: StudentAnswerUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    student_id: string
    user_id: string
    student_nickname?: string | null
    enrolled_date?: Date | string | null
    left_date?: Date | string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class_id: string
  }

  export type StudentUpdateManyMutationInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    student_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentUncheckedUpdateManyInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    student_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class_id?: StringFieldUpdateOperationsInput | string
  }

  export type StudentAnswerCreateInput = {
    answer: string
    student: StudentCreateNestedOneWithoutStudent_answersInput
    class_task: ClassTaskCreateNestedOneWithoutStudent_answerInput
  }

  export type StudentAnswerUncheckedCreateInput = {
    student_answer_id?: number
    student_id: string
    class_task_id: number
    answer: string
  }

  export type StudentAnswerUpdateInput = {
    answer?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutStudent_answersNestedInput
    class_task?: ClassTaskUpdateOneRequiredWithoutStudent_answerNestedInput
  }

  export type StudentAnswerUncheckedUpdateInput = {
    student_answer_id?: IntFieldUpdateOperationsInput | number
    student_id?: StringFieldUpdateOperationsInput | string
    class_task_id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type StudentAnswerCreateManyInput = {
    student_answer_id?: number
    student_id: string
    class_task_id: number
    answer: string
  }

  export type StudentAnswerUpdateManyMutationInput = {
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type StudentAnswerUncheckedUpdateManyInput = {
    student_answer_id?: IntFieldUpdateOperationsInput | number
    student_id?: StringFieldUpdateOperationsInput | string
    class_task_id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTaskCreateInput = {
    task_status: $Enums.StudentTaskStatus
    student: StudentCreateNestedOneWithoutStudent_taskInput
    class_task: ClassTaskCreateNestedOneWithoutStudent_tasksInput
  }

  export type StudentTaskUncheckedCreateInput = {
    student_task_id?: number
    student_id: string
    class_task_id: number
    task_status: $Enums.StudentTaskStatus
  }

  export type StudentTaskUpdateInput = {
    task_status?: EnumStudentTaskStatusFieldUpdateOperationsInput | $Enums.StudentTaskStatus
    student?: StudentUpdateOneRequiredWithoutStudent_taskNestedInput
    class_task?: ClassTaskUpdateOneRequiredWithoutStudent_tasksNestedInput
  }

  export type StudentTaskUncheckedUpdateInput = {
    student_task_id?: IntFieldUpdateOperationsInput | number
    student_id?: StringFieldUpdateOperationsInput | string
    class_task_id?: IntFieldUpdateOperationsInput | number
    task_status?: EnumStudentTaskStatusFieldUpdateOperationsInput | $Enums.StudentTaskStatus
  }

  export type StudentTaskCreateManyInput = {
    student_task_id?: number
    student_id: string
    class_task_id: number
    task_status: $Enums.StudentTaskStatus
  }

  export type StudentTaskUpdateManyMutationInput = {
    task_status?: EnumStudentTaskStatusFieldUpdateOperationsInput | $Enums.StudentTaskStatus
  }

  export type StudentTaskUncheckedUpdateManyInput = {
    student_task_id?: IntFieldUpdateOperationsInput | number
    student_id?: StringFieldUpdateOperationsInput | string
    class_task_id?: IntFieldUpdateOperationsInput | number
    task_status?: EnumStudentTaskStatusFieldUpdateOperationsInput | $Enums.StudentTaskStatus
  }

  export type TaskCreateInput = {
    task_description?: string | null
    task_text?: string | null
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    gap_map?: string | null
    task_type: TaskTypeCreateNestedOneWithoutTaskInput
    task_context: TaskContextCreateNestedOneWithoutTaskInput
    lesson: LessonCreateNestedOneWithoutTasksInput
    task_forms?: TaskFormCreateNestedManyWithoutTaskInput
    task_options?: TaskOptionCreateNestedManyWithoutTaskInput
    CourseTask?: CourseTaskCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    task_id?: number
    task_description?: string | null
    task_text?: string | null
    task_type_id: number
    task_context_id: string
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    lesson_id: number
    gap_map?: string | null
    task_forms?: TaskFormUncheckedCreateNestedManyWithoutTaskInput
    task_options?: TaskOptionUncheckedCreateNestedManyWithoutTaskInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
    task_type?: TaskTypeUpdateOneRequiredWithoutTaskNestedInput
    task_context?: TaskContextUpdateOneRequiredWithoutTaskNestedInput
    lesson?: LessonUpdateOneRequiredWithoutTasksNestedInput
    task_forms?: TaskFormUpdateManyWithoutTaskNestedInput
    task_options?: TaskOptionUpdateManyWithoutTaskNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_type_id?: IntFieldUpdateOperationsInput | number
    task_context_id?: StringFieldUpdateOperationsInput | string
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    lesson_id?: IntFieldUpdateOperationsInput | number
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
    task_forms?: TaskFormUncheckedUpdateManyWithoutTaskNestedInput
    task_options?: TaskOptionUncheckedUpdateManyWithoutTaskNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    task_id?: number
    task_description?: string | null
    task_text?: string | null
    task_type_id: number
    task_context_id: string
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    lesson_id: number
    gap_map?: string | null
  }

  export type TaskUpdateManyMutationInput = {
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskUncheckedUpdateManyInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_type_id?: IntFieldUpdateOperationsInput | number
    task_context_id?: StringFieldUpdateOperationsInput | string
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    lesson_id?: IntFieldUpdateOperationsInput | number
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskFormCreateInput = {
    task_form_name: string
    task_form_description?: string | null
    task?: TaskCreateNestedManyWithoutTask_formsInput
  }

  export type TaskFormUncheckedCreateInput = {
    task_form_id?: number
    task_form_name: string
    task_form_description?: string | null
    task?: TaskUncheckedCreateNestedManyWithoutTask_formsInput
  }

  export type TaskFormUpdateInput = {
    task_form_name?: StringFieldUpdateOperationsInput | string
    task_form_description?: NullableStringFieldUpdateOperationsInput | string | null
    task?: TaskUpdateManyWithoutTask_formsNestedInput
  }

  export type TaskFormUncheckedUpdateInput = {
    task_form_id?: IntFieldUpdateOperationsInput | number
    task_form_name?: StringFieldUpdateOperationsInput | string
    task_form_description?: NullableStringFieldUpdateOperationsInput | string | null
    task?: TaskUncheckedUpdateManyWithoutTask_formsNestedInput
  }

  export type TaskFormCreateManyInput = {
    task_form_id?: number
    task_form_name: string
    task_form_description?: string | null
  }

  export type TaskFormUpdateManyMutationInput = {
    task_form_name?: StringFieldUpdateOperationsInput | string
    task_form_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskFormUncheckedUpdateManyInput = {
    task_form_id?: IntFieldUpdateOperationsInput | number
    task_form_name?: StringFieldUpdateOperationsInput | string
    task_form_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskContextCreateInput = {
    task_context_id: string
    task_context_name: string
    task_context_description?: string | null
    task?: TaskCreateNestedManyWithoutTask_contextInput
  }

  export type TaskContextUncheckedCreateInput = {
    task_context_id: string
    task_context_name: string
    task_context_description?: string | null
    task?: TaskUncheckedCreateNestedManyWithoutTask_contextInput
  }

  export type TaskContextUpdateInput = {
    task_context_id?: StringFieldUpdateOperationsInput | string
    task_context_name?: StringFieldUpdateOperationsInput | string
    task_context_description?: NullableStringFieldUpdateOperationsInput | string | null
    task?: TaskUpdateManyWithoutTask_contextNestedInput
  }

  export type TaskContextUncheckedUpdateInput = {
    task_context_id?: StringFieldUpdateOperationsInput | string
    task_context_name?: StringFieldUpdateOperationsInput | string
    task_context_description?: NullableStringFieldUpdateOperationsInput | string | null
    task?: TaskUncheckedUpdateManyWithoutTask_contextNestedInput
  }

  export type TaskContextCreateManyInput = {
    task_context_id: string
    task_context_name: string
    task_context_description?: string | null
  }

  export type TaskContextUpdateManyMutationInput = {
    task_context_id?: StringFieldUpdateOperationsInput | string
    task_context_name?: StringFieldUpdateOperationsInput | string
    task_context_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskContextUncheckedUpdateManyInput = {
    task_context_id?: StringFieldUpdateOperationsInput | string
    task_context_name?: StringFieldUpdateOperationsInput | string
    task_context_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskOptionCreateInput = {
    task_option_text: string
    task_option_order?: number | null
    is_correct: boolean
    task: TaskCreateNestedOneWithoutTask_optionsInput
  }

  export type TaskOptionUncheckedCreateInput = {
    task_option_id?: number
    task_id: number
    task_option_text: string
    task_option_order?: number | null
    is_correct: boolean
  }

  export type TaskOptionUpdateInput = {
    task_option_text?: StringFieldUpdateOperationsInput | string
    task_option_order?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    task?: TaskUpdateOneRequiredWithoutTask_optionsNestedInput
  }

  export type TaskOptionUncheckedUpdateInput = {
    task_option_id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    task_option_text?: StringFieldUpdateOperationsInput | string
    task_option_order?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskOptionCreateManyInput = {
    task_option_id?: number
    task_id: number
    task_option_text: string
    task_option_order?: number | null
    is_correct: boolean
  }

  export type TaskOptionUpdateManyMutationInput = {
    task_option_text?: StringFieldUpdateOperationsInput | string
    task_option_order?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskOptionUncheckedUpdateManyInput = {
    task_option_id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    task_option_text?: StringFieldUpdateOperationsInput | string
    task_option_order?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskTypeCreateInput = {
    task_type_name: string
    task_type_description?: string | null
    task?: TaskCreateNestedManyWithoutTask_typeInput
  }

  export type TaskTypeUncheckedCreateInput = {
    task_type_id?: number
    task_type_name: string
    task_type_description?: string | null
    task?: TaskUncheckedCreateNestedManyWithoutTask_typeInput
  }

  export type TaskTypeUpdateInput = {
    task_type_name?: StringFieldUpdateOperationsInput | string
    task_type_description?: NullableStringFieldUpdateOperationsInput | string | null
    task?: TaskUpdateManyWithoutTask_typeNestedInput
  }

  export type TaskTypeUncheckedUpdateInput = {
    task_type_id?: IntFieldUpdateOperationsInput | number
    task_type_name?: StringFieldUpdateOperationsInput | string
    task_type_description?: NullableStringFieldUpdateOperationsInput | string | null
    task?: TaskUncheckedUpdateManyWithoutTask_typeNestedInput
  }

  export type TaskTypeCreateManyInput = {
    task_type_id?: number
    task_type_name: string
    task_type_description?: string | null
  }

  export type TaskTypeUpdateManyMutationInput = {
    task_type_name?: StringFieldUpdateOperationsInput | string
    task_type_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskTypeUncheckedUpdateManyInput = {
    task_type_id?: IntFieldUpdateOperationsInput | number
    task_type_name?: StringFieldUpdateOperationsInput | string
    task_type_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type UserApplicationPreferencesListRelationFilter = {
    every?: UserApplicationPreferencesWhereInput
    some?: UserApplicationPreferencesWhereInput
    none?: UserApplicationPreferencesWhereInput
  }

  export type MentorListRelationFilter = {
    every?: MentorWhereInput
    some?: MentorWhereInput
    none?: MentorWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type DataRemovalRequestListRelationFilter = {
    every?: DataRemovalRequestWhereInput
    some?: DataRemovalRequestWhereInput
    none?: DataRemovalRequestWhereInput
  }

  export type DeckListRelationFilter = {
    every?: DeckWhereInput
    some?: DeckWhereInput
    none?: DeckWhereInput
  }

  export type UserCardListRelationFilter = {
    every?: UserCardWhereInput
    some?: UserCardWhereInput
    none?: UserCardWhereInput
  }

  export type VocabularyInboxListRelationFilter = {
    every?: VocabularyInboxWhereInput
    some?: VocabularyInboxWhereInput
    none?: VocabularyInboxWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserApplicationPreferencesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MentorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DataRemovalRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VocabularyInboxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    user_email?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    nickname?: SortOrder
    deleted?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    user_email?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    nickname?: SortOrder
    deleted?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    user_email?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    nickname?: SortOrder
    deleted?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type RoleCountOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    role_description?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    role_description?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    role_description?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleUser_emailRole_idCompoundUniqueInput = {
    user_email: string
    role_id: string
  }

  export type UserRoleCountOrderByAggregateInput = {
    user_email?: SortOrder
    role_id?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    user_email?: SortOrder
    role_id?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    user_email?: SortOrder
    role_id?: SortOrder
  }

  export type ApplicationRelationFilter = {
    is?: ApplicationWhereInput
    isNot?: ApplicationWhereInput
  }

  export type UserApplicationPreferencesUser_emailApplication_idCompoundUniqueInput = {
    user_email: string
    application_id: string
  }

  export type UserApplicationPreferencesCountOrderByAggregateInput = {
    user_email?: SortOrder
    application_id?: SortOrder
    accepted_privacy_policy?: SortOrder
    accepted_cookies_policy?: SortOrder
  }

  export type UserApplicationPreferencesMaxOrderByAggregateInput = {
    user_email?: SortOrder
    application_id?: SortOrder
    accepted_privacy_policy?: SortOrder
    accepted_cookies_policy?: SortOrder
  }

  export type UserApplicationPreferencesMinOrderByAggregateInput = {
    user_email?: SortOrder
    application_id?: SortOrder
    accepted_privacy_policy?: SortOrder
    accepted_cookies_policy?: SortOrder
  }

  export type ApplicationCountOrderByAggregateInput = {
    application_id?: SortOrder
    application_name?: SortOrder
    application_description?: SortOrder
    application_url?: SortOrder
  }

  export type ApplicationMaxOrderByAggregateInput = {
    application_id?: SortOrder
    application_name?: SortOrder
    application_description?: SortOrder
    application_url?: SortOrder
  }

  export type ApplicationMinOrderByAggregateInput = {
    application_id?: SortOrder
    application_name?: SortOrder
    application_description?: SortOrder
    application_url?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumDataRemovalStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRemovalStatusEnum | EnumDataRemovalStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DataRemovalStatusEnum[] | ListEnumDataRemovalStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataRemovalStatusEnum[] | ListEnumDataRemovalStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDataRemovalStatusEnumFilter<$PrismaModel> | $Enums.DataRemovalStatusEnum
  }

  export type DataRemovalRequestCountOrderByAggregateInput = {
    data_removal_request_id?: SortOrder
    user_email?: SortOrder
    data_removal_request?: SortOrder
    data_removal_status?: SortOrder
    data_removal_date?: SortOrder
  }

  export type DataRemovalRequestAvgOrderByAggregateInput = {
    data_removal_request_id?: SortOrder
  }

  export type DataRemovalRequestMaxOrderByAggregateInput = {
    data_removal_request_id?: SortOrder
    user_email?: SortOrder
    data_removal_request?: SortOrder
    data_removal_status?: SortOrder
    data_removal_date?: SortOrder
  }

  export type DataRemovalRequestMinOrderByAggregateInput = {
    data_removal_request_id?: SortOrder
    user_email?: SortOrder
    data_removal_request?: SortOrder
    data_removal_status?: SortOrder
    data_removal_date?: SortOrder
  }

  export type DataRemovalRequestSumOrderByAggregateInput = {
    data_removal_request_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumDataRemovalStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRemovalStatusEnum | EnumDataRemovalStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DataRemovalStatusEnum[] | ListEnumDataRemovalStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataRemovalStatusEnum[] | ListEnumDataRemovalStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDataRemovalStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.DataRemovalStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataRemovalStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumDataRemovalStatusEnumFilter<$PrismaModel>
  }

  export type ClassCallListRelationFilter = {
    every?: ClassCallWhereInput
    some?: ClassCallWhereInput
    none?: ClassCallWhereInput
  }

  export type ClassCallOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeetingKindCountOrderByAggregateInput = {
    meeting_kind_id?: SortOrder
    meeting_kind_name?: SortOrder
  }

  export type MeetingKindMaxOrderByAggregateInput = {
    meeting_kind_id?: SortOrder
    meeting_kind_name?: SortOrder
  }

  export type MeetingKindMinOrderByAggregateInput = {
    meeting_kind_id?: SortOrder
    meeting_kind_name?: SortOrder
  }

  export type CourseRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type ModuleRelationFilter = {
    is?: ModuleWhereInput
    isNot?: ModuleWhereInput
  }

  export type SectionRelationFilter = {
    is?: SectionWhereInput
    isNot?: SectionWhereInput
  }

  export type LessonRelationFilter = {
    is?: LessonWhereInput
    isNot?: LessonWhereInput
  }

  export type CourseStructureCourse_idModule_idSection_idLesson_idCompoundUniqueInput = {
    course_id: string
    module_id: number
    section_id: number
    lesson_id: number
  }

  export type CourseStructureCountOrderByAggregateInput = {
    course_id?: SortOrder
    module_id?: SortOrder
    section_id?: SortOrder
    lesson_id?: SortOrder
  }

  export type CourseStructureAvgOrderByAggregateInput = {
    module_id?: SortOrder
    section_id?: SortOrder
    lesson_id?: SortOrder
  }

  export type CourseStructureMaxOrderByAggregateInput = {
    course_id?: SortOrder
    module_id?: SortOrder
    section_id?: SortOrder
    lesson_id?: SortOrder
  }

  export type CourseStructureMinOrderByAggregateInput = {
    course_id?: SortOrder
    module_id?: SortOrder
    section_id?: SortOrder
    lesson_id?: SortOrder
  }

  export type CourseStructureSumOrderByAggregateInput = {
    module_id?: SortOrder
    section_id?: SortOrder
    lesson_id?: SortOrder
  }

  export type ClassSizeRelationFilter = {
    is?: ClassSizeWhereInput
    isNot?: ClassSizeWhereInput
  }

  export type TimeOfDayRelationFilter = {
    is?: TimeOfDayWhereInput
    isNot?: TimeOfDayWhereInput
  }

  export type TuitionLangRelationFilter = {
    is?: TuitionLangWhereInput
    isNot?: TuitionLangWhereInput
  }

  export type MentorsClassesListRelationFilter = {
    every?: MentorsClassesWhereInput
    some?: MentorsClassesWhereInput
    none?: MentorsClassesWhereInput
  }

  export type BookingRequestListRelationFilter = {
    every?: BookingRequestWhereInput
    some?: BookingRequestWhereInput
    none?: BookingRequestWhereInput
  }

  export type ClassTaskListRelationFilter = {
    every?: ClassTaskWhereInput
    some?: ClassTaskWhereInput
    none?: ClassTaskWhereInput
  }

  export type MentorsClassesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassCountOrderByAggregateInput = {
    class_id?: SortOrder
    class_code?: SortOrder
    course_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    tuition_lang_code?: SortOrder
    time_of_day_id?: SortOrder
    start_time_gmt3?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    classSizeClass_size_id?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    class_id?: SortOrder
    class_code?: SortOrder
    course_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    tuition_lang_code?: SortOrder
    time_of_day_id?: SortOrder
    start_time_gmt3?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    classSizeClass_size_id?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    class_id?: SortOrder
    class_code?: SortOrder
    course_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    tuition_lang_code?: SortOrder
    time_of_day_id?: SortOrder
    start_time_gmt3?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    classSizeClass_size_id?: SortOrder
  }

  export type ClassRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type MeetingKindRelationFilter = {
    is?: MeetingKindWhereInput
    isNot?: MeetingKindWhereInput
  }

  export type ClassCallCountOrderByAggregateInput = {
    class_call_id?: SortOrder
    class_id?: SortOrder
    call_date?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    meeting_kind_id?: SortOrder
  }

  export type ClassCallMaxOrderByAggregateInput = {
    class_call_id?: SortOrder
    class_id?: SortOrder
    call_date?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    meeting_kind_id?: SortOrder
  }

  export type ClassCallMinOrderByAggregateInput = {
    class_call_id?: SortOrder
    class_id?: SortOrder
    call_date?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    meeting_kind_id?: SortOrder
  }

  export type EnumClassSizesEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ClassSizesEnum | EnumClassSizesEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ClassSizesEnum[] | ListEnumClassSizesEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClassSizesEnum[] | ListEnumClassSizesEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumClassSizesEnumFilter<$PrismaModel> | $Enums.ClassSizesEnum
  }

  export type ClassListRelationFilter = {
    every?: ClassWhereInput
    some?: ClassWhereInput
    none?: ClassWhereInput
  }

  export type MentorPayModelListRelationFilter = {
    every?: MentorPayModelWhereInput
    some?: MentorPayModelWhereInput
    none?: MentorPayModelWhereInput
  }

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MentorPayModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassSizeCountOrderByAggregateInput = {
    class_size_id?: SortOrder
    class_size_name?: SortOrder
  }

  export type ClassSizeMaxOrderByAggregateInput = {
    class_size_id?: SortOrder
    class_size_name?: SortOrder
  }

  export type ClassSizeMinOrderByAggregateInput = {
    class_size_id?: SortOrder
    class_size_name?: SortOrder
  }

  export type EnumClassSizesEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClassSizesEnum | EnumClassSizesEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ClassSizesEnum[] | ListEnumClassSizesEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClassSizesEnum[] | ListEnumClassSizesEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumClassSizesEnumWithAggregatesFilter<$PrismaModel> | $Enums.ClassSizesEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClassSizesEnumFilter<$PrismaModel>
    _max?: NestedEnumClassSizesEnumFilter<$PrismaModel>
  }

  export type CourseLevelRelationFilter = {
    is?: CourseLevelWhereInput
    isNot?: CourseLevelWhereInput
  }

  export type CourseAdviceListRelationFilter = {
    every?: CourseAdviceWhereInput
    some?: CourseAdviceWhereInput
    none?: CourseAdviceWhereInput
  }

  export type SubjectNullableRelationFilter = {
    is?: SubjectWhereInput | null
    isNot?: SubjectWhereInput | null
  }

  export type CourseStructureListRelationFilter = {
    every?: CourseStructureWhereInput
    some?: CourseStructureWhereInput
    none?: CourseStructureWhereInput
  }

  export type CourseTaskListRelationFilter = {
    every?: CourseTaskWhereInput
    some?: CourseTaskWhereInput
    none?: CourseTaskWhereInput
  }

  export type ModuleListRelationFilter = {
    every?: ModuleWhereInput
    some?: ModuleWhereInput
    none?: ModuleWhereInput
  }

  export type LessonCardListRelationFilter = {
    every?: LessonCardWhereInput
    some?: LessonCardWhereInput
    none?: LessonCardWhereInput
  }

  export type CourseAdviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseStructureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    course_code?: SortOrder
    course_name?: SortOrder
    course_level_id?: SortOrder
    created_date?: SortOrder
    subject_code?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    course_code?: SortOrder
    course_name?: SortOrder
    course_level_id?: SortOrder
    created_date?: SortOrder
    subject_code?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    course_code?: SortOrder
    course_name?: SortOrder
    course_level_id?: SortOrder
    created_date?: SortOrder
    subject_code?: SortOrder
  }

  export type CourseAdviceCountOrderByAggregateInput = {
    advice_id?: SortOrder
    course_code?: SortOrder
    advice_text?: SortOrder
    last_used_date?: SortOrder
    created_date?: SortOrder
  }

  export type CourseAdviceMaxOrderByAggregateInput = {
    advice_id?: SortOrder
    course_code?: SortOrder
    advice_text?: SortOrder
    last_used_date?: SortOrder
    created_date?: SortOrder
  }

  export type CourseAdviceMinOrderByAggregateInput = {
    advice_id?: SortOrder
    course_code?: SortOrder
    advice_text?: SortOrder
    last_used_date?: SortOrder
    created_date?: SortOrder
  }

  export type TaskRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type CourseTaskCountOrderByAggregateInput = {
    course_task_id?: SortOrder
    course_id?: SortOrder
    module_id?: SortOrder
    section_id?: SortOrder
    lesson_id?: SortOrder
    task_id?: SortOrder
    question?: SortOrder
  }

  export type CourseTaskAvgOrderByAggregateInput = {
    module_id?: SortOrder
    section_id?: SortOrder
    lesson_id?: SortOrder
    task_id?: SortOrder
  }

  export type CourseTaskMaxOrderByAggregateInput = {
    course_task_id?: SortOrder
    course_id?: SortOrder
    module_id?: SortOrder
    section_id?: SortOrder
    lesson_id?: SortOrder
    task_id?: SortOrder
    question?: SortOrder
  }

  export type CourseTaskMinOrderByAggregateInput = {
    course_task_id?: SortOrder
    course_id?: SortOrder
    module_id?: SortOrder
    section_id?: SortOrder
    lesson_id?: SortOrder
    task_id?: SortOrder
    question?: SortOrder
  }

  export type CourseTaskSumOrderByAggregateInput = {
    module_id?: SortOrder
    section_id?: SortOrder
    lesson_id?: SortOrder
    task_id?: SortOrder
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type CourseLevelsPerSubjectListRelationFilter = {
    every?: CourseLevelsPerSubjectWhereInput
    some?: CourseLevelsPerSubjectWhereInput
    none?: CourseLevelsPerSubjectWhereInput
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseLevelsPerSubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseLevelCountOrderByAggregateInput = {
    course_level_id?: SortOrder
    course_level_name?: SortOrder
  }

  export type CourseLevelMaxOrderByAggregateInput = {
    course_level_id?: SortOrder
    course_level_name?: SortOrder
  }

  export type CourseLevelMinOrderByAggregateInput = {
    course_level_id?: SortOrder
    course_level_name?: SortOrder
  }

  export type SubjectCountOrderByAggregateInput = {
    subject_code?: SortOrder
    subject_name?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    subject_code?: SortOrder
    subject_name?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    subject_code?: SortOrder
    subject_name?: SortOrder
  }

  export type SubjectRelationFilter = {
    is?: SubjectWhereInput
    isNot?: SubjectWhereInput
  }

  export type CourseLevelsPerSubjectCourse_level_idSubject_codeCompoundUniqueInput = {
    course_level_id: string
    subject_code: string
  }

  export type CourseLevelsPerSubjectCountOrderByAggregateInput = {
    course_level_id?: SortOrder
    subject_code?: SortOrder
  }

  export type CourseLevelsPerSubjectMaxOrderByAggregateInput = {
    course_level_id?: SortOrder
    subject_code?: SortOrder
  }

  export type CourseLevelsPerSubjectMinOrderByAggregateInput = {
    course_level_id?: SortOrder
    subject_code?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type ModuleNullableRelationFilter = {
    is?: ModuleWhereInput | null
    isNot?: ModuleWhereInput | null
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonCountOrderByAggregateInput = {
    lesson_id?: SortOrder
    lesson_name?: SortOrder
    lesson_description?: SortOrder
    lesson_order?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    section_id?: SortOrder
    moduleModule_id?: SortOrder
  }

  export type LessonAvgOrderByAggregateInput = {
    lesson_id?: SortOrder
    lesson_order?: SortOrder
    section_id?: SortOrder
    moduleModule_id?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    lesson_id?: SortOrder
    lesson_name?: SortOrder
    lesson_description?: SortOrder
    lesson_order?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    section_id?: SortOrder
    moduleModule_id?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    lesson_id?: SortOrder
    lesson_name?: SortOrder
    lesson_description?: SortOrder
    lesson_order?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    section_id?: SortOrder
    moduleModule_id?: SortOrder
  }

  export type LessonSumOrderByAggregateInput = {
    lesson_id?: SortOrder
    lesson_order?: SortOrder
    section_id?: SortOrder
    moduleModule_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type MentorCountOrderByAggregateInput = {
    mentor_id?: SortOrder
    user_id?: SortOrder
    mentor_description_en?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
  }

  export type MentorMaxOrderByAggregateInput = {
    mentor_id?: SortOrder
    user_id?: SortOrder
    mentor_description_en?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
  }

  export type MentorMinOrderByAggregateInput = {
    mentor_id?: SortOrder
    user_id?: SortOrder
    mentor_description_en?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
  }

  export type MentorRelationFilter = {
    is?: MentorWhereInput
    isNot?: MentorWhereInput
  }

  export type MentorsClassesMentor_idClass_idCompoundUniqueInput = {
    mentor_id: string
    class_id: string
  }

  export type MentorsClassesCountOrderByAggregateInput = {
    mentor_id?: SortOrder
    class_id?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
  }

  export type MentorsClassesMaxOrderByAggregateInput = {
    mentor_id?: SortOrder
    class_id?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
  }

  export type MentorsClassesMinOrderByAggregateInput = {
    mentor_id?: SortOrder
    class_id?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MentorPayModelMentor_idClass_size_idStart_dateCompoundUniqueInput = {
    mentor_id: string
    class_size_id: string
    start_date: Date | string
  }

  export type MentorPayModelCountOrderByAggregateInput = {
    mentor_id?: SortOrder
    class_size_id?: SortOrder
    start_date?: SortOrder
    pay_rate_per_hour?: SortOrder
    created_date?: SortOrder
    end_date?: SortOrder
    deleted?: SortOrder
  }

  export type MentorPayModelAvgOrderByAggregateInput = {
    pay_rate_per_hour?: SortOrder
  }

  export type MentorPayModelMaxOrderByAggregateInput = {
    mentor_id?: SortOrder
    class_size_id?: SortOrder
    start_date?: SortOrder
    pay_rate_per_hour?: SortOrder
    created_date?: SortOrder
    end_date?: SortOrder
    deleted?: SortOrder
  }

  export type MentorPayModelMinOrderByAggregateInput = {
    mentor_id?: SortOrder
    class_size_id?: SortOrder
    start_date?: SortOrder
    pay_rate_per_hour?: SortOrder
    created_date?: SortOrder
    end_date?: SortOrder
    deleted?: SortOrder
  }

  export type MentorPayModelSumOrderByAggregateInput = {
    pay_rate_per_hour?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SectionListRelationFilter = {
    every?: SectionWhereInput
    some?: SectionWhereInput
    none?: SectionWhereInput
  }

  export type LessonListRelationFilter = {
    every?: LessonWhereInput
    some?: LessonWhereInput
    none?: LessonWhereInput
  }

  export type SectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleCountOrderByAggregateInput = {
    module_id?: SortOrder
    module_name?: SortOrder
    module_description?: SortOrder
    module_order?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    course_id?: SortOrder
  }

  export type ModuleAvgOrderByAggregateInput = {
    module_id?: SortOrder
    module_order?: SortOrder
  }

  export type ModuleMaxOrderByAggregateInput = {
    module_id?: SortOrder
    module_name?: SortOrder
    module_description?: SortOrder
    module_order?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    course_id?: SortOrder
  }

  export type ModuleMinOrderByAggregateInput = {
    module_id?: SortOrder
    module_name?: SortOrder
    module_description?: SortOrder
    module_order?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    course_id?: SortOrder
  }

  export type ModuleSumOrderByAggregateInput = {
    module_id?: SortOrder
    module_order?: SortOrder
  }

  export type SectionCountOrderByAggregateInput = {
    section_id?: SortOrder
    section_name?: SortOrder
    section_description?: SortOrder
    section_order?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    module_id?: SortOrder
  }

  export type SectionAvgOrderByAggregateInput = {
    section_id?: SortOrder
    section_order?: SortOrder
    module_id?: SortOrder
  }

  export type SectionMaxOrderByAggregateInput = {
    section_id?: SortOrder
    section_name?: SortOrder
    section_description?: SortOrder
    section_order?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    module_id?: SortOrder
  }

  export type SectionMinOrderByAggregateInput = {
    section_id?: SortOrder
    section_name?: SortOrder
    section_description?: SortOrder
    section_order?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    module_id?: SortOrder
  }

  export type SectionSumOrderByAggregateInput = {
    section_id?: SortOrder
    section_order?: SortOrder
    module_id?: SortOrder
  }

  export type TimeOfDayCountOrderByAggregateInput = {
    time_of_day_id?: SortOrder
    time_of_day_name?: SortOrder
  }

  export type TimeOfDayMaxOrderByAggregateInput = {
    time_of_day_id?: SortOrder
    time_of_day_name?: SortOrder
  }

  export type TimeOfDayMinOrderByAggregateInput = {
    time_of_day_id?: SortOrder
    time_of_day_name?: SortOrder
  }

  export type TuitionLangCountOrderByAggregateInput = {
    tuition_lang_code?: SortOrder
    tuition_lang_name?: SortOrder
  }

  export type TuitionLangMaxOrderByAggregateInput = {
    tuition_lang_code?: SortOrder
    tuition_lang_name?: SortOrder
  }

  export type TuitionLangMinOrderByAggregateInput = {
    tuition_lang_code?: SortOrder
    tuition_lang_name?: SortOrder
  }

  export type DeckCountOrderByAggregateInput = {
    deck_id?: SortOrder
    user_id?: SortOrder
    deck_description?: SortOrder
  }

  export type DeckMaxOrderByAggregateInput = {
    deck_id?: SortOrder
    user_id?: SortOrder
    deck_description?: SortOrder
  }

  export type DeckMinOrderByAggregateInput = {
    deck_id?: SortOrder
    user_id?: SortOrder
    deck_description?: SortOrder
  }

  export type DeckRelationFilter = {
    is?: DeckWhereInput
    isNot?: DeckWhereInput
  }

  export type LessonCardCountOrderByAggregateInput = {
    card_id?: SortOrder
    deck_id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    example?: SortOrder
    course_code?: SortOrder
    lesson_id?: SortOrder
  }

  export type LessonCardAvgOrderByAggregateInput = {
    lesson_id?: SortOrder
  }

  export type LessonCardMaxOrderByAggregateInput = {
    card_id?: SortOrder
    deck_id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    example?: SortOrder
    course_code?: SortOrder
    lesson_id?: SortOrder
  }

  export type LessonCardMinOrderByAggregateInput = {
    card_id?: SortOrder
    deck_id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    example?: SortOrder
    course_code?: SortOrder
    lesson_id?: SortOrder
  }

  export type LessonCardSumOrderByAggregateInput = {
    lesson_id?: SortOrder
  }

  export type LessonNullableRelationFilter = {
    is?: LessonWhereInput | null
    isNot?: LessonWhereInput | null
  }

  export type UserCardCountOrderByAggregateInput = {
    user_card_id?: SortOrder
    user_id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    example?: SortOrder
    lesson_id?: SortOrder
  }

  export type UserCardAvgOrderByAggregateInput = {
    lesson_id?: SortOrder
  }

  export type UserCardMaxOrderByAggregateInput = {
    user_card_id?: SortOrder
    user_id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    example?: SortOrder
    lesson_id?: SortOrder
  }

  export type UserCardMinOrderByAggregateInput = {
    user_card_id?: SortOrder
    user_id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    example?: SortOrder
    lesson_id?: SortOrder
  }

  export type UserCardSumOrderByAggregateInput = {
    lesson_id?: SortOrder
  }

  export type VocabularyCountOrderByAggregateInput = {
    vocabulary_id?: SortOrder
    user_id?: SortOrder
  }

  export type VocabularyMaxOrderByAggregateInput = {
    vocabulary_id?: SortOrder
    user_id?: SortOrder
  }

  export type VocabularyMinOrderByAggregateInput = {
    vocabulary_id?: SortOrder
    user_id?: SortOrder
  }

  export type VocabularyInboxUser_idQuestionCompoundUniqueInput = {
    user_id: string
    question: string
  }

  export type VocabularyInboxCountOrderByAggregateInput = {
    user_id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
  }

  export type VocabularyInboxMaxOrderByAggregateInput = {
    user_id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
  }

  export type VocabularyInboxMinOrderByAggregateInput = {
    user_id?: SortOrder
    question?: SortOrder
    answer?: SortOrder
  }

  export type EnumBookingRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingRequestStatus | EnumBookingRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingRequestStatus[] | ListEnumBookingRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingRequestStatus[] | ListEnumBookingRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingRequestStatusFilter<$PrismaModel> | $Enums.BookingRequestStatus
  }

  export type BookingRequestCountOrderByAggregateInput = {
    booking_request_id?: SortOrder
    class_id?: SortOrder
    booking_date?: SortOrder
    booking_request_status?: SortOrder
    user_stated_name?: SortOrder
    user_stated_phone?: SortOrder
    user_stated_email?: SortOrder
    user_stated_telegram_nickname?: SortOrder
  }

  export type BookingRequestMaxOrderByAggregateInput = {
    booking_request_id?: SortOrder
    class_id?: SortOrder
    booking_date?: SortOrder
    booking_request_status?: SortOrder
    user_stated_name?: SortOrder
    user_stated_phone?: SortOrder
    user_stated_email?: SortOrder
    user_stated_telegram_nickname?: SortOrder
  }

  export type BookingRequestMinOrderByAggregateInput = {
    booking_request_id?: SortOrder
    class_id?: SortOrder
    booking_date?: SortOrder
    booking_request_status?: SortOrder
    user_stated_name?: SortOrder
    user_stated_phone?: SortOrder
    user_stated_email?: SortOrder
    user_stated_telegram_nickname?: SortOrder
  }

  export type EnumBookingRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingRequestStatus | EnumBookingRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingRequestStatus[] | ListEnumBookingRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingRequestStatus[] | ListEnumBookingRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingRequestStatusFilter<$PrismaModel>
  }

  export type CourseTaskRelationFilter = {
    is?: CourseTaskWhereInput
    isNot?: CourseTaskWhereInput
  }

  export type StudentTaskListRelationFilter = {
    every?: StudentTaskWhereInput
    some?: StudentTaskWhereInput
    none?: StudentTaskWhereInput
  }

  export type StudentAnswerListRelationFilter = {
    every?: StudentAnswerWhereInput
    some?: StudentAnswerWhereInput
    none?: StudentAnswerWhereInput
  }

  export type StudentTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassTaskCountOrderByAggregateInput = {
    class_task_id?: SortOrder
    course_task_id?: SortOrder
    class_id?: SortOrder
  }

  export type ClassTaskAvgOrderByAggregateInput = {
    class_task_id?: SortOrder
  }

  export type ClassTaskMaxOrderByAggregateInput = {
    class_task_id?: SortOrder
    course_task_id?: SortOrder
    class_id?: SortOrder
  }

  export type ClassTaskMinOrderByAggregateInput = {
    class_task_id?: SortOrder
    course_task_id?: SortOrder
    class_id?: SortOrder
  }

  export type ClassTaskSumOrderByAggregateInput = {
    class_task_id?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    student_id?: SortOrder
    user_id?: SortOrder
    student_nickname?: SortOrder
    enrolled_date?: SortOrder
    left_date?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    class_id?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    student_id?: SortOrder
    user_id?: SortOrder
    student_nickname?: SortOrder
    enrolled_date?: SortOrder
    left_date?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    class_id?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    student_id?: SortOrder
    user_id?: SortOrder
    student_nickname?: SortOrder
    enrolled_date?: SortOrder
    left_date?: SortOrder
    created_date?: SortOrder
    updated_date?: SortOrder
    deleted?: SortOrder
    class_id?: SortOrder
  }

  export type StudentRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type ClassTaskRelationFilter = {
    is?: ClassTaskWhereInput
    isNot?: ClassTaskWhereInput
  }

  export type StudentAnswerCountOrderByAggregateInput = {
    student_answer_id?: SortOrder
    student_id?: SortOrder
    class_task_id?: SortOrder
    answer?: SortOrder
  }

  export type StudentAnswerAvgOrderByAggregateInput = {
    student_answer_id?: SortOrder
    class_task_id?: SortOrder
  }

  export type StudentAnswerMaxOrderByAggregateInput = {
    student_answer_id?: SortOrder
    student_id?: SortOrder
    class_task_id?: SortOrder
    answer?: SortOrder
  }

  export type StudentAnswerMinOrderByAggregateInput = {
    student_answer_id?: SortOrder
    student_id?: SortOrder
    class_task_id?: SortOrder
    answer?: SortOrder
  }

  export type StudentAnswerSumOrderByAggregateInput = {
    student_answer_id?: SortOrder
    class_task_id?: SortOrder
  }

  export type EnumStudentTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentTaskStatus | EnumStudentTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentTaskStatus[] | ListEnumStudentTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentTaskStatus[] | ListEnumStudentTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentTaskStatusFilter<$PrismaModel> | $Enums.StudentTaskStatus
  }

  export type StudentTaskCountOrderByAggregateInput = {
    student_task_id?: SortOrder
    student_id?: SortOrder
    class_task_id?: SortOrder
    task_status?: SortOrder
  }

  export type StudentTaskAvgOrderByAggregateInput = {
    student_task_id?: SortOrder
    class_task_id?: SortOrder
  }

  export type StudentTaskMaxOrderByAggregateInput = {
    student_task_id?: SortOrder
    student_id?: SortOrder
    class_task_id?: SortOrder
    task_status?: SortOrder
  }

  export type StudentTaskMinOrderByAggregateInput = {
    student_task_id?: SortOrder
    student_id?: SortOrder
    class_task_id?: SortOrder
    task_status?: SortOrder
  }

  export type StudentTaskSumOrderByAggregateInput = {
    student_task_id?: SortOrder
    class_task_id?: SortOrder
  }

  export type EnumStudentTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentTaskStatus | EnumStudentTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentTaskStatus[] | ListEnumStudentTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentTaskStatus[] | ListEnumStudentTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentTaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentTaskStatusFilter<$PrismaModel>
  }

  export type TaskTypeRelationFilter = {
    is?: TaskTypeWhereInput
    isNot?: TaskTypeWhereInput
  }

  export type TaskContextRelationFilter = {
    is?: TaskContextWhereInput
    isNot?: TaskContextWhereInput
  }

  export type TaskFormListRelationFilter = {
    every?: TaskFormWhereInput
    some?: TaskFormWhereInput
    none?: TaskFormWhereInput
  }

  export type TaskOptionListRelationFilter = {
    every?: TaskOptionWhereInput
    some?: TaskOptionWhereInput
    none?: TaskOptionWhereInput
  }

  export type TaskFormOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCountOrderByAggregateInput = {
    task_id?: SortOrder
    task_description?: SortOrder
    task_text?: SortOrder
    task_type_id?: SortOrder
    task_context_id?: SortOrder
    task_form_id?: SortOrder
    task_created_date?: SortOrder
    task_updated_date?: SortOrder
    deleted?: SortOrder
    lesson_id?: SortOrder
    gap_map?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    task_id?: SortOrder
    task_type_id?: SortOrder
    task_form_id?: SortOrder
    lesson_id?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    task_id?: SortOrder
    task_description?: SortOrder
    task_text?: SortOrder
    task_type_id?: SortOrder
    task_context_id?: SortOrder
    task_form_id?: SortOrder
    task_created_date?: SortOrder
    task_updated_date?: SortOrder
    deleted?: SortOrder
    lesson_id?: SortOrder
    gap_map?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    task_id?: SortOrder
    task_description?: SortOrder
    task_text?: SortOrder
    task_type_id?: SortOrder
    task_context_id?: SortOrder
    task_form_id?: SortOrder
    task_created_date?: SortOrder
    task_updated_date?: SortOrder
    deleted?: SortOrder
    lesson_id?: SortOrder
    gap_map?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    task_id?: SortOrder
    task_type_id?: SortOrder
    task_form_id?: SortOrder
    lesson_id?: SortOrder
  }

  export type TaskFormCountOrderByAggregateInput = {
    task_form_id?: SortOrder
    task_form_name?: SortOrder
    task_form_description?: SortOrder
  }

  export type TaskFormAvgOrderByAggregateInput = {
    task_form_id?: SortOrder
  }

  export type TaskFormMaxOrderByAggregateInput = {
    task_form_id?: SortOrder
    task_form_name?: SortOrder
    task_form_description?: SortOrder
  }

  export type TaskFormMinOrderByAggregateInput = {
    task_form_id?: SortOrder
    task_form_name?: SortOrder
    task_form_description?: SortOrder
  }

  export type TaskFormSumOrderByAggregateInput = {
    task_form_id?: SortOrder
  }

  export type TaskContextCountOrderByAggregateInput = {
    task_context_id?: SortOrder
    task_context_name?: SortOrder
    task_context_description?: SortOrder
  }

  export type TaskContextMaxOrderByAggregateInput = {
    task_context_id?: SortOrder
    task_context_name?: SortOrder
    task_context_description?: SortOrder
  }

  export type TaskContextMinOrderByAggregateInput = {
    task_context_id?: SortOrder
    task_context_name?: SortOrder
    task_context_description?: SortOrder
  }

  export type TaskOptionCountOrderByAggregateInput = {
    task_option_id?: SortOrder
    task_id?: SortOrder
    task_option_text?: SortOrder
    task_option_order?: SortOrder
    is_correct?: SortOrder
  }

  export type TaskOptionAvgOrderByAggregateInput = {
    task_option_id?: SortOrder
    task_id?: SortOrder
    task_option_order?: SortOrder
  }

  export type TaskOptionMaxOrderByAggregateInput = {
    task_option_id?: SortOrder
    task_id?: SortOrder
    task_option_text?: SortOrder
    task_option_order?: SortOrder
    is_correct?: SortOrder
  }

  export type TaskOptionMinOrderByAggregateInput = {
    task_option_id?: SortOrder
    task_id?: SortOrder
    task_option_text?: SortOrder
    task_option_order?: SortOrder
    is_correct?: SortOrder
  }

  export type TaskOptionSumOrderByAggregateInput = {
    task_option_id?: SortOrder
    task_id?: SortOrder
    task_option_order?: SortOrder
  }

  export type TaskTypeCountOrderByAggregateInput = {
    task_type_id?: SortOrder
    task_type_name?: SortOrder
    task_type_description?: SortOrder
  }

  export type TaskTypeAvgOrderByAggregateInput = {
    task_type_id?: SortOrder
  }

  export type TaskTypeMaxOrderByAggregateInput = {
    task_type_id?: SortOrder
    task_type_name?: SortOrder
    task_type_description?: SortOrder
  }

  export type TaskTypeMinOrderByAggregateInput = {
    task_type_id?: SortOrder
    task_type_name?: SortOrder
    task_type_description?: SortOrder
  }

  export type TaskTypeSumOrderByAggregateInput = {
    task_type_id?: SortOrder
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserApplicationPreferencesCreateNestedManyWithoutUserInput = {
    create?: XOR<UserApplicationPreferencesCreateWithoutUserInput, UserApplicationPreferencesUncheckedCreateWithoutUserInput> | UserApplicationPreferencesCreateWithoutUserInput[] | UserApplicationPreferencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserApplicationPreferencesCreateOrConnectWithoutUserInput | UserApplicationPreferencesCreateOrConnectWithoutUserInput[]
    createMany?: UserApplicationPreferencesCreateManyUserInputEnvelope
    connect?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
  }

  export type MentorCreateNestedManyWithoutUserInput = {
    create?: XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput> | MentorCreateWithoutUserInput[] | MentorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorCreateOrConnectWithoutUserInput | MentorCreateOrConnectWithoutUserInput[]
    createMany?: MentorCreateManyUserInputEnvelope
    connect?: MentorWhereUniqueInput | MentorWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput> | StudentCreateWithoutUserInput[] | StudentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput | StudentCreateOrConnectWithoutUserInput[]
    createMany?: StudentCreateManyUserInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type DataRemovalRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<DataRemovalRequestCreateWithoutUserInput, DataRemovalRequestUncheckedCreateWithoutUserInput> | DataRemovalRequestCreateWithoutUserInput[] | DataRemovalRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataRemovalRequestCreateOrConnectWithoutUserInput | DataRemovalRequestCreateOrConnectWithoutUserInput[]
    createMany?: DataRemovalRequestCreateManyUserInputEnvelope
    connect?: DataRemovalRequestWhereUniqueInput | DataRemovalRequestWhereUniqueInput[]
  }

  export type DeckCreateNestedManyWithoutUserInput = {
    create?: XOR<DeckCreateWithoutUserInput, DeckUncheckedCreateWithoutUserInput> | DeckCreateWithoutUserInput[] | DeckUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeckCreateOrConnectWithoutUserInput | DeckCreateOrConnectWithoutUserInput[]
    createMany?: DeckCreateManyUserInputEnvelope
    connect?: DeckWhereUniqueInput | DeckWhereUniqueInput[]
  }

  export type UserCardCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCardCreateWithoutUserInput, UserCardUncheckedCreateWithoutUserInput> | UserCardCreateWithoutUserInput[] | UserCardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutUserInput | UserCardCreateOrConnectWithoutUserInput[]
    createMany?: UserCardCreateManyUserInputEnvelope
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
  }

  export type VocabularyInboxCreateNestedManyWithoutUserInput = {
    create?: XOR<VocabularyInboxCreateWithoutUserInput, VocabularyInboxUncheckedCreateWithoutUserInput> | VocabularyInboxCreateWithoutUserInput[] | VocabularyInboxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VocabularyInboxCreateOrConnectWithoutUserInput | VocabularyInboxCreateOrConnectWithoutUserInput[]
    createMany?: VocabularyInboxCreateManyUserInputEnvelope
    connect?: VocabularyInboxWhereUniqueInput | VocabularyInboxWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserApplicationPreferencesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserApplicationPreferencesCreateWithoutUserInput, UserApplicationPreferencesUncheckedCreateWithoutUserInput> | UserApplicationPreferencesCreateWithoutUserInput[] | UserApplicationPreferencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserApplicationPreferencesCreateOrConnectWithoutUserInput | UserApplicationPreferencesCreateOrConnectWithoutUserInput[]
    createMany?: UserApplicationPreferencesCreateManyUserInputEnvelope
    connect?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
  }

  export type MentorUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput> | MentorCreateWithoutUserInput[] | MentorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorCreateOrConnectWithoutUserInput | MentorCreateOrConnectWithoutUserInput[]
    createMany?: MentorCreateManyUserInputEnvelope
    connect?: MentorWhereUniqueInput | MentorWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput> | StudentCreateWithoutUserInput[] | StudentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput | StudentCreateOrConnectWithoutUserInput[]
    createMany?: StudentCreateManyUserInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type DataRemovalRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DataRemovalRequestCreateWithoutUserInput, DataRemovalRequestUncheckedCreateWithoutUserInput> | DataRemovalRequestCreateWithoutUserInput[] | DataRemovalRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataRemovalRequestCreateOrConnectWithoutUserInput | DataRemovalRequestCreateOrConnectWithoutUserInput[]
    createMany?: DataRemovalRequestCreateManyUserInputEnvelope
    connect?: DataRemovalRequestWhereUniqueInput | DataRemovalRequestWhereUniqueInput[]
  }

  export type DeckUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeckCreateWithoutUserInput, DeckUncheckedCreateWithoutUserInput> | DeckCreateWithoutUserInput[] | DeckUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeckCreateOrConnectWithoutUserInput | DeckCreateOrConnectWithoutUserInput[]
    createMany?: DeckCreateManyUserInputEnvelope
    connect?: DeckWhereUniqueInput | DeckWhereUniqueInput[]
  }

  export type UserCardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCardCreateWithoutUserInput, UserCardUncheckedCreateWithoutUserInput> | UserCardCreateWithoutUserInput[] | UserCardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutUserInput | UserCardCreateOrConnectWithoutUserInput[]
    createMany?: UserCardCreateManyUserInputEnvelope
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
  }

  export type VocabularyInboxUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VocabularyInboxCreateWithoutUserInput, VocabularyInboxUncheckedCreateWithoutUserInput> | VocabularyInboxCreateWithoutUserInput[] | VocabularyInboxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VocabularyInboxCreateOrConnectWithoutUserInput | VocabularyInboxCreateOrConnectWithoutUserInput[]
    createMany?: VocabularyInboxCreateManyUserInputEnvelope
    connect?: VocabularyInboxWhereUniqueInput | VocabularyInboxWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserApplicationPreferencesUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserApplicationPreferencesCreateWithoutUserInput, UserApplicationPreferencesUncheckedCreateWithoutUserInput> | UserApplicationPreferencesCreateWithoutUserInput[] | UserApplicationPreferencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserApplicationPreferencesCreateOrConnectWithoutUserInput | UserApplicationPreferencesCreateOrConnectWithoutUserInput[]
    upsert?: UserApplicationPreferencesUpsertWithWhereUniqueWithoutUserInput | UserApplicationPreferencesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserApplicationPreferencesCreateManyUserInputEnvelope
    set?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
    disconnect?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
    delete?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
    connect?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
    update?: UserApplicationPreferencesUpdateWithWhereUniqueWithoutUserInput | UserApplicationPreferencesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserApplicationPreferencesUpdateManyWithWhereWithoutUserInput | UserApplicationPreferencesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserApplicationPreferencesScalarWhereInput | UserApplicationPreferencesScalarWhereInput[]
  }

  export type MentorUpdateManyWithoutUserNestedInput = {
    create?: XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput> | MentorCreateWithoutUserInput[] | MentorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorCreateOrConnectWithoutUserInput | MentorCreateOrConnectWithoutUserInput[]
    upsert?: MentorUpsertWithWhereUniqueWithoutUserInput | MentorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MentorCreateManyUserInputEnvelope
    set?: MentorWhereUniqueInput | MentorWhereUniqueInput[]
    disconnect?: MentorWhereUniqueInput | MentorWhereUniqueInput[]
    delete?: MentorWhereUniqueInput | MentorWhereUniqueInput[]
    connect?: MentorWhereUniqueInput | MentorWhereUniqueInput[]
    update?: MentorUpdateWithWhereUniqueWithoutUserInput | MentorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MentorUpdateManyWithWhereWithoutUserInput | MentorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MentorScalarWhereInput | MentorScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput> | StudentCreateWithoutUserInput[] | StudentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput | StudentCreateOrConnectWithoutUserInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutUserInput | StudentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudentCreateManyUserInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutUserInput | StudentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutUserInput | StudentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type DataRemovalRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataRemovalRequestCreateWithoutUserInput, DataRemovalRequestUncheckedCreateWithoutUserInput> | DataRemovalRequestCreateWithoutUserInput[] | DataRemovalRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataRemovalRequestCreateOrConnectWithoutUserInput | DataRemovalRequestCreateOrConnectWithoutUserInput[]
    upsert?: DataRemovalRequestUpsertWithWhereUniqueWithoutUserInput | DataRemovalRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataRemovalRequestCreateManyUserInputEnvelope
    set?: DataRemovalRequestWhereUniqueInput | DataRemovalRequestWhereUniqueInput[]
    disconnect?: DataRemovalRequestWhereUniqueInput | DataRemovalRequestWhereUniqueInput[]
    delete?: DataRemovalRequestWhereUniqueInput | DataRemovalRequestWhereUniqueInput[]
    connect?: DataRemovalRequestWhereUniqueInput | DataRemovalRequestWhereUniqueInput[]
    update?: DataRemovalRequestUpdateWithWhereUniqueWithoutUserInput | DataRemovalRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataRemovalRequestUpdateManyWithWhereWithoutUserInput | DataRemovalRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataRemovalRequestScalarWhereInput | DataRemovalRequestScalarWhereInput[]
  }

  export type DeckUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeckCreateWithoutUserInput, DeckUncheckedCreateWithoutUserInput> | DeckCreateWithoutUserInput[] | DeckUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeckCreateOrConnectWithoutUserInput | DeckCreateOrConnectWithoutUserInput[]
    upsert?: DeckUpsertWithWhereUniqueWithoutUserInput | DeckUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeckCreateManyUserInputEnvelope
    set?: DeckWhereUniqueInput | DeckWhereUniqueInput[]
    disconnect?: DeckWhereUniqueInput | DeckWhereUniqueInput[]
    delete?: DeckWhereUniqueInput | DeckWhereUniqueInput[]
    connect?: DeckWhereUniqueInput | DeckWhereUniqueInput[]
    update?: DeckUpdateWithWhereUniqueWithoutUserInput | DeckUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeckUpdateManyWithWhereWithoutUserInput | DeckUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeckScalarWhereInput | DeckScalarWhereInput[]
  }

  export type UserCardUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCardCreateWithoutUserInput, UserCardUncheckedCreateWithoutUserInput> | UserCardCreateWithoutUserInput[] | UserCardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutUserInput | UserCardCreateOrConnectWithoutUserInput[]
    upsert?: UserCardUpsertWithWhereUniqueWithoutUserInput | UserCardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCardCreateManyUserInputEnvelope
    set?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    disconnect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    delete?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    update?: UserCardUpdateWithWhereUniqueWithoutUserInput | UserCardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCardUpdateManyWithWhereWithoutUserInput | UserCardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCardScalarWhereInput | UserCardScalarWhereInput[]
  }

  export type VocabularyInboxUpdateManyWithoutUserNestedInput = {
    create?: XOR<VocabularyInboxCreateWithoutUserInput, VocabularyInboxUncheckedCreateWithoutUserInput> | VocabularyInboxCreateWithoutUserInput[] | VocabularyInboxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VocabularyInboxCreateOrConnectWithoutUserInput | VocabularyInboxCreateOrConnectWithoutUserInput[]
    upsert?: VocabularyInboxUpsertWithWhereUniqueWithoutUserInput | VocabularyInboxUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VocabularyInboxCreateManyUserInputEnvelope
    set?: VocabularyInboxWhereUniqueInput | VocabularyInboxWhereUniqueInput[]
    disconnect?: VocabularyInboxWhereUniqueInput | VocabularyInboxWhereUniqueInput[]
    delete?: VocabularyInboxWhereUniqueInput | VocabularyInboxWhereUniqueInput[]
    connect?: VocabularyInboxWhereUniqueInput | VocabularyInboxWhereUniqueInput[]
    update?: VocabularyInboxUpdateWithWhereUniqueWithoutUserInput | VocabularyInboxUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VocabularyInboxUpdateManyWithWhereWithoutUserInput | VocabularyInboxUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VocabularyInboxScalarWhereInput | VocabularyInboxScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserApplicationPreferencesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserApplicationPreferencesCreateWithoutUserInput, UserApplicationPreferencesUncheckedCreateWithoutUserInput> | UserApplicationPreferencesCreateWithoutUserInput[] | UserApplicationPreferencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserApplicationPreferencesCreateOrConnectWithoutUserInput | UserApplicationPreferencesCreateOrConnectWithoutUserInput[]
    upsert?: UserApplicationPreferencesUpsertWithWhereUniqueWithoutUserInput | UserApplicationPreferencesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserApplicationPreferencesCreateManyUserInputEnvelope
    set?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
    disconnect?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
    delete?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
    connect?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
    update?: UserApplicationPreferencesUpdateWithWhereUniqueWithoutUserInput | UserApplicationPreferencesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserApplicationPreferencesUpdateManyWithWhereWithoutUserInput | UserApplicationPreferencesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserApplicationPreferencesScalarWhereInput | UserApplicationPreferencesScalarWhereInput[]
  }

  export type MentorUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput> | MentorCreateWithoutUserInput[] | MentorUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MentorCreateOrConnectWithoutUserInput | MentorCreateOrConnectWithoutUserInput[]
    upsert?: MentorUpsertWithWhereUniqueWithoutUserInput | MentorUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MentorCreateManyUserInputEnvelope
    set?: MentorWhereUniqueInput | MentorWhereUniqueInput[]
    disconnect?: MentorWhereUniqueInput | MentorWhereUniqueInput[]
    delete?: MentorWhereUniqueInput | MentorWhereUniqueInput[]
    connect?: MentorWhereUniqueInput | MentorWhereUniqueInput[]
    update?: MentorUpdateWithWhereUniqueWithoutUserInput | MentorUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MentorUpdateManyWithWhereWithoutUserInput | MentorUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MentorScalarWhereInput | MentorScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput> | StudentCreateWithoutUserInput[] | StudentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput | StudentCreateOrConnectWithoutUserInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutUserInput | StudentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudentCreateManyUserInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutUserInput | StudentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutUserInput | StudentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type DataRemovalRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataRemovalRequestCreateWithoutUserInput, DataRemovalRequestUncheckedCreateWithoutUserInput> | DataRemovalRequestCreateWithoutUserInput[] | DataRemovalRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataRemovalRequestCreateOrConnectWithoutUserInput | DataRemovalRequestCreateOrConnectWithoutUserInput[]
    upsert?: DataRemovalRequestUpsertWithWhereUniqueWithoutUserInput | DataRemovalRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataRemovalRequestCreateManyUserInputEnvelope
    set?: DataRemovalRequestWhereUniqueInput | DataRemovalRequestWhereUniqueInput[]
    disconnect?: DataRemovalRequestWhereUniqueInput | DataRemovalRequestWhereUniqueInput[]
    delete?: DataRemovalRequestWhereUniqueInput | DataRemovalRequestWhereUniqueInput[]
    connect?: DataRemovalRequestWhereUniqueInput | DataRemovalRequestWhereUniqueInput[]
    update?: DataRemovalRequestUpdateWithWhereUniqueWithoutUserInput | DataRemovalRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataRemovalRequestUpdateManyWithWhereWithoutUserInput | DataRemovalRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataRemovalRequestScalarWhereInput | DataRemovalRequestScalarWhereInput[]
  }

  export type DeckUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeckCreateWithoutUserInput, DeckUncheckedCreateWithoutUserInput> | DeckCreateWithoutUserInput[] | DeckUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeckCreateOrConnectWithoutUserInput | DeckCreateOrConnectWithoutUserInput[]
    upsert?: DeckUpsertWithWhereUniqueWithoutUserInput | DeckUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeckCreateManyUserInputEnvelope
    set?: DeckWhereUniqueInput | DeckWhereUniqueInput[]
    disconnect?: DeckWhereUniqueInput | DeckWhereUniqueInput[]
    delete?: DeckWhereUniqueInput | DeckWhereUniqueInput[]
    connect?: DeckWhereUniqueInput | DeckWhereUniqueInput[]
    update?: DeckUpdateWithWhereUniqueWithoutUserInput | DeckUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeckUpdateManyWithWhereWithoutUserInput | DeckUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeckScalarWhereInput | DeckScalarWhereInput[]
  }

  export type UserCardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCardCreateWithoutUserInput, UserCardUncheckedCreateWithoutUserInput> | UserCardCreateWithoutUserInput[] | UserCardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutUserInput | UserCardCreateOrConnectWithoutUserInput[]
    upsert?: UserCardUpsertWithWhereUniqueWithoutUserInput | UserCardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCardCreateManyUserInputEnvelope
    set?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    disconnect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    delete?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    update?: UserCardUpdateWithWhereUniqueWithoutUserInput | UserCardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCardUpdateManyWithWhereWithoutUserInput | UserCardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCardScalarWhereInput | UserCardScalarWhereInput[]
  }

  export type VocabularyInboxUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VocabularyInboxCreateWithoutUserInput, VocabularyInboxUncheckedCreateWithoutUserInput> | VocabularyInboxCreateWithoutUserInput[] | VocabularyInboxUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VocabularyInboxCreateOrConnectWithoutUserInput | VocabularyInboxCreateOrConnectWithoutUserInput[]
    upsert?: VocabularyInboxUpsertWithWhereUniqueWithoutUserInput | VocabularyInboxUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VocabularyInboxCreateManyUserInputEnvelope
    set?: VocabularyInboxWhereUniqueInput | VocabularyInboxWhereUniqueInput[]
    disconnect?: VocabularyInboxWhereUniqueInput | VocabularyInboxWhereUniqueInput[]
    delete?: VocabularyInboxWhereUniqueInput | VocabularyInboxWhereUniqueInput[]
    connect?: VocabularyInboxWhereUniqueInput | VocabularyInboxWhereUniqueInput[]
    update?: VocabularyInboxUpdateWithWhereUniqueWithoutUserInput | VocabularyInboxUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VocabularyInboxUpdateManyWithWhereWithoutUserInput | VocabularyInboxUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VocabularyInboxScalarWhereInput | VocabularyInboxScalarWhereInput[]
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUser_rolesInput = {
    create?: XOR<UserCreateWithoutUser_rolesInput, UserUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_rolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUser_rolesInput = {
    create?: XOR<RoleCreateWithoutUser_rolesInput, RoleUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUser_rolesInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUser_rolesNestedInput = {
    create?: XOR<UserCreateWithoutUser_rolesInput, UserUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_rolesInput
    upsert?: UserUpsertWithoutUser_rolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_rolesInput, UserUpdateWithoutUser_rolesInput>, UserUncheckedUpdateWithoutUser_rolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUser_rolesNestedInput = {
    create?: XOR<RoleCreateWithoutUser_rolesInput, RoleUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUser_rolesInput
    upsert?: RoleUpsertWithoutUser_rolesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUser_rolesInput, RoleUpdateWithoutUser_rolesInput>, RoleUncheckedUpdateWithoutUser_rolesInput>
  }

  export type UserCreateNestedOneWithoutUser_application_preferencesInput = {
    create?: XOR<UserCreateWithoutUser_application_preferencesInput, UserUncheckedCreateWithoutUser_application_preferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_application_preferencesInput
    connect?: UserWhereUniqueInput
  }

  export type ApplicationCreateNestedOneWithoutUser_application_preferencesInput = {
    create?: XOR<ApplicationCreateWithoutUser_application_preferencesInput, ApplicationUncheckedCreateWithoutUser_application_preferencesInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutUser_application_preferencesInput
    connect?: ApplicationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUser_application_preferencesNestedInput = {
    create?: XOR<UserCreateWithoutUser_application_preferencesInput, UserUncheckedCreateWithoutUser_application_preferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_application_preferencesInput
    upsert?: UserUpsertWithoutUser_application_preferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_application_preferencesInput, UserUpdateWithoutUser_application_preferencesInput>, UserUncheckedUpdateWithoutUser_application_preferencesInput>
  }

  export type ApplicationUpdateOneRequiredWithoutUser_application_preferencesNestedInput = {
    create?: XOR<ApplicationCreateWithoutUser_application_preferencesInput, ApplicationUncheckedCreateWithoutUser_application_preferencesInput>
    connectOrCreate?: ApplicationCreateOrConnectWithoutUser_application_preferencesInput
    upsert?: ApplicationUpsertWithoutUser_application_preferencesInput
    connect?: ApplicationWhereUniqueInput
    update?: XOR<XOR<ApplicationUpdateToOneWithWhereWithoutUser_application_preferencesInput, ApplicationUpdateWithoutUser_application_preferencesInput>, ApplicationUncheckedUpdateWithoutUser_application_preferencesInput>
  }

  export type UserApplicationPreferencesCreateNestedManyWithoutApplicationInput = {
    create?: XOR<UserApplicationPreferencesCreateWithoutApplicationInput, UserApplicationPreferencesUncheckedCreateWithoutApplicationInput> | UserApplicationPreferencesCreateWithoutApplicationInput[] | UserApplicationPreferencesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: UserApplicationPreferencesCreateOrConnectWithoutApplicationInput | UserApplicationPreferencesCreateOrConnectWithoutApplicationInput[]
    createMany?: UserApplicationPreferencesCreateManyApplicationInputEnvelope
    connect?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
  }

  export type UserApplicationPreferencesUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<UserApplicationPreferencesCreateWithoutApplicationInput, UserApplicationPreferencesUncheckedCreateWithoutApplicationInput> | UserApplicationPreferencesCreateWithoutApplicationInput[] | UserApplicationPreferencesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: UserApplicationPreferencesCreateOrConnectWithoutApplicationInput | UserApplicationPreferencesCreateOrConnectWithoutApplicationInput[]
    createMany?: UserApplicationPreferencesCreateManyApplicationInputEnvelope
    connect?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
  }

  export type UserApplicationPreferencesUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<UserApplicationPreferencesCreateWithoutApplicationInput, UserApplicationPreferencesUncheckedCreateWithoutApplicationInput> | UserApplicationPreferencesCreateWithoutApplicationInput[] | UserApplicationPreferencesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: UserApplicationPreferencesCreateOrConnectWithoutApplicationInput | UserApplicationPreferencesCreateOrConnectWithoutApplicationInput[]
    upsert?: UserApplicationPreferencesUpsertWithWhereUniqueWithoutApplicationInput | UserApplicationPreferencesUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: UserApplicationPreferencesCreateManyApplicationInputEnvelope
    set?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
    disconnect?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
    delete?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
    connect?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
    update?: UserApplicationPreferencesUpdateWithWhereUniqueWithoutApplicationInput | UserApplicationPreferencesUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: UserApplicationPreferencesUpdateManyWithWhereWithoutApplicationInput | UserApplicationPreferencesUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: UserApplicationPreferencesScalarWhereInput | UserApplicationPreferencesScalarWhereInput[]
  }

  export type UserApplicationPreferencesUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<UserApplicationPreferencesCreateWithoutApplicationInput, UserApplicationPreferencesUncheckedCreateWithoutApplicationInput> | UserApplicationPreferencesCreateWithoutApplicationInput[] | UserApplicationPreferencesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: UserApplicationPreferencesCreateOrConnectWithoutApplicationInput | UserApplicationPreferencesCreateOrConnectWithoutApplicationInput[]
    upsert?: UserApplicationPreferencesUpsertWithWhereUniqueWithoutApplicationInput | UserApplicationPreferencesUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: UserApplicationPreferencesCreateManyApplicationInputEnvelope
    set?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
    disconnect?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
    delete?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
    connect?: UserApplicationPreferencesWhereUniqueInput | UserApplicationPreferencesWhereUniqueInput[]
    update?: UserApplicationPreferencesUpdateWithWhereUniqueWithoutApplicationInput | UserApplicationPreferencesUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: UserApplicationPreferencesUpdateManyWithWhereWithoutApplicationInput | UserApplicationPreferencesUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: UserApplicationPreferencesScalarWhereInput | UserApplicationPreferencesScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDataRemovalRequestInput = {
    create?: XOR<UserCreateWithoutDataRemovalRequestInput, UserUncheckedCreateWithoutDataRemovalRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutDataRemovalRequestInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDataRemovalStatusEnumFieldUpdateOperationsInput = {
    set?: $Enums.DataRemovalStatusEnum
  }

  export type UserUpdateOneRequiredWithoutDataRemovalRequestNestedInput = {
    create?: XOR<UserCreateWithoutDataRemovalRequestInput, UserUncheckedCreateWithoutDataRemovalRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutDataRemovalRequestInput
    upsert?: UserUpsertWithoutDataRemovalRequestInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDataRemovalRequestInput, UserUpdateWithoutDataRemovalRequestInput>, UserUncheckedUpdateWithoutDataRemovalRequestInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClassCallCreateNestedManyWithoutMeeting_kindInput = {
    create?: XOR<ClassCallCreateWithoutMeeting_kindInput, ClassCallUncheckedCreateWithoutMeeting_kindInput> | ClassCallCreateWithoutMeeting_kindInput[] | ClassCallUncheckedCreateWithoutMeeting_kindInput[]
    connectOrCreate?: ClassCallCreateOrConnectWithoutMeeting_kindInput | ClassCallCreateOrConnectWithoutMeeting_kindInput[]
    createMany?: ClassCallCreateManyMeeting_kindInputEnvelope
    connect?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
  }

  export type ClassCallUncheckedCreateNestedManyWithoutMeeting_kindInput = {
    create?: XOR<ClassCallCreateWithoutMeeting_kindInput, ClassCallUncheckedCreateWithoutMeeting_kindInput> | ClassCallCreateWithoutMeeting_kindInput[] | ClassCallUncheckedCreateWithoutMeeting_kindInput[]
    connectOrCreate?: ClassCallCreateOrConnectWithoutMeeting_kindInput | ClassCallCreateOrConnectWithoutMeeting_kindInput[]
    createMany?: ClassCallCreateManyMeeting_kindInputEnvelope
    connect?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
  }

  export type ClassCallUpdateManyWithoutMeeting_kindNestedInput = {
    create?: XOR<ClassCallCreateWithoutMeeting_kindInput, ClassCallUncheckedCreateWithoutMeeting_kindInput> | ClassCallCreateWithoutMeeting_kindInput[] | ClassCallUncheckedCreateWithoutMeeting_kindInput[]
    connectOrCreate?: ClassCallCreateOrConnectWithoutMeeting_kindInput | ClassCallCreateOrConnectWithoutMeeting_kindInput[]
    upsert?: ClassCallUpsertWithWhereUniqueWithoutMeeting_kindInput | ClassCallUpsertWithWhereUniqueWithoutMeeting_kindInput[]
    createMany?: ClassCallCreateManyMeeting_kindInputEnvelope
    set?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
    disconnect?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
    delete?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
    connect?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
    update?: ClassCallUpdateWithWhereUniqueWithoutMeeting_kindInput | ClassCallUpdateWithWhereUniqueWithoutMeeting_kindInput[]
    updateMany?: ClassCallUpdateManyWithWhereWithoutMeeting_kindInput | ClassCallUpdateManyWithWhereWithoutMeeting_kindInput[]
    deleteMany?: ClassCallScalarWhereInput | ClassCallScalarWhereInput[]
  }

  export type ClassCallUncheckedUpdateManyWithoutMeeting_kindNestedInput = {
    create?: XOR<ClassCallCreateWithoutMeeting_kindInput, ClassCallUncheckedCreateWithoutMeeting_kindInput> | ClassCallCreateWithoutMeeting_kindInput[] | ClassCallUncheckedCreateWithoutMeeting_kindInput[]
    connectOrCreate?: ClassCallCreateOrConnectWithoutMeeting_kindInput | ClassCallCreateOrConnectWithoutMeeting_kindInput[]
    upsert?: ClassCallUpsertWithWhereUniqueWithoutMeeting_kindInput | ClassCallUpsertWithWhereUniqueWithoutMeeting_kindInput[]
    createMany?: ClassCallCreateManyMeeting_kindInputEnvelope
    set?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
    disconnect?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
    delete?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
    connect?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
    update?: ClassCallUpdateWithWhereUniqueWithoutMeeting_kindInput | ClassCallUpdateWithWhereUniqueWithoutMeeting_kindInput[]
    updateMany?: ClassCallUpdateManyWithWhereWithoutMeeting_kindInput | ClassCallUpdateManyWithWhereWithoutMeeting_kindInput[]
    deleteMany?: ClassCallScalarWhereInput | ClassCallScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutCourseStructureInput = {
    create?: XOR<CourseCreateWithoutCourseStructureInput, CourseUncheckedCreateWithoutCourseStructureInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseStructureInput
    connect?: CourseWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutCourseStructureInput = {
    create?: XOR<ModuleCreateWithoutCourseStructureInput, ModuleUncheckedCreateWithoutCourseStructureInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseStructureInput
    connect?: ModuleWhereUniqueInput
  }

  export type SectionCreateNestedOneWithoutCourseStructureInput = {
    create?: XOR<SectionCreateWithoutCourseStructureInput, SectionUncheckedCreateWithoutCourseStructureInput>
    connectOrCreate?: SectionCreateOrConnectWithoutCourseStructureInput
    connect?: SectionWhereUniqueInput
  }

  export type LessonCreateNestedOneWithoutCourseStructureInput = {
    create?: XOR<LessonCreateWithoutCourseStructureInput, LessonUncheckedCreateWithoutCourseStructureInput>
    connectOrCreate?: LessonCreateOrConnectWithoutCourseStructureInput
    connect?: LessonWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutCourseStructureNestedInput = {
    create?: XOR<CourseCreateWithoutCourseStructureInput, CourseUncheckedCreateWithoutCourseStructureInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseStructureInput
    upsert?: CourseUpsertWithoutCourseStructureInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCourseStructureInput, CourseUpdateWithoutCourseStructureInput>, CourseUncheckedUpdateWithoutCourseStructureInput>
  }

  export type ModuleUpdateOneRequiredWithoutCourseStructureNestedInput = {
    create?: XOR<ModuleCreateWithoutCourseStructureInput, ModuleUncheckedCreateWithoutCourseStructureInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseStructureInput
    upsert?: ModuleUpsertWithoutCourseStructureInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutCourseStructureInput, ModuleUpdateWithoutCourseStructureInput>, ModuleUncheckedUpdateWithoutCourseStructureInput>
  }

  export type SectionUpdateOneRequiredWithoutCourseStructureNestedInput = {
    create?: XOR<SectionCreateWithoutCourseStructureInput, SectionUncheckedCreateWithoutCourseStructureInput>
    connectOrCreate?: SectionCreateOrConnectWithoutCourseStructureInput
    upsert?: SectionUpsertWithoutCourseStructureInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutCourseStructureInput, SectionUpdateWithoutCourseStructureInput>, SectionUncheckedUpdateWithoutCourseStructureInput>
  }

  export type LessonUpdateOneRequiredWithoutCourseStructureNestedInput = {
    create?: XOR<LessonCreateWithoutCourseStructureInput, LessonUncheckedCreateWithoutCourseStructureInput>
    connectOrCreate?: LessonCreateOrConnectWithoutCourseStructureInput
    upsert?: LessonUpsertWithoutCourseStructureInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutCourseStructureInput, LessonUpdateWithoutCourseStructureInput>, LessonUncheckedUpdateWithoutCourseStructureInput>
  }

  export type ClassSizeCreateNestedOneWithoutClassesInput = {
    create?: XOR<ClassSizeCreateWithoutClassesInput, ClassSizeUncheckedCreateWithoutClassesInput>
    connectOrCreate?: ClassSizeCreateOrConnectWithoutClassesInput
    connect?: ClassSizeWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutClassesInput = {
    create?: XOR<CourseCreateWithoutClassesInput, CourseUncheckedCreateWithoutClassesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutClassesInput
    connect?: CourseWhereUniqueInput
  }

  export type TimeOfDayCreateNestedOneWithoutClassesInput = {
    create?: XOR<TimeOfDayCreateWithoutClassesInput, TimeOfDayUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TimeOfDayCreateOrConnectWithoutClassesInput
    connect?: TimeOfDayWhereUniqueInput
  }

  export type TuitionLangCreateNestedOneWithoutClassesInput = {
    create?: XOR<TuitionLangCreateWithoutClassesInput, TuitionLangUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TuitionLangCreateOrConnectWithoutClassesInput
    connect?: TuitionLangWhereUniqueInput
  }

  export type MentorsClassesCreateNestedManyWithoutClassInput = {
    create?: XOR<MentorsClassesCreateWithoutClassInput, MentorsClassesUncheckedCreateWithoutClassInput> | MentorsClassesCreateWithoutClassInput[] | MentorsClassesUncheckedCreateWithoutClassInput[]
    connectOrCreate?: MentorsClassesCreateOrConnectWithoutClassInput | MentorsClassesCreateOrConnectWithoutClassInput[]
    createMany?: MentorsClassesCreateManyClassInputEnvelope
    connect?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type BookingRequestCreateNestedManyWithoutClassInput = {
    create?: XOR<BookingRequestCreateWithoutClassInput, BookingRequestUncheckedCreateWithoutClassInput> | BookingRequestCreateWithoutClassInput[] | BookingRequestUncheckedCreateWithoutClassInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutClassInput | BookingRequestCreateOrConnectWithoutClassInput[]
    createMany?: BookingRequestCreateManyClassInputEnvelope
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
  }

  export type ClassCallCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassCallCreateWithoutClassInput, ClassCallUncheckedCreateWithoutClassInput> | ClassCallCreateWithoutClassInput[] | ClassCallUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassCallCreateOrConnectWithoutClassInput | ClassCallCreateOrConnectWithoutClassInput[]
    createMany?: ClassCallCreateManyClassInputEnvelope
    connect?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
  }

  export type ClassTaskCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassTaskCreateWithoutClassInput, ClassTaskUncheckedCreateWithoutClassInput> | ClassTaskCreateWithoutClassInput[] | ClassTaskUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassTaskCreateOrConnectWithoutClassInput | ClassTaskCreateOrConnectWithoutClassInput[]
    createMany?: ClassTaskCreateManyClassInputEnvelope
    connect?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
  }

  export type MentorsClassesUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<MentorsClassesCreateWithoutClassInput, MentorsClassesUncheckedCreateWithoutClassInput> | MentorsClassesCreateWithoutClassInput[] | MentorsClassesUncheckedCreateWithoutClassInput[]
    connectOrCreate?: MentorsClassesCreateOrConnectWithoutClassInput | MentorsClassesCreateOrConnectWithoutClassInput[]
    createMany?: MentorsClassesCreateManyClassInputEnvelope
    connect?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type BookingRequestUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<BookingRequestCreateWithoutClassInput, BookingRequestUncheckedCreateWithoutClassInput> | BookingRequestCreateWithoutClassInput[] | BookingRequestUncheckedCreateWithoutClassInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutClassInput | BookingRequestCreateOrConnectWithoutClassInput[]
    createMany?: BookingRequestCreateManyClassInputEnvelope
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
  }

  export type ClassCallUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassCallCreateWithoutClassInput, ClassCallUncheckedCreateWithoutClassInput> | ClassCallCreateWithoutClassInput[] | ClassCallUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassCallCreateOrConnectWithoutClassInput | ClassCallCreateOrConnectWithoutClassInput[]
    createMany?: ClassCallCreateManyClassInputEnvelope
    connect?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
  }

  export type ClassTaskUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassTaskCreateWithoutClassInput, ClassTaskUncheckedCreateWithoutClassInput> | ClassTaskCreateWithoutClassInput[] | ClassTaskUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassTaskCreateOrConnectWithoutClassInput | ClassTaskCreateOrConnectWithoutClassInput[]
    createMany?: ClassTaskCreateManyClassInputEnvelope
    connect?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
  }

  export type ClassSizeUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<ClassSizeCreateWithoutClassesInput, ClassSizeUncheckedCreateWithoutClassesInput>
    connectOrCreate?: ClassSizeCreateOrConnectWithoutClassesInput
    upsert?: ClassSizeUpsertWithoutClassesInput
    connect?: ClassSizeWhereUniqueInput
    update?: XOR<XOR<ClassSizeUpdateToOneWithWhereWithoutClassesInput, ClassSizeUpdateWithoutClassesInput>, ClassSizeUncheckedUpdateWithoutClassesInput>
  }

  export type CourseUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<CourseCreateWithoutClassesInput, CourseUncheckedCreateWithoutClassesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutClassesInput
    upsert?: CourseUpsertWithoutClassesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutClassesInput, CourseUpdateWithoutClassesInput>, CourseUncheckedUpdateWithoutClassesInput>
  }

  export type TimeOfDayUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<TimeOfDayCreateWithoutClassesInput, TimeOfDayUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TimeOfDayCreateOrConnectWithoutClassesInput
    upsert?: TimeOfDayUpsertWithoutClassesInput
    connect?: TimeOfDayWhereUniqueInput
    update?: XOR<XOR<TimeOfDayUpdateToOneWithWhereWithoutClassesInput, TimeOfDayUpdateWithoutClassesInput>, TimeOfDayUncheckedUpdateWithoutClassesInput>
  }

  export type TuitionLangUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<TuitionLangCreateWithoutClassesInput, TuitionLangUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TuitionLangCreateOrConnectWithoutClassesInput
    upsert?: TuitionLangUpsertWithoutClassesInput
    connect?: TuitionLangWhereUniqueInput
    update?: XOR<XOR<TuitionLangUpdateToOneWithWhereWithoutClassesInput, TuitionLangUpdateWithoutClassesInput>, TuitionLangUncheckedUpdateWithoutClassesInput>
  }

  export type MentorsClassesUpdateManyWithoutClassNestedInput = {
    create?: XOR<MentorsClassesCreateWithoutClassInput, MentorsClassesUncheckedCreateWithoutClassInput> | MentorsClassesCreateWithoutClassInput[] | MentorsClassesUncheckedCreateWithoutClassInput[]
    connectOrCreate?: MentorsClassesCreateOrConnectWithoutClassInput | MentorsClassesCreateOrConnectWithoutClassInput[]
    upsert?: MentorsClassesUpsertWithWhereUniqueWithoutClassInput | MentorsClassesUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: MentorsClassesCreateManyClassInputEnvelope
    set?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
    disconnect?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
    delete?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
    connect?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
    update?: MentorsClassesUpdateWithWhereUniqueWithoutClassInput | MentorsClassesUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: MentorsClassesUpdateManyWithWhereWithoutClassInput | MentorsClassesUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: MentorsClassesScalarWhereInput | MentorsClassesScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassInput | StudentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassInput | StudentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassInput | StudentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type BookingRequestUpdateManyWithoutClassNestedInput = {
    create?: XOR<BookingRequestCreateWithoutClassInput, BookingRequestUncheckedCreateWithoutClassInput> | BookingRequestCreateWithoutClassInput[] | BookingRequestUncheckedCreateWithoutClassInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutClassInput | BookingRequestCreateOrConnectWithoutClassInput[]
    upsert?: BookingRequestUpsertWithWhereUniqueWithoutClassInput | BookingRequestUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: BookingRequestCreateManyClassInputEnvelope
    set?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    disconnect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    delete?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    update?: BookingRequestUpdateWithWhereUniqueWithoutClassInput | BookingRequestUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: BookingRequestUpdateManyWithWhereWithoutClassInput | BookingRequestUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: BookingRequestScalarWhereInput | BookingRequestScalarWhereInput[]
  }

  export type ClassCallUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassCallCreateWithoutClassInput, ClassCallUncheckedCreateWithoutClassInput> | ClassCallCreateWithoutClassInput[] | ClassCallUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassCallCreateOrConnectWithoutClassInput | ClassCallCreateOrConnectWithoutClassInput[]
    upsert?: ClassCallUpsertWithWhereUniqueWithoutClassInput | ClassCallUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassCallCreateManyClassInputEnvelope
    set?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
    disconnect?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
    delete?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
    connect?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
    update?: ClassCallUpdateWithWhereUniqueWithoutClassInput | ClassCallUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassCallUpdateManyWithWhereWithoutClassInput | ClassCallUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassCallScalarWhereInput | ClassCallScalarWhereInput[]
  }

  export type ClassTaskUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassTaskCreateWithoutClassInput, ClassTaskUncheckedCreateWithoutClassInput> | ClassTaskCreateWithoutClassInput[] | ClassTaskUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassTaskCreateOrConnectWithoutClassInput | ClassTaskCreateOrConnectWithoutClassInput[]
    upsert?: ClassTaskUpsertWithWhereUniqueWithoutClassInput | ClassTaskUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassTaskCreateManyClassInputEnvelope
    set?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
    disconnect?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
    delete?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
    connect?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
    update?: ClassTaskUpdateWithWhereUniqueWithoutClassInput | ClassTaskUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassTaskUpdateManyWithWhereWithoutClassInput | ClassTaskUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassTaskScalarWhereInput | ClassTaskScalarWhereInput[]
  }

  export type MentorsClassesUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<MentorsClassesCreateWithoutClassInput, MentorsClassesUncheckedCreateWithoutClassInput> | MentorsClassesCreateWithoutClassInput[] | MentorsClassesUncheckedCreateWithoutClassInput[]
    connectOrCreate?: MentorsClassesCreateOrConnectWithoutClassInput | MentorsClassesCreateOrConnectWithoutClassInput[]
    upsert?: MentorsClassesUpsertWithWhereUniqueWithoutClassInput | MentorsClassesUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: MentorsClassesCreateManyClassInputEnvelope
    set?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
    disconnect?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
    delete?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
    connect?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
    update?: MentorsClassesUpdateWithWhereUniqueWithoutClassInput | MentorsClassesUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: MentorsClassesUpdateManyWithWhereWithoutClassInput | MentorsClassesUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: MentorsClassesScalarWhereInput | MentorsClassesScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassInput | StudentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassInput | StudentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassInput | StudentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type BookingRequestUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<BookingRequestCreateWithoutClassInput, BookingRequestUncheckedCreateWithoutClassInput> | BookingRequestCreateWithoutClassInput[] | BookingRequestUncheckedCreateWithoutClassInput[]
    connectOrCreate?: BookingRequestCreateOrConnectWithoutClassInput | BookingRequestCreateOrConnectWithoutClassInput[]
    upsert?: BookingRequestUpsertWithWhereUniqueWithoutClassInput | BookingRequestUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: BookingRequestCreateManyClassInputEnvelope
    set?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    disconnect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    delete?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    connect?: BookingRequestWhereUniqueInput | BookingRequestWhereUniqueInput[]
    update?: BookingRequestUpdateWithWhereUniqueWithoutClassInput | BookingRequestUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: BookingRequestUpdateManyWithWhereWithoutClassInput | BookingRequestUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: BookingRequestScalarWhereInput | BookingRequestScalarWhereInput[]
  }

  export type ClassCallUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassCallCreateWithoutClassInput, ClassCallUncheckedCreateWithoutClassInput> | ClassCallCreateWithoutClassInput[] | ClassCallUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassCallCreateOrConnectWithoutClassInput | ClassCallCreateOrConnectWithoutClassInput[]
    upsert?: ClassCallUpsertWithWhereUniqueWithoutClassInput | ClassCallUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassCallCreateManyClassInputEnvelope
    set?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
    disconnect?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
    delete?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
    connect?: ClassCallWhereUniqueInput | ClassCallWhereUniqueInput[]
    update?: ClassCallUpdateWithWhereUniqueWithoutClassInput | ClassCallUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassCallUpdateManyWithWhereWithoutClassInput | ClassCallUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassCallScalarWhereInput | ClassCallScalarWhereInput[]
  }

  export type ClassTaskUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassTaskCreateWithoutClassInput, ClassTaskUncheckedCreateWithoutClassInput> | ClassTaskCreateWithoutClassInput[] | ClassTaskUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassTaskCreateOrConnectWithoutClassInput | ClassTaskCreateOrConnectWithoutClassInput[]
    upsert?: ClassTaskUpsertWithWhereUniqueWithoutClassInput | ClassTaskUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassTaskCreateManyClassInputEnvelope
    set?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
    disconnect?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
    delete?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
    connect?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
    update?: ClassTaskUpdateWithWhereUniqueWithoutClassInput | ClassTaskUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassTaskUpdateManyWithWhereWithoutClassInput | ClassTaskUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassTaskScalarWhereInput | ClassTaskScalarWhereInput[]
  }

  export type ClassCreateNestedOneWithoutClass_callsInput = {
    create?: XOR<ClassCreateWithoutClass_callsInput, ClassUncheckedCreateWithoutClass_callsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutClass_callsInput
    connect?: ClassWhereUniqueInput
  }

  export type MeetingKindCreateNestedOneWithoutClass_callsInput = {
    create?: XOR<MeetingKindCreateWithoutClass_callsInput, MeetingKindUncheckedCreateWithoutClass_callsInput>
    connectOrCreate?: MeetingKindCreateOrConnectWithoutClass_callsInput
    connect?: MeetingKindWhereUniqueInput
  }

  export type ClassUpdateOneRequiredWithoutClass_callsNestedInput = {
    create?: XOR<ClassCreateWithoutClass_callsInput, ClassUncheckedCreateWithoutClass_callsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutClass_callsInput
    upsert?: ClassUpsertWithoutClass_callsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutClass_callsInput, ClassUpdateWithoutClass_callsInput>, ClassUncheckedUpdateWithoutClass_callsInput>
  }

  export type MeetingKindUpdateOneRequiredWithoutClass_callsNestedInput = {
    create?: XOR<MeetingKindCreateWithoutClass_callsInput, MeetingKindUncheckedCreateWithoutClass_callsInput>
    connectOrCreate?: MeetingKindCreateOrConnectWithoutClass_callsInput
    upsert?: MeetingKindUpsertWithoutClass_callsInput
    connect?: MeetingKindWhereUniqueInput
    update?: XOR<XOR<MeetingKindUpdateToOneWithWhereWithoutClass_callsInput, MeetingKindUpdateWithoutClass_callsInput>, MeetingKindUncheckedUpdateWithoutClass_callsInput>
  }

  export type ClassCreateNestedManyWithoutClass_size_idInput = {
    create?: XOR<ClassCreateWithoutClass_size_idInput, ClassUncheckedCreateWithoutClass_size_idInput> | ClassCreateWithoutClass_size_idInput[] | ClassUncheckedCreateWithoutClass_size_idInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutClass_size_idInput | ClassCreateOrConnectWithoutClass_size_idInput[]
    createMany?: ClassCreateManyClass_size_idInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type MentorPayModelCreateNestedManyWithoutClass_sizeInput = {
    create?: XOR<MentorPayModelCreateWithoutClass_sizeInput, MentorPayModelUncheckedCreateWithoutClass_sizeInput> | MentorPayModelCreateWithoutClass_sizeInput[] | MentorPayModelUncheckedCreateWithoutClass_sizeInput[]
    connectOrCreate?: MentorPayModelCreateOrConnectWithoutClass_sizeInput | MentorPayModelCreateOrConnectWithoutClass_sizeInput[]
    createMany?: MentorPayModelCreateManyClass_sizeInputEnvelope
    connect?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutClass_size_idInput = {
    create?: XOR<ClassCreateWithoutClass_size_idInput, ClassUncheckedCreateWithoutClass_size_idInput> | ClassCreateWithoutClass_size_idInput[] | ClassUncheckedCreateWithoutClass_size_idInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutClass_size_idInput | ClassCreateOrConnectWithoutClass_size_idInput[]
    createMany?: ClassCreateManyClass_size_idInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type MentorPayModelUncheckedCreateNestedManyWithoutClass_sizeInput = {
    create?: XOR<MentorPayModelCreateWithoutClass_sizeInput, MentorPayModelUncheckedCreateWithoutClass_sizeInput> | MentorPayModelCreateWithoutClass_sizeInput[] | MentorPayModelUncheckedCreateWithoutClass_sizeInput[]
    connectOrCreate?: MentorPayModelCreateOrConnectWithoutClass_sizeInput | MentorPayModelCreateOrConnectWithoutClass_sizeInput[]
    createMany?: MentorPayModelCreateManyClass_sizeInputEnvelope
    connect?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
  }

  export type EnumClassSizesEnumFieldUpdateOperationsInput = {
    set?: $Enums.ClassSizesEnum
  }

  export type ClassUpdateManyWithoutClass_size_idNestedInput = {
    create?: XOR<ClassCreateWithoutClass_size_idInput, ClassUncheckedCreateWithoutClass_size_idInput> | ClassCreateWithoutClass_size_idInput[] | ClassUncheckedCreateWithoutClass_size_idInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutClass_size_idInput | ClassCreateOrConnectWithoutClass_size_idInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutClass_size_idInput | ClassUpsertWithWhereUniqueWithoutClass_size_idInput[]
    createMany?: ClassCreateManyClass_size_idInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutClass_size_idInput | ClassUpdateWithWhereUniqueWithoutClass_size_idInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutClass_size_idInput | ClassUpdateManyWithWhereWithoutClass_size_idInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type MentorPayModelUpdateManyWithoutClass_sizeNestedInput = {
    create?: XOR<MentorPayModelCreateWithoutClass_sizeInput, MentorPayModelUncheckedCreateWithoutClass_sizeInput> | MentorPayModelCreateWithoutClass_sizeInput[] | MentorPayModelUncheckedCreateWithoutClass_sizeInput[]
    connectOrCreate?: MentorPayModelCreateOrConnectWithoutClass_sizeInput | MentorPayModelCreateOrConnectWithoutClass_sizeInput[]
    upsert?: MentorPayModelUpsertWithWhereUniqueWithoutClass_sizeInput | MentorPayModelUpsertWithWhereUniqueWithoutClass_sizeInput[]
    createMany?: MentorPayModelCreateManyClass_sizeInputEnvelope
    set?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
    disconnect?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
    delete?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
    connect?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
    update?: MentorPayModelUpdateWithWhereUniqueWithoutClass_sizeInput | MentorPayModelUpdateWithWhereUniqueWithoutClass_sizeInput[]
    updateMany?: MentorPayModelUpdateManyWithWhereWithoutClass_sizeInput | MentorPayModelUpdateManyWithWhereWithoutClass_sizeInput[]
    deleteMany?: MentorPayModelScalarWhereInput | MentorPayModelScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutClass_size_idNestedInput = {
    create?: XOR<ClassCreateWithoutClass_size_idInput, ClassUncheckedCreateWithoutClass_size_idInput> | ClassCreateWithoutClass_size_idInput[] | ClassUncheckedCreateWithoutClass_size_idInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutClass_size_idInput | ClassCreateOrConnectWithoutClass_size_idInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutClass_size_idInput | ClassUpsertWithWhereUniqueWithoutClass_size_idInput[]
    createMany?: ClassCreateManyClass_size_idInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutClass_size_idInput | ClassUpdateWithWhereUniqueWithoutClass_size_idInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutClass_size_idInput | ClassUpdateManyWithWhereWithoutClass_size_idInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type MentorPayModelUncheckedUpdateManyWithoutClass_sizeNestedInput = {
    create?: XOR<MentorPayModelCreateWithoutClass_sizeInput, MentorPayModelUncheckedCreateWithoutClass_sizeInput> | MentorPayModelCreateWithoutClass_sizeInput[] | MentorPayModelUncheckedCreateWithoutClass_sizeInput[]
    connectOrCreate?: MentorPayModelCreateOrConnectWithoutClass_sizeInput | MentorPayModelCreateOrConnectWithoutClass_sizeInput[]
    upsert?: MentorPayModelUpsertWithWhereUniqueWithoutClass_sizeInput | MentorPayModelUpsertWithWhereUniqueWithoutClass_sizeInput[]
    createMany?: MentorPayModelCreateManyClass_sizeInputEnvelope
    set?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
    disconnect?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
    delete?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
    connect?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
    update?: MentorPayModelUpdateWithWhereUniqueWithoutClass_sizeInput | MentorPayModelUpdateWithWhereUniqueWithoutClass_sizeInput[]
    updateMany?: MentorPayModelUpdateManyWithWhereWithoutClass_sizeInput | MentorPayModelUpdateManyWithWhereWithoutClass_sizeInput[]
    deleteMany?: MentorPayModelScalarWhereInput | MentorPayModelScalarWhereInput[]
  }

  export type CourseLevelCreateNestedOneWithoutCourseInput = {
    create?: XOR<CourseLevelCreateWithoutCourseInput, CourseLevelUncheckedCreateWithoutCourseInput>
    connectOrCreate?: CourseLevelCreateOrConnectWithoutCourseInput
    connect?: CourseLevelWhereUniqueInput
  }

  export type CourseAdviceCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseAdviceCreateWithoutCourseInput, CourseAdviceUncheckedCreateWithoutCourseInput> | CourseAdviceCreateWithoutCourseInput[] | CourseAdviceUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseAdviceCreateOrConnectWithoutCourseInput | CourseAdviceCreateOrConnectWithoutCourseInput[]
    createMany?: CourseAdviceCreateManyCourseInputEnvelope
    connect?: CourseAdviceWhereUniqueInput | CourseAdviceWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutIs_instance_of_courseInput = {
    create?: XOR<ClassCreateWithoutIs_instance_of_courseInput, ClassUncheckedCreateWithoutIs_instance_of_courseInput> | ClassCreateWithoutIs_instance_of_courseInput[] | ClassUncheckedCreateWithoutIs_instance_of_courseInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutIs_instance_of_courseInput | ClassCreateOrConnectWithoutIs_instance_of_courseInput[]
    createMany?: ClassCreateManyIs_instance_of_courseInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type SubjectCreateNestedOneWithoutCourseInput = {
    create?: XOR<SubjectCreateWithoutCourseInput, SubjectUncheckedCreateWithoutCourseInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutCourseInput
    connect?: SubjectWhereUniqueInput
  }

  export type CourseStructureCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseStructureCreateWithoutCourseInput, CourseStructureUncheckedCreateWithoutCourseInput> | CourseStructureCreateWithoutCourseInput[] | CourseStructureUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseStructureCreateOrConnectWithoutCourseInput | CourseStructureCreateOrConnectWithoutCourseInput[]
    createMany?: CourseStructureCreateManyCourseInputEnvelope
    connect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
  }

  export type CourseTaskCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseTaskCreateWithoutCourseInput, CourseTaskUncheckedCreateWithoutCourseInput> | CourseTaskCreateWithoutCourseInput[] | CourseTaskUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutCourseInput | CourseTaskCreateOrConnectWithoutCourseInput[]
    createMany?: CourseTaskCreateManyCourseInputEnvelope
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
  }

  export type ModuleCreateNestedManyWithoutCourseInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type LessonCardCreateNestedManyWithoutCourseInput = {
    create?: XOR<LessonCardCreateWithoutCourseInput, LessonCardUncheckedCreateWithoutCourseInput> | LessonCardCreateWithoutCourseInput[] | LessonCardUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonCardCreateOrConnectWithoutCourseInput | LessonCardCreateOrConnectWithoutCourseInput[]
    createMany?: LessonCardCreateManyCourseInputEnvelope
    connect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
  }

  export type CourseAdviceUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseAdviceCreateWithoutCourseInput, CourseAdviceUncheckedCreateWithoutCourseInput> | CourseAdviceCreateWithoutCourseInput[] | CourseAdviceUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseAdviceCreateOrConnectWithoutCourseInput | CourseAdviceCreateOrConnectWithoutCourseInput[]
    createMany?: CourseAdviceCreateManyCourseInputEnvelope
    connect?: CourseAdviceWhereUniqueInput | CourseAdviceWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutIs_instance_of_courseInput = {
    create?: XOR<ClassCreateWithoutIs_instance_of_courseInput, ClassUncheckedCreateWithoutIs_instance_of_courseInput> | ClassCreateWithoutIs_instance_of_courseInput[] | ClassUncheckedCreateWithoutIs_instance_of_courseInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutIs_instance_of_courseInput | ClassCreateOrConnectWithoutIs_instance_of_courseInput[]
    createMany?: ClassCreateManyIs_instance_of_courseInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type CourseStructureUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseStructureCreateWithoutCourseInput, CourseStructureUncheckedCreateWithoutCourseInput> | CourseStructureCreateWithoutCourseInput[] | CourseStructureUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseStructureCreateOrConnectWithoutCourseInput | CourseStructureCreateOrConnectWithoutCourseInput[]
    createMany?: CourseStructureCreateManyCourseInputEnvelope
    connect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
  }

  export type CourseTaskUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseTaskCreateWithoutCourseInput, CourseTaskUncheckedCreateWithoutCourseInput> | CourseTaskCreateWithoutCourseInput[] | CourseTaskUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutCourseInput | CourseTaskCreateOrConnectWithoutCourseInput[]
    createMany?: CourseTaskCreateManyCourseInputEnvelope
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
  }

  export type ModuleUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type LessonCardUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<LessonCardCreateWithoutCourseInput, LessonCardUncheckedCreateWithoutCourseInput> | LessonCardCreateWithoutCourseInput[] | LessonCardUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonCardCreateOrConnectWithoutCourseInput | LessonCardCreateOrConnectWithoutCourseInput[]
    createMany?: LessonCardCreateManyCourseInputEnvelope
    connect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
  }

  export type CourseLevelUpdateOneRequiredWithoutCourseNestedInput = {
    create?: XOR<CourseLevelCreateWithoutCourseInput, CourseLevelUncheckedCreateWithoutCourseInput>
    connectOrCreate?: CourseLevelCreateOrConnectWithoutCourseInput
    upsert?: CourseLevelUpsertWithoutCourseInput
    connect?: CourseLevelWhereUniqueInput
    update?: XOR<XOR<CourseLevelUpdateToOneWithWhereWithoutCourseInput, CourseLevelUpdateWithoutCourseInput>, CourseLevelUncheckedUpdateWithoutCourseInput>
  }

  export type CourseAdviceUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseAdviceCreateWithoutCourseInput, CourseAdviceUncheckedCreateWithoutCourseInput> | CourseAdviceCreateWithoutCourseInput[] | CourseAdviceUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseAdviceCreateOrConnectWithoutCourseInput | CourseAdviceCreateOrConnectWithoutCourseInput[]
    upsert?: CourseAdviceUpsertWithWhereUniqueWithoutCourseInput | CourseAdviceUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseAdviceCreateManyCourseInputEnvelope
    set?: CourseAdviceWhereUniqueInput | CourseAdviceWhereUniqueInput[]
    disconnect?: CourseAdviceWhereUniqueInput | CourseAdviceWhereUniqueInput[]
    delete?: CourseAdviceWhereUniqueInput | CourseAdviceWhereUniqueInput[]
    connect?: CourseAdviceWhereUniqueInput | CourseAdviceWhereUniqueInput[]
    update?: CourseAdviceUpdateWithWhereUniqueWithoutCourseInput | CourseAdviceUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseAdviceUpdateManyWithWhereWithoutCourseInput | CourseAdviceUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseAdviceScalarWhereInput | CourseAdviceScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutIs_instance_of_courseNestedInput = {
    create?: XOR<ClassCreateWithoutIs_instance_of_courseInput, ClassUncheckedCreateWithoutIs_instance_of_courseInput> | ClassCreateWithoutIs_instance_of_courseInput[] | ClassUncheckedCreateWithoutIs_instance_of_courseInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutIs_instance_of_courseInput | ClassCreateOrConnectWithoutIs_instance_of_courseInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutIs_instance_of_courseInput | ClassUpsertWithWhereUniqueWithoutIs_instance_of_courseInput[]
    createMany?: ClassCreateManyIs_instance_of_courseInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutIs_instance_of_courseInput | ClassUpdateWithWhereUniqueWithoutIs_instance_of_courseInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutIs_instance_of_courseInput | ClassUpdateManyWithWhereWithoutIs_instance_of_courseInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type SubjectUpdateOneWithoutCourseNestedInput = {
    create?: XOR<SubjectCreateWithoutCourseInput, SubjectUncheckedCreateWithoutCourseInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutCourseInput
    upsert?: SubjectUpsertWithoutCourseInput
    disconnect?: SubjectWhereInput | boolean
    delete?: SubjectWhereInput | boolean
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutCourseInput, SubjectUpdateWithoutCourseInput>, SubjectUncheckedUpdateWithoutCourseInput>
  }

  export type CourseStructureUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseStructureCreateWithoutCourseInput, CourseStructureUncheckedCreateWithoutCourseInput> | CourseStructureCreateWithoutCourseInput[] | CourseStructureUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseStructureCreateOrConnectWithoutCourseInput | CourseStructureCreateOrConnectWithoutCourseInput[]
    upsert?: CourseStructureUpsertWithWhereUniqueWithoutCourseInput | CourseStructureUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseStructureCreateManyCourseInputEnvelope
    set?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    disconnect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    delete?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    connect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    update?: CourseStructureUpdateWithWhereUniqueWithoutCourseInput | CourseStructureUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseStructureUpdateManyWithWhereWithoutCourseInput | CourseStructureUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseStructureScalarWhereInput | CourseStructureScalarWhereInput[]
  }

  export type CourseTaskUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseTaskCreateWithoutCourseInput, CourseTaskUncheckedCreateWithoutCourseInput> | CourseTaskCreateWithoutCourseInput[] | CourseTaskUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutCourseInput | CourseTaskCreateOrConnectWithoutCourseInput[]
    upsert?: CourseTaskUpsertWithWhereUniqueWithoutCourseInput | CourseTaskUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseTaskCreateManyCourseInputEnvelope
    set?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    disconnect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    delete?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    update?: CourseTaskUpdateWithWhereUniqueWithoutCourseInput | CourseTaskUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseTaskUpdateManyWithWhereWithoutCourseInput | CourseTaskUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseTaskScalarWhereInput | CourseTaskScalarWhereInput[]
  }

  export type ModuleUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutCourseInput | ModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutCourseInput | ModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutCourseInput | ModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type LessonCardUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LessonCardCreateWithoutCourseInput, LessonCardUncheckedCreateWithoutCourseInput> | LessonCardCreateWithoutCourseInput[] | LessonCardUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonCardCreateOrConnectWithoutCourseInput | LessonCardCreateOrConnectWithoutCourseInput[]
    upsert?: LessonCardUpsertWithWhereUniqueWithoutCourseInput | LessonCardUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LessonCardCreateManyCourseInputEnvelope
    set?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    disconnect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    delete?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    connect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    update?: LessonCardUpdateWithWhereUniqueWithoutCourseInput | LessonCardUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LessonCardUpdateManyWithWhereWithoutCourseInput | LessonCardUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LessonCardScalarWhereInput | LessonCardScalarWhereInput[]
  }

  export type CourseAdviceUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseAdviceCreateWithoutCourseInput, CourseAdviceUncheckedCreateWithoutCourseInput> | CourseAdviceCreateWithoutCourseInput[] | CourseAdviceUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseAdviceCreateOrConnectWithoutCourseInput | CourseAdviceCreateOrConnectWithoutCourseInput[]
    upsert?: CourseAdviceUpsertWithWhereUniqueWithoutCourseInput | CourseAdviceUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseAdviceCreateManyCourseInputEnvelope
    set?: CourseAdviceWhereUniqueInput | CourseAdviceWhereUniqueInput[]
    disconnect?: CourseAdviceWhereUniqueInput | CourseAdviceWhereUniqueInput[]
    delete?: CourseAdviceWhereUniqueInput | CourseAdviceWhereUniqueInput[]
    connect?: CourseAdviceWhereUniqueInput | CourseAdviceWhereUniqueInput[]
    update?: CourseAdviceUpdateWithWhereUniqueWithoutCourseInput | CourseAdviceUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseAdviceUpdateManyWithWhereWithoutCourseInput | CourseAdviceUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseAdviceScalarWhereInput | CourseAdviceScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutIs_instance_of_courseNestedInput = {
    create?: XOR<ClassCreateWithoutIs_instance_of_courseInput, ClassUncheckedCreateWithoutIs_instance_of_courseInput> | ClassCreateWithoutIs_instance_of_courseInput[] | ClassUncheckedCreateWithoutIs_instance_of_courseInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutIs_instance_of_courseInput | ClassCreateOrConnectWithoutIs_instance_of_courseInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutIs_instance_of_courseInput | ClassUpsertWithWhereUniqueWithoutIs_instance_of_courseInput[]
    createMany?: ClassCreateManyIs_instance_of_courseInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutIs_instance_of_courseInput | ClassUpdateWithWhereUniqueWithoutIs_instance_of_courseInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutIs_instance_of_courseInput | ClassUpdateManyWithWhereWithoutIs_instance_of_courseInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type CourseStructureUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseStructureCreateWithoutCourseInput, CourseStructureUncheckedCreateWithoutCourseInput> | CourseStructureCreateWithoutCourseInput[] | CourseStructureUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseStructureCreateOrConnectWithoutCourseInput | CourseStructureCreateOrConnectWithoutCourseInput[]
    upsert?: CourseStructureUpsertWithWhereUniqueWithoutCourseInput | CourseStructureUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseStructureCreateManyCourseInputEnvelope
    set?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    disconnect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    delete?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    connect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    update?: CourseStructureUpdateWithWhereUniqueWithoutCourseInput | CourseStructureUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseStructureUpdateManyWithWhereWithoutCourseInput | CourseStructureUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseStructureScalarWhereInput | CourseStructureScalarWhereInput[]
  }

  export type CourseTaskUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseTaskCreateWithoutCourseInput, CourseTaskUncheckedCreateWithoutCourseInput> | CourseTaskCreateWithoutCourseInput[] | CourseTaskUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutCourseInput | CourseTaskCreateOrConnectWithoutCourseInput[]
    upsert?: CourseTaskUpsertWithWhereUniqueWithoutCourseInput | CourseTaskUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseTaskCreateManyCourseInputEnvelope
    set?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    disconnect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    delete?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    update?: CourseTaskUpdateWithWhereUniqueWithoutCourseInput | CourseTaskUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseTaskUpdateManyWithWhereWithoutCourseInput | CourseTaskUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseTaskScalarWhereInput | CourseTaskScalarWhereInput[]
  }

  export type ModuleUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput> | ModuleCreateWithoutCourseInput[] | ModuleUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseInput | ModuleCreateOrConnectWithoutCourseInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutCourseInput | ModuleUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ModuleCreateManyCourseInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutCourseInput | ModuleUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutCourseInput | ModuleUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type LessonCardUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LessonCardCreateWithoutCourseInput, LessonCardUncheckedCreateWithoutCourseInput> | LessonCardCreateWithoutCourseInput[] | LessonCardUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LessonCardCreateOrConnectWithoutCourseInput | LessonCardCreateOrConnectWithoutCourseInput[]
    upsert?: LessonCardUpsertWithWhereUniqueWithoutCourseInput | LessonCardUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LessonCardCreateManyCourseInputEnvelope
    set?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    disconnect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    delete?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    connect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    update?: LessonCardUpdateWithWhereUniqueWithoutCourseInput | LessonCardUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LessonCardUpdateManyWithWhereWithoutCourseInput | LessonCardUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LessonCardScalarWhereInput | LessonCardScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutCourse_adviceInput = {
    create?: XOR<CourseCreateWithoutCourse_adviceInput, CourseUncheckedCreateWithoutCourse_adviceInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourse_adviceInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutCourse_adviceNestedInput = {
    create?: XOR<CourseCreateWithoutCourse_adviceInput, CourseUncheckedCreateWithoutCourse_adviceInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourse_adviceInput
    upsert?: CourseUpsertWithoutCourse_adviceInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCourse_adviceInput, CourseUpdateWithoutCourse_adviceInput>, CourseUncheckedUpdateWithoutCourse_adviceInput>
  }

  export type CourseCreateNestedOneWithoutCourseTaskInput = {
    create?: XOR<CourseCreateWithoutCourseTaskInput, CourseUncheckedCreateWithoutCourseTaskInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseTaskInput
    connect?: CourseWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutCourseTaskInput = {
    create?: XOR<ModuleCreateWithoutCourseTaskInput, ModuleUncheckedCreateWithoutCourseTaskInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseTaskInput
    connect?: ModuleWhereUniqueInput
  }

  export type SectionCreateNestedOneWithoutCourseTaskInput = {
    create?: XOR<SectionCreateWithoutCourseTaskInput, SectionUncheckedCreateWithoutCourseTaskInput>
    connectOrCreate?: SectionCreateOrConnectWithoutCourseTaskInput
    connect?: SectionWhereUniqueInput
  }

  export type LessonCreateNestedOneWithoutCourseTaskInput = {
    create?: XOR<LessonCreateWithoutCourseTaskInput, LessonUncheckedCreateWithoutCourseTaskInput>
    connectOrCreate?: LessonCreateOrConnectWithoutCourseTaskInput
    connect?: LessonWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutCourseTaskInput = {
    create?: XOR<TaskCreateWithoutCourseTaskInput, TaskUncheckedCreateWithoutCourseTaskInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCourseTaskInput
    connect?: TaskWhereUniqueInput
  }

  export type ClassTaskCreateNestedManyWithoutCourse_taskInput = {
    create?: XOR<ClassTaskCreateWithoutCourse_taskInput, ClassTaskUncheckedCreateWithoutCourse_taskInput> | ClassTaskCreateWithoutCourse_taskInput[] | ClassTaskUncheckedCreateWithoutCourse_taskInput[]
    connectOrCreate?: ClassTaskCreateOrConnectWithoutCourse_taskInput | ClassTaskCreateOrConnectWithoutCourse_taskInput[]
    createMany?: ClassTaskCreateManyCourse_taskInputEnvelope
    connect?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
  }

  export type ClassTaskUncheckedCreateNestedManyWithoutCourse_taskInput = {
    create?: XOR<ClassTaskCreateWithoutCourse_taskInput, ClassTaskUncheckedCreateWithoutCourse_taskInput> | ClassTaskCreateWithoutCourse_taskInput[] | ClassTaskUncheckedCreateWithoutCourse_taskInput[]
    connectOrCreate?: ClassTaskCreateOrConnectWithoutCourse_taskInput | ClassTaskCreateOrConnectWithoutCourse_taskInput[]
    createMany?: ClassTaskCreateManyCourse_taskInputEnvelope
    connect?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutCourseTaskNestedInput = {
    create?: XOR<CourseCreateWithoutCourseTaskInput, CourseUncheckedCreateWithoutCourseTaskInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseTaskInput
    upsert?: CourseUpsertWithoutCourseTaskInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCourseTaskInput, CourseUpdateWithoutCourseTaskInput>, CourseUncheckedUpdateWithoutCourseTaskInput>
  }

  export type ModuleUpdateOneRequiredWithoutCourseTaskNestedInput = {
    create?: XOR<ModuleCreateWithoutCourseTaskInput, ModuleUncheckedCreateWithoutCourseTaskInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutCourseTaskInput
    upsert?: ModuleUpsertWithoutCourseTaskInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutCourseTaskInput, ModuleUpdateWithoutCourseTaskInput>, ModuleUncheckedUpdateWithoutCourseTaskInput>
  }

  export type SectionUpdateOneRequiredWithoutCourseTaskNestedInput = {
    create?: XOR<SectionCreateWithoutCourseTaskInput, SectionUncheckedCreateWithoutCourseTaskInput>
    connectOrCreate?: SectionCreateOrConnectWithoutCourseTaskInput
    upsert?: SectionUpsertWithoutCourseTaskInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutCourseTaskInput, SectionUpdateWithoutCourseTaskInput>, SectionUncheckedUpdateWithoutCourseTaskInput>
  }

  export type LessonUpdateOneRequiredWithoutCourseTaskNestedInput = {
    create?: XOR<LessonCreateWithoutCourseTaskInput, LessonUncheckedCreateWithoutCourseTaskInput>
    connectOrCreate?: LessonCreateOrConnectWithoutCourseTaskInput
    upsert?: LessonUpsertWithoutCourseTaskInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutCourseTaskInput, LessonUpdateWithoutCourseTaskInput>, LessonUncheckedUpdateWithoutCourseTaskInput>
  }

  export type TaskUpdateOneRequiredWithoutCourseTaskNestedInput = {
    create?: XOR<TaskCreateWithoutCourseTaskInput, TaskUncheckedCreateWithoutCourseTaskInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCourseTaskInput
    upsert?: TaskUpsertWithoutCourseTaskInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutCourseTaskInput, TaskUpdateWithoutCourseTaskInput>, TaskUncheckedUpdateWithoutCourseTaskInput>
  }

  export type ClassTaskUpdateManyWithoutCourse_taskNestedInput = {
    create?: XOR<ClassTaskCreateWithoutCourse_taskInput, ClassTaskUncheckedCreateWithoutCourse_taskInput> | ClassTaskCreateWithoutCourse_taskInput[] | ClassTaskUncheckedCreateWithoutCourse_taskInput[]
    connectOrCreate?: ClassTaskCreateOrConnectWithoutCourse_taskInput | ClassTaskCreateOrConnectWithoutCourse_taskInput[]
    upsert?: ClassTaskUpsertWithWhereUniqueWithoutCourse_taskInput | ClassTaskUpsertWithWhereUniqueWithoutCourse_taskInput[]
    createMany?: ClassTaskCreateManyCourse_taskInputEnvelope
    set?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
    disconnect?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
    delete?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
    connect?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
    update?: ClassTaskUpdateWithWhereUniqueWithoutCourse_taskInput | ClassTaskUpdateWithWhereUniqueWithoutCourse_taskInput[]
    updateMany?: ClassTaskUpdateManyWithWhereWithoutCourse_taskInput | ClassTaskUpdateManyWithWhereWithoutCourse_taskInput[]
    deleteMany?: ClassTaskScalarWhereInput | ClassTaskScalarWhereInput[]
  }

  export type ClassTaskUncheckedUpdateManyWithoutCourse_taskNestedInput = {
    create?: XOR<ClassTaskCreateWithoutCourse_taskInput, ClassTaskUncheckedCreateWithoutCourse_taskInput> | ClassTaskCreateWithoutCourse_taskInput[] | ClassTaskUncheckedCreateWithoutCourse_taskInput[]
    connectOrCreate?: ClassTaskCreateOrConnectWithoutCourse_taskInput | ClassTaskCreateOrConnectWithoutCourse_taskInput[]
    upsert?: ClassTaskUpsertWithWhereUniqueWithoutCourse_taskInput | ClassTaskUpsertWithWhereUniqueWithoutCourse_taskInput[]
    createMany?: ClassTaskCreateManyCourse_taskInputEnvelope
    set?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
    disconnect?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
    delete?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
    connect?: ClassTaskWhereUniqueInput | ClassTaskWhereUniqueInput[]
    update?: ClassTaskUpdateWithWhereUniqueWithoutCourse_taskInput | ClassTaskUpdateWithWhereUniqueWithoutCourse_taskInput[]
    updateMany?: ClassTaskUpdateManyWithWhereWithoutCourse_taskInput | ClassTaskUpdateManyWithWhereWithoutCourse_taskInput[]
    deleteMany?: ClassTaskScalarWhereInput | ClassTaskScalarWhereInput[]
  }

  export type CourseCreateNestedManyWithoutCourse_levelInput = {
    create?: XOR<CourseCreateWithoutCourse_levelInput, CourseUncheckedCreateWithoutCourse_levelInput> | CourseCreateWithoutCourse_levelInput[] | CourseUncheckedCreateWithoutCourse_levelInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCourse_levelInput | CourseCreateOrConnectWithoutCourse_levelInput[]
    createMany?: CourseCreateManyCourse_levelInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type CourseLevelsPerSubjectCreateNestedManyWithoutCourse_levelInput = {
    create?: XOR<CourseLevelsPerSubjectCreateWithoutCourse_levelInput, CourseLevelsPerSubjectUncheckedCreateWithoutCourse_levelInput> | CourseLevelsPerSubjectCreateWithoutCourse_levelInput[] | CourseLevelsPerSubjectUncheckedCreateWithoutCourse_levelInput[]
    connectOrCreate?: CourseLevelsPerSubjectCreateOrConnectWithoutCourse_levelInput | CourseLevelsPerSubjectCreateOrConnectWithoutCourse_levelInput[]
    createMany?: CourseLevelsPerSubjectCreateManyCourse_levelInputEnvelope
    connect?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutCourse_levelInput = {
    create?: XOR<CourseCreateWithoutCourse_levelInput, CourseUncheckedCreateWithoutCourse_levelInput> | CourseCreateWithoutCourse_levelInput[] | CourseUncheckedCreateWithoutCourse_levelInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCourse_levelInput | CourseCreateOrConnectWithoutCourse_levelInput[]
    createMany?: CourseCreateManyCourse_levelInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type CourseLevelsPerSubjectUncheckedCreateNestedManyWithoutCourse_levelInput = {
    create?: XOR<CourseLevelsPerSubjectCreateWithoutCourse_levelInput, CourseLevelsPerSubjectUncheckedCreateWithoutCourse_levelInput> | CourseLevelsPerSubjectCreateWithoutCourse_levelInput[] | CourseLevelsPerSubjectUncheckedCreateWithoutCourse_levelInput[]
    connectOrCreate?: CourseLevelsPerSubjectCreateOrConnectWithoutCourse_levelInput | CourseLevelsPerSubjectCreateOrConnectWithoutCourse_levelInput[]
    createMany?: CourseLevelsPerSubjectCreateManyCourse_levelInputEnvelope
    connect?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
  }

  export type CourseUpdateManyWithoutCourse_levelNestedInput = {
    create?: XOR<CourseCreateWithoutCourse_levelInput, CourseUncheckedCreateWithoutCourse_levelInput> | CourseCreateWithoutCourse_levelInput[] | CourseUncheckedCreateWithoutCourse_levelInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCourse_levelInput | CourseCreateOrConnectWithoutCourse_levelInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCourse_levelInput | CourseUpsertWithWhereUniqueWithoutCourse_levelInput[]
    createMany?: CourseCreateManyCourse_levelInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCourse_levelInput | CourseUpdateWithWhereUniqueWithoutCourse_levelInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCourse_levelInput | CourseUpdateManyWithWhereWithoutCourse_levelInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type CourseLevelsPerSubjectUpdateManyWithoutCourse_levelNestedInput = {
    create?: XOR<CourseLevelsPerSubjectCreateWithoutCourse_levelInput, CourseLevelsPerSubjectUncheckedCreateWithoutCourse_levelInput> | CourseLevelsPerSubjectCreateWithoutCourse_levelInput[] | CourseLevelsPerSubjectUncheckedCreateWithoutCourse_levelInput[]
    connectOrCreate?: CourseLevelsPerSubjectCreateOrConnectWithoutCourse_levelInput | CourseLevelsPerSubjectCreateOrConnectWithoutCourse_levelInput[]
    upsert?: CourseLevelsPerSubjectUpsertWithWhereUniqueWithoutCourse_levelInput | CourseLevelsPerSubjectUpsertWithWhereUniqueWithoutCourse_levelInput[]
    createMany?: CourseLevelsPerSubjectCreateManyCourse_levelInputEnvelope
    set?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
    disconnect?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
    delete?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
    connect?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
    update?: CourseLevelsPerSubjectUpdateWithWhereUniqueWithoutCourse_levelInput | CourseLevelsPerSubjectUpdateWithWhereUniqueWithoutCourse_levelInput[]
    updateMany?: CourseLevelsPerSubjectUpdateManyWithWhereWithoutCourse_levelInput | CourseLevelsPerSubjectUpdateManyWithWhereWithoutCourse_levelInput[]
    deleteMany?: CourseLevelsPerSubjectScalarWhereInput | CourseLevelsPerSubjectScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutCourse_levelNestedInput = {
    create?: XOR<CourseCreateWithoutCourse_levelInput, CourseUncheckedCreateWithoutCourse_levelInput> | CourseCreateWithoutCourse_levelInput[] | CourseUncheckedCreateWithoutCourse_levelInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutCourse_levelInput | CourseCreateOrConnectWithoutCourse_levelInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutCourse_levelInput | CourseUpsertWithWhereUniqueWithoutCourse_levelInput[]
    createMany?: CourseCreateManyCourse_levelInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutCourse_levelInput | CourseUpdateWithWhereUniqueWithoutCourse_levelInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutCourse_levelInput | CourseUpdateManyWithWhereWithoutCourse_levelInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type CourseLevelsPerSubjectUncheckedUpdateManyWithoutCourse_levelNestedInput = {
    create?: XOR<CourseLevelsPerSubjectCreateWithoutCourse_levelInput, CourseLevelsPerSubjectUncheckedCreateWithoutCourse_levelInput> | CourseLevelsPerSubjectCreateWithoutCourse_levelInput[] | CourseLevelsPerSubjectUncheckedCreateWithoutCourse_levelInput[]
    connectOrCreate?: CourseLevelsPerSubjectCreateOrConnectWithoutCourse_levelInput | CourseLevelsPerSubjectCreateOrConnectWithoutCourse_levelInput[]
    upsert?: CourseLevelsPerSubjectUpsertWithWhereUniqueWithoutCourse_levelInput | CourseLevelsPerSubjectUpsertWithWhereUniqueWithoutCourse_levelInput[]
    createMany?: CourseLevelsPerSubjectCreateManyCourse_levelInputEnvelope
    set?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
    disconnect?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
    delete?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
    connect?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
    update?: CourseLevelsPerSubjectUpdateWithWhereUniqueWithoutCourse_levelInput | CourseLevelsPerSubjectUpdateWithWhereUniqueWithoutCourse_levelInput[]
    updateMany?: CourseLevelsPerSubjectUpdateManyWithWhereWithoutCourse_levelInput | CourseLevelsPerSubjectUpdateManyWithWhereWithoutCourse_levelInput[]
    deleteMany?: CourseLevelsPerSubjectScalarWhereInput | CourseLevelsPerSubjectScalarWhereInput[]
  }

  export type CourseCreateNestedManyWithoutSubjectInput = {
    create?: XOR<CourseCreateWithoutSubjectInput, CourseUncheckedCreateWithoutSubjectInput> | CourseCreateWithoutSubjectInput[] | CourseUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutSubjectInput | CourseCreateOrConnectWithoutSubjectInput[]
    createMany?: CourseCreateManySubjectInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type CourseLevelsPerSubjectCreateNestedManyWithoutSubjectInput = {
    create?: XOR<CourseLevelsPerSubjectCreateWithoutSubjectInput, CourseLevelsPerSubjectUncheckedCreateWithoutSubjectInput> | CourseLevelsPerSubjectCreateWithoutSubjectInput[] | CourseLevelsPerSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: CourseLevelsPerSubjectCreateOrConnectWithoutSubjectInput | CourseLevelsPerSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: CourseLevelsPerSubjectCreateManySubjectInputEnvelope
    connect?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<CourseCreateWithoutSubjectInput, CourseUncheckedCreateWithoutSubjectInput> | CourseCreateWithoutSubjectInput[] | CourseUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutSubjectInput | CourseCreateOrConnectWithoutSubjectInput[]
    createMany?: CourseCreateManySubjectInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type CourseLevelsPerSubjectUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<CourseLevelsPerSubjectCreateWithoutSubjectInput, CourseLevelsPerSubjectUncheckedCreateWithoutSubjectInput> | CourseLevelsPerSubjectCreateWithoutSubjectInput[] | CourseLevelsPerSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: CourseLevelsPerSubjectCreateOrConnectWithoutSubjectInput | CourseLevelsPerSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: CourseLevelsPerSubjectCreateManySubjectInputEnvelope
    connect?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
  }

  export type CourseUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<CourseCreateWithoutSubjectInput, CourseUncheckedCreateWithoutSubjectInput> | CourseCreateWithoutSubjectInput[] | CourseUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutSubjectInput | CourseCreateOrConnectWithoutSubjectInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutSubjectInput | CourseUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: CourseCreateManySubjectInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutSubjectInput | CourseUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutSubjectInput | CourseUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type CourseLevelsPerSubjectUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<CourseLevelsPerSubjectCreateWithoutSubjectInput, CourseLevelsPerSubjectUncheckedCreateWithoutSubjectInput> | CourseLevelsPerSubjectCreateWithoutSubjectInput[] | CourseLevelsPerSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: CourseLevelsPerSubjectCreateOrConnectWithoutSubjectInput | CourseLevelsPerSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: CourseLevelsPerSubjectUpsertWithWhereUniqueWithoutSubjectInput | CourseLevelsPerSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: CourseLevelsPerSubjectCreateManySubjectInputEnvelope
    set?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
    disconnect?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
    delete?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
    connect?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
    update?: CourseLevelsPerSubjectUpdateWithWhereUniqueWithoutSubjectInput | CourseLevelsPerSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: CourseLevelsPerSubjectUpdateManyWithWhereWithoutSubjectInput | CourseLevelsPerSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: CourseLevelsPerSubjectScalarWhereInput | CourseLevelsPerSubjectScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<CourseCreateWithoutSubjectInput, CourseUncheckedCreateWithoutSubjectInput> | CourseCreateWithoutSubjectInput[] | CourseUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutSubjectInput | CourseCreateOrConnectWithoutSubjectInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutSubjectInput | CourseUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: CourseCreateManySubjectInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutSubjectInput | CourseUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutSubjectInput | CourseUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type CourseLevelsPerSubjectUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<CourseLevelsPerSubjectCreateWithoutSubjectInput, CourseLevelsPerSubjectUncheckedCreateWithoutSubjectInput> | CourseLevelsPerSubjectCreateWithoutSubjectInput[] | CourseLevelsPerSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: CourseLevelsPerSubjectCreateOrConnectWithoutSubjectInput | CourseLevelsPerSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: CourseLevelsPerSubjectUpsertWithWhereUniqueWithoutSubjectInput | CourseLevelsPerSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: CourseLevelsPerSubjectCreateManySubjectInputEnvelope
    set?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
    disconnect?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
    delete?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
    connect?: CourseLevelsPerSubjectWhereUniqueInput | CourseLevelsPerSubjectWhereUniqueInput[]
    update?: CourseLevelsPerSubjectUpdateWithWhereUniqueWithoutSubjectInput | CourseLevelsPerSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: CourseLevelsPerSubjectUpdateManyWithWhereWithoutSubjectInput | CourseLevelsPerSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: CourseLevelsPerSubjectScalarWhereInput | CourseLevelsPerSubjectScalarWhereInput[]
  }

  export type CourseLevelCreateNestedOneWithoutCourseLevelsPerSubjectInput = {
    create?: XOR<CourseLevelCreateWithoutCourseLevelsPerSubjectInput, CourseLevelUncheckedCreateWithoutCourseLevelsPerSubjectInput>
    connectOrCreate?: CourseLevelCreateOrConnectWithoutCourseLevelsPerSubjectInput
    connect?: CourseLevelWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutCourseLevelsPerSubjectInput = {
    create?: XOR<SubjectCreateWithoutCourseLevelsPerSubjectInput, SubjectUncheckedCreateWithoutCourseLevelsPerSubjectInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutCourseLevelsPerSubjectInput
    connect?: SubjectWhereUniqueInput
  }

  export type CourseLevelUpdateOneRequiredWithoutCourseLevelsPerSubjectNestedInput = {
    create?: XOR<CourseLevelCreateWithoutCourseLevelsPerSubjectInput, CourseLevelUncheckedCreateWithoutCourseLevelsPerSubjectInput>
    connectOrCreate?: CourseLevelCreateOrConnectWithoutCourseLevelsPerSubjectInput
    upsert?: CourseLevelUpsertWithoutCourseLevelsPerSubjectInput
    connect?: CourseLevelWhereUniqueInput
    update?: XOR<XOR<CourseLevelUpdateToOneWithWhereWithoutCourseLevelsPerSubjectInput, CourseLevelUpdateWithoutCourseLevelsPerSubjectInput>, CourseLevelUncheckedUpdateWithoutCourseLevelsPerSubjectInput>
  }

  export type SubjectUpdateOneRequiredWithoutCourseLevelsPerSubjectNestedInput = {
    create?: XOR<SubjectCreateWithoutCourseLevelsPerSubjectInput, SubjectUncheckedCreateWithoutCourseLevelsPerSubjectInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutCourseLevelsPerSubjectInput
    upsert?: SubjectUpsertWithoutCourseLevelsPerSubjectInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutCourseLevelsPerSubjectInput, SubjectUpdateWithoutCourseLevelsPerSubjectInput>, SubjectUncheckedUpdateWithoutCourseLevelsPerSubjectInput>
  }

  export type SectionCreateNestedOneWithoutLessonInput = {
    create?: XOR<SectionCreateWithoutLessonInput, SectionUncheckedCreateWithoutLessonInput>
    connectOrCreate?: SectionCreateOrConnectWithoutLessonInput
    connect?: SectionWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutLessonInput = {
    create?: XOR<TaskCreateWithoutLessonInput, TaskUncheckedCreateWithoutLessonInput> | TaskCreateWithoutLessonInput[] | TaskUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLessonInput | TaskCreateOrConnectWithoutLessonInput[]
    createMany?: TaskCreateManyLessonInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CourseStructureCreateNestedManyWithoutLessonInput = {
    create?: XOR<CourseStructureCreateWithoutLessonInput, CourseStructureUncheckedCreateWithoutLessonInput> | CourseStructureCreateWithoutLessonInput[] | CourseStructureUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CourseStructureCreateOrConnectWithoutLessonInput | CourseStructureCreateOrConnectWithoutLessonInput[]
    createMany?: CourseStructureCreateManyLessonInputEnvelope
    connect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
  }

  export type CourseTaskCreateNestedManyWithoutLessonInput = {
    create?: XOR<CourseTaskCreateWithoutLessonInput, CourseTaskUncheckedCreateWithoutLessonInput> | CourseTaskCreateWithoutLessonInput[] | CourseTaskUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutLessonInput | CourseTaskCreateOrConnectWithoutLessonInput[]
    createMany?: CourseTaskCreateManyLessonInputEnvelope
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
  }

  export type ModuleCreateNestedOneWithoutLessonsInput = {
    create?: XOR<ModuleCreateWithoutLessonsInput, ModuleUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutLessonsInput
    connect?: ModuleWhereUniqueInput
  }

  export type LessonCardCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonCardCreateWithoutLessonInput, LessonCardUncheckedCreateWithoutLessonInput> | LessonCardCreateWithoutLessonInput[] | LessonCardUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonCardCreateOrConnectWithoutLessonInput | LessonCardCreateOrConnectWithoutLessonInput[]
    createMany?: LessonCardCreateManyLessonInputEnvelope
    connect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
  }

  export type UserCardCreateNestedManyWithoutLessonInput = {
    create?: XOR<UserCardCreateWithoutLessonInput, UserCardUncheckedCreateWithoutLessonInput> | UserCardCreateWithoutLessonInput[] | UserCardUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutLessonInput | UserCardCreateOrConnectWithoutLessonInput[]
    createMany?: UserCardCreateManyLessonInputEnvelope
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<TaskCreateWithoutLessonInput, TaskUncheckedCreateWithoutLessonInput> | TaskCreateWithoutLessonInput[] | TaskUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLessonInput | TaskCreateOrConnectWithoutLessonInput[]
    createMany?: TaskCreateManyLessonInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type CourseStructureUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<CourseStructureCreateWithoutLessonInput, CourseStructureUncheckedCreateWithoutLessonInput> | CourseStructureCreateWithoutLessonInput[] | CourseStructureUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CourseStructureCreateOrConnectWithoutLessonInput | CourseStructureCreateOrConnectWithoutLessonInput[]
    createMany?: CourseStructureCreateManyLessonInputEnvelope
    connect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
  }

  export type CourseTaskUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<CourseTaskCreateWithoutLessonInput, CourseTaskUncheckedCreateWithoutLessonInput> | CourseTaskCreateWithoutLessonInput[] | CourseTaskUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutLessonInput | CourseTaskCreateOrConnectWithoutLessonInput[]
    createMany?: CourseTaskCreateManyLessonInputEnvelope
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
  }

  export type LessonCardUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<LessonCardCreateWithoutLessonInput, LessonCardUncheckedCreateWithoutLessonInput> | LessonCardCreateWithoutLessonInput[] | LessonCardUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonCardCreateOrConnectWithoutLessonInput | LessonCardCreateOrConnectWithoutLessonInput[]
    createMany?: LessonCardCreateManyLessonInputEnvelope
    connect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
  }

  export type UserCardUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<UserCardCreateWithoutLessonInput, UserCardUncheckedCreateWithoutLessonInput> | UserCardCreateWithoutLessonInput[] | UserCardUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutLessonInput | UserCardCreateOrConnectWithoutLessonInput[]
    createMany?: UserCardCreateManyLessonInputEnvelope
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
  }

  export type SectionUpdateOneRequiredWithoutLessonNestedInput = {
    create?: XOR<SectionCreateWithoutLessonInput, SectionUncheckedCreateWithoutLessonInput>
    connectOrCreate?: SectionCreateOrConnectWithoutLessonInput
    upsert?: SectionUpsertWithoutLessonInput
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutLessonInput, SectionUpdateWithoutLessonInput>, SectionUncheckedUpdateWithoutLessonInput>
  }

  export type TaskUpdateManyWithoutLessonNestedInput = {
    create?: XOR<TaskCreateWithoutLessonInput, TaskUncheckedCreateWithoutLessonInput> | TaskCreateWithoutLessonInput[] | TaskUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLessonInput | TaskCreateOrConnectWithoutLessonInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutLessonInput | TaskUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: TaskCreateManyLessonInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutLessonInput | TaskUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutLessonInput | TaskUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CourseStructureUpdateManyWithoutLessonNestedInput = {
    create?: XOR<CourseStructureCreateWithoutLessonInput, CourseStructureUncheckedCreateWithoutLessonInput> | CourseStructureCreateWithoutLessonInput[] | CourseStructureUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CourseStructureCreateOrConnectWithoutLessonInput | CourseStructureCreateOrConnectWithoutLessonInput[]
    upsert?: CourseStructureUpsertWithWhereUniqueWithoutLessonInput | CourseStructureUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: CourseStructureCreateManyLessonInputEnvelope
    set?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    disconnect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    delete?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    connect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    update?: CourseStructureUpdateWithWhereUniqueWithoutLessonInput | CourseStructureUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: CourseStructureUpdateManyWithWhereWithoutLessonInput | CourseStructureUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: CourseStructureScalarWhereInput | CourseStructureScalarWhereInput[]
  }

  export type CourseTaskUpdateManyWithoutLessonNestedInput = {
    create?: XOR<CourseTaskCreateWithoutLessonInput, CourseTaskUncheckedCreateWithoutLessonInput> | CourseTaskCreateWithoutLessonInput[] | CourseTaskUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutLessonInput | CourseTaskCreateOrConnectWithoutLessonInput[]
    upsert?: CourseTaskUpsertWithWhereUniqueWithoutLessonInput | CourseTaskUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: CourseTaskCreateManyLessonInputEnvelope
    set?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    disconnect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    delete?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    update?: CourseTaskUpdateWithWhereUniqueWithoutLessonInput | CourseTaskUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: CourseTaskUpdateManyWithWhereWithoutLessonInput | CourseTaskUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: CourseTaskScalarWhereInput | CourseTaskScalarWhereInput[]
  }

  export type ModuleUpdateOneWithoutLessonsNestedInput = {
    create?: XOR<ModuleCreateWithoutLessonsInput, ModuleUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutLessonsInput
    upsert?: ModuleUpsertWithoutLessonsInput
    disconnect?: ModuleWhereInput | boolean
    delete?: ModuleWhereInput | boolean
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutLessonsInput, ModuleUpdateWithoutLessonsInput>, ModuleUncheckedUpdateWithoutLessonsInput>
  }

  export type LessonCardUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonCardCreateWithoutLessonInput, LessonCardUncheckedCreateWithoutLessonInput> | LessonCardCreateWithoutLessonInput[] | LessonCardUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonCardCreateOrConnectWithoutLessonInput | LessonCardCreateOrConnectWithoutLessonInput[]
    upsert?: LessonCardUpsertWithWhereUniqueWithoutLessonInput | LessonCardUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonCardCreateManyLessonInputEnvelope
    set?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    disconnect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    delete?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    connect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    update?: LessonCardUpdateWithWhereUniqueWithoutLessonInput | LessonCardUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonCardUpdateManyWithWhereWithoutLessonInput | LessonCardUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonCardScalarWhereInput | LessonCardScalarWhereInput[]
  }

  export type UserCardUpdateManyWithoutLessonNestedInput = {
    create?: XOR<UserCardCreateWithoutLessonInput, UserCardUncheckedCreateWithoutLessonInput> | UserCardCreateWithoutLessonInput[] | UserCardUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutLessonInput | UserCardCreateOrConnectWithoutLessonInput[]
    upsert?: UserCardUpsertWithWhereUniqueWithoutLessonInput | UserCardUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: UserCardCreateManyLessonInputEnvelope
    set?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    disconnect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    delete?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    update?: UserCardUpdateWithWhereUniqueWithoutLessonInput | UserCardUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: UserCardUpdateManyWithWhereWithoutLessonInput | UserCardUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: UserCardScalarWhereInput | UserCardScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TaskUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<TaskCreateWithoutLessonInput, TaskUncheckedCreateWithoutLessonInput> | TaskCreateWithoutLessonInput[] | TaskUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutLessonInput | TaskCreateOrConnectWithoutLessonInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutLessonInput | TaskUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: TaskCreateManyLessonInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutLessonInput | TaskUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutLessonInput | TaskUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type CourseStructureUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<CourseStructureCreateWithoutLessonInput, CourseStructureUncheckedCreateWithoutLessonInput> | CourseStructureCreateWithoutLessonInput[] | CourseStructureUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CourseStructureCreateOrConnectWithoutLessonInput | CourseStructureCreateOrConnectWithoutLessonInput[]
    upsert?: CourseStructureUpsertWithWhereUniqueWithoutLessonInput | CourseStructureUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: CourseStructureCreateManyLessonInputEnvelope
    set?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    disconnect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    delete?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    connect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    update?: CourseStructureUpdateWithWhereUniqueWithoutLessonInput | CourseStructureUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: CourseStructureUpdateManyWithWhereWithoutLessonInput | CourseStructureUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: CourseStructureScalarWhereInput | CourseStructureScalarWhereInput[]
  }

  export type CourseTaskUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<CourseTaskCreateWithoutLessonInput, CourseTaskUncheckedCreateWithoutLessonInput> | CourseTaskCreateWithoutLessonInput[] | CourseTaskUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutLessonInput | CourseTaskCreateOrConnectWithoutLessonInput[]
    upsert?: CourseTaskUpsertWithWhereUniqueWithoutLessonInput | CourseTaskUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: CourseTaskCreateManyLessonInputEnvelope
    set?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    disconnect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    delete?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    update?: CourseTaskUpdateWithWhereUniqueWithoutLessonInput | CourseTaskUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: CourseTaskUpdateManyWithWhereWithoutLessonInput | CourseTaskUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: CourseTaskScalarWhereInput | CourseTaskScalarWhereInput[]
  }

  export type LessonCardUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<LessonCardCreateWithoutLessonInput, LessonCardUncheckedCreateWithoutLessonInput> | LessonCardCreateWithoutLessonInput[] | LessonCardUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: LessonCardCreateOrConnectWithoutLessonInput | LessonCardCreateOrConnectWithoutLessonInput[]
    upsert?: LessonCardUpsertWithWhereUniqueWithoutLessonInput | LessonCardUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: LessonCardCreateManyLessonInputEnvelope
    set?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    disconnect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    delete?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    connect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    update?: LessonCardUpdateWithWhereUniqueWithoutLessonInput | LessonCardUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: LessonCardUpdateManyWithWhereWithoutLessonInput | LessonCardUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: LessonCardScalarWhereInput | LessonCardScalarWhereInput[]
  }

  export type UserCardUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<UserCardCreateWithoutLessonInput, UserCardUncheckedCreateWithoutLessonInput> | UserCardCreateWithoutLessonInput[] | UserCardUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: UserCardCreateOrConnectWithoutLessonInput | UserCardCreateOrConnectWithoutLessonInput[]
    upsert?: UserCardUpsertWithWhereUniqueWithoutLessonInput | UserCardUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: UserCardCreateManyLessonInputEnvelope
    set?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    disconnect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    delete?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    connect?: UserCardWhereUniqueInput | UserCardWhereUniqueInput[]
    update?: UserCardUpdateWithWhereUniqueWithoutLessonInput | UserCardUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: UserCardUpdateManyWithWhereWithoutLessonInput | UserCardUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: UserCardScalarWhereInput | UserCardScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMentorInput = {
    create?: XOR<UserCreateWithoutMentorInput, UserUncheckedCreateWithoutMentorInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentorInput
    connect?: UserWhereUniqueInput
  }

  export type MentorsClassesCreateNestedManyWithoutMentorInput = {
    create?: XOR<MentorsClassesCreateWithoutMentorInput, MentorsClassesUncheckedCreateWithoutMentorInput> | MentorsClassesCreateWithoutMentorInput[] | MentorsClassesUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorsClassesCreateOrConnectWithoutMentorInput | MentorsClassesCreateOrConnectWithoutMentorInput[]
    createMany?: MentorsClassesCreateManyMentorInputEnvelope
    connect?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
  }

  export type MentorPayModelCreateNestedManyWithoutMentorInput = {
    create?: XOR<MentorPayModelCreateWithoutMentorInput, MentorPayModelUncheckedCreateWithoutMentorInput> | MentorPayModelCreateWithoutMentorInput[] | MentorPayModelUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorPayModelCreateOrConnectWithoutMentorInput | MentorPayModelCreateOrConnectWithoutMentorInput[]
    createMany?: MentorPayModelCreateManyMentorInputEnvelope
    connect?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
  }

  export type MentorsClassesUncheckedCreateNestedManyWithoutMentorInput = {
    create?: XOR<MentorsClassesCreateWithoutMentorInput, MentorsClassesUncheckedCreateWithoutMentorInput> | MentorsClassesCreateWithoutMentorInput[] | MentorsClassesUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorsClassesCreateOrConnectWithoutMentorInput | MentorsClassesCreateOrConnectWithoutMentorInput[]
    createMany?: MentorsClassesCreateManyMentorInputEnvelope
    connect?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
  }

  export type MentorPayModelUncheckedCreateNestedManyWithoutMentorInput = {
    create?: XOR<MentorPayModelCreateWithoutMentorInput, MentorPayModelUncheckedCreateWithoutMentorInput> | MentorPayModelCreateWithoutMentorInput[] | MentorPayModelUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorPayModelCreateOrConnectWithoutMentorInput | MentorPayModelCreateOrConnectWithoutMentorInput[]
    createMany?: MentorPayModelCreateManyMentorInputEnvelope
    connect?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutMentorNestedInput = {
    create?: XOR<UserCreateWithoutMentorInput, UserUncheckedCreateWithoutMentorInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentorInput
    upsert?: UserUpsertWithoutMentorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentorInput, UserUpdateWithoutMentorInput>, UserUncheckedUpdateWithoutMentorInput>
  }

  export type MentorsClassesUpdateManyWithoutMentorNestedInput = {
    create?: XOR<MentorsClassesCreateWithoutMentorInput, MentorsClassesUncheckedCreateWithoutMentorInput> | MentorsClassesCreateWithoutMentorInput[] | MentorsClassesUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorsClassesCreateOrConnectWithoutMentorInput | MentorsClassesCreateOrConnectWithoutMentorInput[]
    upsert?: MentorsClassesUpsertWithWhereUniqueWithoutMentorInput | MentorsClassesUpsertWithWhereUniqueWithoutMentorInput[]
    createMany?: MentorsClassesCreateManyMentorInputEnvelope
    set?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
    disconnect?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
    delete?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
    connect?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
    update?: MentorsClassesUpdateWithWhereUniqueWithoutMentorInput | MentorsClassesUpdateWithWhereUniqueWithoutMentorInput[]
    updateMany?: MentorsClassesUpdateManyWithWhereWithoutMentorInput | MentorsClassesUpdateManyWithWhereWithoutMentorInput[]
    deleteMany?: MentorsClassesScalarWhereInput | MentorsClassesScalarWhereInput[]
  }

  export type MentorPayModelUpdateManyWithoutMentorNestedInput = {
    create?: XOR<MentorPayModelCreateWithoutMentorInput, MentorPayModelUncheckedCreateWithoutMentorInput> | MentorPayModelCreateWithoutMentorInput[] | MentorPayModelUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorPayModelCreateOrConnectWithoutMentorInput | MentorPayModelCreateOrConnectWithoutMentorInput[]
    upsert?: MentorPayModelUpsertWithWhereUniqueWithoutMentorInput | MentorPayModelUpsertWithWhereUniqueWithoutMentorInput[]
    createMany?: MentorPayModelCreateManyMentorInputEnvelope
    set?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
    disconnect?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
    delete?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
    connect?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
    update?: MentorPayModelUpdateWithWhereUniqueWithoutMentorInput | MentorPayModelUpdateWithWhereUniqueWithoutMentorInput[]
    updateMany?: MentorPayModelUpdateManyWithWhereWithoutMentorInput | MentorPayModelUpdateManyWithWhereWithoutMentorInput[]
    deleteMany?: MentorPayModelScalarWhereInput | MentorPayModelScalarWhereInput[]
  }

  export type MentorsClassesUncheckedUpdateManyWithoutMentorNestedInput = {
    create?: XOR<MentorsClassesCreateWithoutMentorInput, MentorsClassesUncheckedCreateWithoutMentorInput> | MentorsClassesCreateWithoutMentorInput[] | MentorsClassesUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorsClassesCreateOrConnectWithoutMentorInput | MentorsClassesCreateOrConnectWithoutMentorInput[]
    upsert?: MentorsClassesUpsertWithWhereUniqueWithoutMentorInput | MentorsClassesUpsertWithWhereUniqueWithoutMentorInput[]
    createMany?: MentorsClassesCreateManyMentorInputEnvelope
    set?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
    disconnect?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
    delete?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
    connect?: MentorsClassesWhereUniqueInput | MentorsClassesWhereUniqueInput[]
    update?: MentorsClassesUpdateWithWhereUniqueWithoutMentorInput | MentorsClassesUpdateWithWhereUniqueWithoutMentorInput[]
    updateMany?: MentorsClassesUpdateManyWithWhereWithoutMentorInput | MentorsClassesUpdateManyWithWhereWithoutMentorInput[]
    deleteMany?: MentorsClassesScalarWhereInput | MentorsClassesScalarWhereInput[]
  }

  export type MentorPayModelUncheckedUpdateManyWithoutMentorNestedInput = {
    create?: XOR<MentorPayModelCreateWithoutMentorInput, MentorPayModelUncheckedCreateWithoutMentorInput> | MentorPayModelCreateWithoutMentorInput[] | MentorPayModelUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorPayModelCreateOrConnectWithoutMentorInput | MentorPayModelCreateOrConnectWithoutMentorInput[]
    upsert?: MentorPayModelUpsertWithWhereUniqueWithoutMentorInput | MentorPayModelUpsertWithWhereUniqueWithoutMentorInput[]
    createMany?: MentorPayModelCreateManyMentorInputEnvelope
    set?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
    disconnect?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
    delete?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
    connect?: MentorPayModelWhereUniqueInput | MentorPayModelWhereUniqueInput[]
    update?: MentorPayModelUpdateWithWhereUniqueWithoutMentorInput | MentorPayModelUpdateWithWhereUniqueWithoutMentorInput[]
    updateMany?: MentorPayModelUpdateManyWithWhereWithoutMentorInput | MentorPayModelUpdateManyWithWhereWithoutMentorInput[]
    deleteMany?: MentorPayModelScalarWhereInput | MentorPayModelScalarWhereInput[]
  }

  export type MentorCreateNestedOneWithoutMentor_classesInput = {
    create?: XOR<MentorCreateWithoutMentor_classesInput, MentorUncheckedCreateWithoutMentor_classesInput>
    connectOrCreate?: MentorCreateOrConnectWithoutMentor_classesInput
    connect?: MentorWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutMentor_classesInput = {
    create?: XOR<ClassCreateWithoutMentor_classesInput, ClassUncheckedCreateWithoutMentor_classesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutMentor_classesInput
    connect?: ClassWhereUniqueInput
  }

  export type MentorUpdateOneRequiredWithoutMentor_classesNestedInput = {
    create?: XOR<MentorCreateWithoutMentor_classesInput, MentorUncheckedCreateWithoutMentor_classesInput>
    connectOrCreate?: MentorCreateOrConnectWithoutMentor_classesInput
    upsert?: MentorUpsertWithoutMentor_classesInput
    connect?: MentorWhereUniqueInput
    update?: XOR<XOR<MentorUpdateToOneWithWhereWithoutMentor_classesInput, MentorUpdateWithoutMentor_classesInput>, MentorUncheckedUpdateWithoutMentor_classesInput>
  }

  export type ClassUpdateOneRequiredWithoutMentor_classesNestedInput = {
    create?: XOR<ClassCreateWithoutMentor_classesInput, ClassUncheckedCreateWithoutMentor_classesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutMentor_classesInput
    upsert?: ClassUpsertWithoutMentor_classesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutMentor_classesInput, ClassUpdateWithoutMentor_classesInput>, ClassUncheckedUpdateWithoutMentor_classesInput>
  }

  export type MentorCreateNestedOneWithoutMentorPayModelInput = {
    create?: XOR<MentorCreateWithoutMentorPayModelInput, MentorUncheckedCreateWithoutMentorPayModelInput>
    connectOrCreate?: MentorCreateOrConnectWithoutMentorPayModelInput
    connect?: MentorWhereUniqueInput
  }

  export type ClassSizeCreateNestedOneWithoutMentorPayModelInput = {
    create?: XOR<ClassSizeCreateWithoutMentorPayModelInput, ClassSizeUncheckedCreateWithoutMentorPayModelInput>
    connectOrCreate?: ClassSizeCreateOrConnectWithoutMentorPayModelInput
    connect?: ClassSizeWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MentorUpdateOneRequiredWithoutMentorPayModelNestedInput = {
    create?: XOR<MentorCreateWithoutMentorPayModelInput, MentorUncheckedCreateWithoutMentorPayModelInput>
    connectOrCreate?: MentorCreateOrConnectWithoutMentorPayModelInput
    upsert?: MentorUpsertWithoutMentorPayModelInput
    connect?: MentorWhereUniqueInput
    update?: XOR<XOR<MentorUpdateToOneWithWhereWithoutMentorPayModelInput, MentorUpdateWithoutMentorPayModelInput>, MentorUncheckedUpdateWithoutMentorPayModelInput>
  }

  export type ClassSizeUpdateOneRequiredWithoutMentorPayModelNestedInput = {
    create?: XOR<ClassSizeCreateWithoutMentorPayModelInput, ClassSizeUncheckedCreateWithoutMentorPayModelInput>
    connectOrCreate?: ClassSizeCreateOrConnectWithoutMentorPayModelInput
    upsert?: ClassSizeUpsertWithoutMentorPayModelInput
    connect?: ClassSizeWhereUniqueInput
    update?: XOR<XOR<ClassSizeUpdateToOneWithWhereWithoutMentorPayModelInput, ClassSizeUpdateWithoutMentorPayModelInput>, ClassSizeUncheckedUpdateWithoutMentorPayModelInput>
  }

  export type CourseCreateNestedOneWithoutModuleInput = {
    create?: XOR<CourseCreateWithoutModuleInput, CourseUncheckedCreateWithoutModuleInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModuleInput
    connect?: CourseWhereUniqueInput
  }

  export type SectionCreateNestedManyWithoutModuleInput = {
    create?: XOR<SectionCreateWithoutModuleInput, SectionUncheckedCreateWithoutModuleInput> | SectionCreateWithoutModuleInput[] | SectionUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutModuleInput | SectionCreateOrConnectWithoutModuleInput[]
    createMany?: SectionCreateManyModuleInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type LessonCreateNestedManyWithoutModuleInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type CourseStructureCreateNestedManyWithoutModuleInput = {
    create?: XOR<CourseStructureCreateWithoutModuleInput, CourseStructureUncheckedCreateWithoutModuleInput> | CourseStructureCreateWithoutModuleInput[] | CourseStructureUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: CourseStructureCreateOrConnectWithoutModuleInput | CourseStructureCreateOrConnectWithoutModuleInput[]
    createMany?: CourseStructureCreateManyModuleInputEnvelope
    connect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
  }

  export type CourseTaskCreateNestedManyWithoutModuleInput = {
    create?: XOR<CourseTaskCreateWithoutModuleInput, CourseTaskUncheckedCreateWithoutModuleInput> | CourseTaskCreateWithoutModuleInput[] | CourseTaskUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutModuleInput | CourseTaskCreateOrConnectWithoutModuleInput[]
    createMany?: CourseTaskCreateManyModuleInputEnvelope
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
  }

  export type SectionUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<SectionCreateWithoutModuleInput, SectionUncheckedCreateWithoutModuleInput> | SectionCreateWithoutModuleInput[] | SectionUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutModuleInput | SectionCreateOrConnectWithoutModuleInput[]
    createMany?: SectionCreateManyModuleInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type CourseStructureUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<CourseStructureCreateWithoutModuleInput, CourseStructureUncheckedCreateWithoutModuleInput> | CourseStructureCreateWithoutModuleInput[] | CourseStructureUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: CourseStructureCreateOrConnectWithoutModuleInput | CourseStructureCreateOrConnectWithoutModuleInput[]
    createMany?: CourseStructureCreateManyModuleInputEnvelope
    connect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
  }

  export type CourseTaskUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<CourseTaskCreateWithoutModuleInput, CourseTaskUncheckedCreateWithoutModuleInput> | CourseTaskCreateWithoutModuleInput[] | CourseTaskUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutModuleInput | CourseTaskCreateOrConnectWithoutModuleInput[]
    createMany?: CourseTaskCreateManyModuleInputEnvelope
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
  }

  export type CourseUpdateOneRequiredWithoutModuleNestedInput = {
    create?: XOR<CourseCreateWithoutModuleInput, CourseUncheckedCreateWithoutModuleInput>
    connectOrCreate?: CourseCreateOrConnectWithoutModuleInput
    upsert?: CourseUpsertWithoutModuleInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutModuleInput, CourseUpdateWithoutModuleInput>, CourseUncheckedUpdateWithoutModuleInput>
  }

  export type SectionUpdateManyWithoutModuleNestedInput = {
    create?: XOR<SectionCreateWithoutModuleInput, SectionUncheckedCreateWithoutModuleInput> | SectionCreateWithoutModuleInput[] | SectionUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutModuleInput | SectionCreateOrConnectWithoutModuleInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutModuleInput | SectionUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: SectionCreateManyModuleInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutModuleInput | SectionUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutModuleInput | SectionUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type LessonUpdateManyWithoutModuleNestedInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutModuleInput | LessonUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutModuleInput | LessonUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutModuleInput | LessonUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type CourseStructureUpdateManyWithoutModuleNestedInput = {
    create?: XOR<CourseStructureCreateWithoutModuleInput, CourseStructureUncheckedCreateWithoutModuleInput> | CourseStructureCreateWithoutModuleInput[] | CourseStructureUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: CourseStructureCreateOrConnectWithoutModuleInput | CourseStructureCreateOrConnectWithoutModuleInput[]
    upsert?: CourseStructureUpsertWithWhereUniqueWithoutModuleInput | CourseStructureUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: CourseStructureCreateManyModuleInputEnvelope
    set?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    disconnect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    delete?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    connect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    update?: CourseStructureUpdateWithWhereUniqueWithoutModuleInput | CourseStructureUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: CourseStructureUpdateManyWithWhereWithoutModuleInput | CourseStructureUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: CourseStructureScalarWhereInput | CourseStructureScalarWhereInput[]
  }

  export type CourseTaskUpdateManyWithoutModuleNestedInput = {
    create?: XOR<CourseTaskCreateWithoutModuleInput, CourseTaskUncheckedCreateWithoutModuleInput> | CourseTaskCreateWithoutModuleInput[] | CourseTaskUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutModuleInput | CourseTaskCreateOrConnectWithoutModuleInput[]
    upsert?: CourseTaskUpsertWithWhereUniqueWithoutModuleInput | CourseTaskUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: CourseTaskCreateManyModuleInputEnvelope
    set?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    disconnect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    delete?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    update?: CourseTaskUpdateWithWhereUniqueWithoutModuleInput | CourseTaskUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: CourseTaskUpdateManyWithWhereWithoutModuleInput | CourseTaskUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: CourseTaskScalarWhereInput | CourseTaskScalarWhereInput[]
  }

  export type SectionUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<SectionCreateWithoutModuleInput, SectionUncheckedCreateWithoutModuleInput> | SectionCreateWithoutModuleInput[] | SectionUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutModuleInput | SectionCreateOrConnectWithoutModuleInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutModuleInput | SectionUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: SectionCreateManyModuleInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutModuleInput | SectionUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutModuleInput | SectionUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput> | LessonCreateWithoutModuleInput[] | LessonUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutModuleInput | LessonCreateOrConnectWithoutModuleInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutModuleInput | LessonUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: LessonCreateManyModuleInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutModuleInput | LessonUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutModuleInput | LessonUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type CourseStructureUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<CourseStructureCreateWithoutModuleInput, CourseStructureUncheckedCreateWithoutModuleInput> | CourseStructureCreateWithoutModuleInput[] | CourseStructureUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: CourseStructureCreateOrConnectWithoutModuleInput | CourseStructureCreateOrConnectWithoutModuleInput[]
    upsert?: CourseStructureUpsertWithWhereUniqueWithoutModuleInput | CourseStructureUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: CourseStructureCreateManyModuleInputEnvelope
    set?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    disconnect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    delete?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    connect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    update?: CourseStructureUpdateWithWhereUniqueWithoutModuleInput | CourseStructureUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: CourseStructureUpdateManyWithWhereWithoutModuleInput | CourseStructureUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: CourseStructureScalarWhereInput | CourseStructureScalarWhereInput[]
  }

  export type CourseTaskUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<CourseTaskCreateWithoutModuleInput, CourseTaskUncheckedCreateWithoutModuleInput> | CourseTaskCreateWithoutModuleInput[] | CourseTaskUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutModuleInput | CourseTaskCreateOrConnectWithoutModuleInput[]
    upsert?: CourseTaskUpsertWithWhereUniqueWithoutModuleInput | CourseTaskUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: CourseTaskCreateManyModuleInputEnvelope
    set?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    disconnect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    delete?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    update?: CourseTaskUpdateWithWhereUniqueWithoutModuleInput | CourseTaskUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: CourseTaskUpdateManyWithWhereWithoutModuleInput | CourseTaskUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: CourseTaskScalarWhereInput | CourseTaskScalarWhereInput[]
  }

  export type ModuleCreateNestedOneWithoutSectionsInput = {
    create?: XOR<ModuleCreateWithoutSectionsInput, ModuleUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutSectionsInput
    connect?: ModuleWhereUniqueInput
  }

  export type CourseStructureCreateNestedManyWithoutSectionInput = {
    create?: XOR<CourseStructureCreateWithoutSectionInput, CourseStructureUncheckedCreateWithoutSectionInput> | CourseStructureCreateWithoutSectionInput[] | CourseStructureUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: CourseStructureCreateOrConnectWithoutSectionInput | CourseStructureCreateOrConnectWithoutSectionInput[]
    createMany?: CourseStructureCreateManySectionInputEnvelope
    connect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
  }

  export type CourseTaskCreateNestedManyWithoutSectionInput = {
    create?: XOR<CourseTaskCreateWithoutSectionInput, CourseTaskUncheckedCreateWithoutSectionInput> | CourseTaskCreateWithoutSectionInput[] | CourseTaskUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutSectionInput | CourseTaskCreateOrConnectWithoutSectionInput[]
    createMany?: CourseTaskCreateManySectionInputEnvelope
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
  }

  export type LessonCreateNestedManyWithoutSectionInput = {
    create?: XOR<LessonCreateWithoutSectionInput, LessonUncheckedCreateWithoutSectionInput> | LessonCreateWithoutSectionInput[] | LessonUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutSectionInput | LessonCreateOrConnectWithoutSectionInput[]
    createMany?: LessonCreateManySectionInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type CourseStructureUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<CourseStructureCreateWithoutSectionInput, CourseStructureUncheckedCreateWithoutSectionInput> | CourseStructureCreateWithoutSectionInput[] | CourseStructureUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: CourseStructureCreateOrConnectWithoutSectionInput | CourseStructureCreateOrConnectWithoutSectionInput[]
    createMany?: CourseStructureCreateManySectionInputEnvelope
    connect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
  }

  export type CourseTaskUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<CourseTaskCreateWithoutSectionInput, CourseTaskUncheckedCreateWithoutSectionInput> | CourseTaskCreateWithoutSectionInput[] | CourseTaskUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutSectionInput | CourseTaskCreateOrConnectWithoutSectionInput[]
    createMany?: CourseTaskCreateManySectionInputEnvelope
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<LessonCreateWithoutSectionInput, LessonUncheckedCreateWithoutSectionInput> | LessonCreateWithoutSectionInput[] | LessonUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutSectionInput | LessonCreateOrConnectWithoutSectionInput[]
    createMany?: LessonCreateManySectionInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type ModuleUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<ModuleCreateWithoutSectionsInput, ModuleUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutSectionsInput
    upsert?: ModuleUpsertWithoutSectionsInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutSectionsInput, ModuleUpdateWithoutSectionsInput>, ModuleUncheckedUpdateWithoutSectionsInput>
  }

  export type CourseStructureUpdateManyWithoutSectionNestedInput = {
    create?: XOR<CourseStructureCreateWithoutSectionInput, CourseStructureUncheckedCreateWithoutSectionInput> | CourseStructureCreateWithoutSectionInput[] | CourseStructureUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: CourseStructureCreateOrConnectWithoutSectionInput | CourseStructureCreateOrConnectWithoutSectionInput[]
    upsert?: CourseStructureUpsertWithWhereUniqueWithoutSectionInput | CourseStructureUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: CourseStructureCreateManySectionInputEnvelope
    set?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    disconnect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    delete?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    connect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    update?: CourseStructureUpdateWithWhereUniqueWithoutSectionInput | CourseStructureUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: CourseStructureUpdateManyWithWhereWithoutSectionInput | CourseStructureUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: CourseStructureScalarWhereInput | CourseStructureScalarWhereInput[]
  }

  export type CourseTaskUpdateManyWithoutSectionNestedInput = {
    create?: XOR<CourseTaskCreateWithoutSectionInput, CourseTaskUncheckedCreateWithoutSectionInput> | CourseTaskCreateWithoutSectionInput[] | CourseTaskUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutSectionInput | CourseTaskCreateOrConnectWithoutSectionInput[]
    upsert?: CourseTaskUpsertWithWhereUniqueWithoutSectionInput | CourseTaskUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: CourseTaskCreateManySectionInputEnvelope
    set?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    disconnect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    delete?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    update?: CourseTaskUpdateWithWhereUniqueWithoutSectionInput | CourseTaskUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: CourseTaskUpdateManyWithWhereWithoutSectionInput | CourseTaskUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: CourseTaskScalarWhereInput | CourseTaskScalarWhereInput[]
  }

  export type LessonUpdateManyWithoutSectionNestedInput = {
    create?: XOR<LessonCreateWithoutSectionInput, LessonUncheckedCreateWithoutSectionInput> | LessonCreateWithoutSectionInput[] | LessonUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutSectionInput | LessonCreateOrConnectWithoutSectionInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutSectionInput | LessonUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: LessonCreateManySectionInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutSectionInput | LessonUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutSectionInput | LessonUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type CourseStructureUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<CourseStructureCreateWithoutSectionInput, CourseStructureUncheckedCreateWithoutSectionInput> | CourseStructureCreateWithoutSectionInput[] | CourseStructureUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: CourseStructureCreateOrConnectWithoutSectionInput | CourseStructureCreateOrConnectWithoutSectionInput[]
    upsert?: CourseStructureUpsertWithWhereUniqueWithoutSectionInput | CourseStructureUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: CourseStructureCreateManySectionInputEnvelope
    set?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    disconnect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    delete?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    connect?: CourseStructureWhereUniqueInput | CourseStructureWhereUniqueInput[]
    update?: CourseStructureUpdateWithWhereUniqueWithoutSectionInput | CourseStructureUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: CourseStructureUpdateManyWithWhereWithoutSectionInput | CourseStructureUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: CourseStructureScalarWhereInput | CourseStructureScalarWhereInput[]
  }

  export type CourseTaskUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<CourseTaskCreateWithoutSectionInput, CourseTaskUncheckedCreateWithoutSectionInput> | CourseTaskCreateWithoutSectionInput[] | CourseTaskUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutSectionInput | CourseTaskCreateOrConnectWithoutSectionInput[]
    upsert?: CourseTaskUpsertWithWhereUniqueWithoutSectionInput | CourseTaskUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: CourseTaskCreateManySectionInputEnvelope
    set?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    disconnect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    delete?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    update?: CourseTaskUpdateWithWhereUniqueWithoutSectionInput | CourseTaskUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: CourseTaskUpdateManyWithWhereWithoutSectionInput | CourseTaskUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: CourseTaskScalarWhereInput | CourseTaskScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<LessonCreateWithoutSectionInput, LessonUncheckedCreateWithoutSectionInput> | LessonCreateWithoutSectionInput[] | LessonUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutSectionInput | LessonCreateOrConnectWithoutSectionInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutSectionInput | LessonUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: LessonCreateManySectionInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutSectionInput | LessonUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutSectionInput | LessonUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type ClassCreateNestedManyWithoutTime_of_dayInput = {
    create?: XOR<ClassCreateWithoutTime_of_dayInput, ClassUncheckedCreateWithoutTime_of_dayInput> | ClassCreateWithoutTime_of_dayInput[] | ClassUncheckedCreateWithoutTime_of_dayInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTime_of_dayInput | ClassCreateOrConnectWithoutTime_of_dayInput[]
    createMany?: ClassCreateManyTime_of_dayInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutTime_of_dayInput = {
    create?: XOR<ClassCreateWithoutTime_of_dayInput, ClassUncheckedCreateWithoutTime_of_dayInput> | ClassCreateWithoutTime_of_dayInput[] | ClassUncheckedCreateWithoutTime_of_dayInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTime_of_dayInput | ClassCreateOrConnectWithoutTime_of_dayInput[]
    createMany?: ClassCreateManyTime_of_dayInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type ClassUpdateManyWithoutTime_of_dayNestedInput = {
    create?: XOR<ClassCreateWithoutTime_of_dayInput, ClassUncheckedCreateWithoutTime_of_dayInput> | ClassCreateWithoutTime_of_dayInput[] | ClassUncheckedCreateWithoutTime_of_dayInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTime_of_dayInput | ClassCreateOrConnectWithoutTime_of_dayInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutTime_of_dayInput | ClassUpsertWithWhereUniqueWithoutTime_of_dayInput[]
    createMany?: ClassCreateManyTime_of_dayInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutTime_of_dayInput | ClassUpdateWithWhereUniqueWithoutTime_of_dayInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutTime_of_dayInput | ClassUpdateManyWithWhereWithoutTime_of_dayInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutTime_of_dayNestedInput = {
    create?: XOR<ClassCreateWithoutTime_of_dayInput, ClassUncheckedCreateWithoutTime_of_dayInput> | ClassCreateWithoutTime_of_dayInput[] | ClassUncheckedCreateWithoutTime_of_dayInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTime_of_dayInput | ClassCreateOrConnectWithoutTime_of_dayInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutTime_of_dayInput | ClassUpsertWithWhereUniqueWithoutTime_of_dayInput[]
    createMany?: ClassCreateManyTime_of_dayInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutTime_of_dayInput | ClassUpdateWithWhereUniqueWithoutTime_of_dayInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutTime_of_dayInput | ClassUpdateManyWithWhereWithoutTime_of_dayInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type ClassCreateNestedManyWithoutTuition_langInput = {
    create?: XOR<ClassCreateWithoutTuition_langInput, ClassUncheckedCreateWithoutTuition_langInput> | ClassCreateWithoutTuition_langInput[] | ClassUncheckedCreateWithoutTuition_langInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTuition_langInput | ClassCreateOrConnectWithoutTuition_langInput[]
    createMany?: ClassCreateManyTuition_langInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutTuition_langInput = {
    create?: XOR<ClassCreateWithoutTuition_langInput, ClassUncheckedCreateWithoutTuition_langInput> | ClassCreateWithoutTuition_langInput[] | ClassUncheckedCreateWithoutTuition_langInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTuition_langInput | ClassCreateOrConnectWithoutTuition_langInput[]
    createMany?: ClassCreateManyTuition_langInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type ClassUpdateManyWithoutTuition_langNestedInput = {
    create?: XOR<ClassCreateWithoutTuition_langInput, ClassUncheckedCreateWithoutTuition_langInput> | ClassCreateWithoutTuition_langInput[] | ClassUncheckedCreateWithoutTuition_langInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTuition_langInput | ClassCreateOrConnectWithoutTuition_langInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutTuition_langInput | ClassUpsertWithWhereUniqueWithoutTuition_langInput[]
    createMany?: ClassCreateManyTuition_langInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutTuition_langInput | ClassUpdateWithWhereUniqueWithoutTuition_langInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutTuition_langInput | ClassUpdateManyWithWhereWithoutTuition_langInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutTuition_langNestedInput = {
    create?: XOR<ClassCreateWithoutTuition_langInput, ClassUncheckedCreateWithoutTuition_langInput> | ClassCreateWithoutTuition_langInput[] | ClassUncheckedCreateWithoutTuition_langInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutTuition_langInput | ClassCreateOrConnectWithoutTuition_langInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutTuition_langInput | ClassUpsertWithWhereUniqueWithoutTuition_langInput[]
    createMany?: ClassCreateManyTuition_langInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutTuition_langInput | ClassUpdateWithWhereUniqueWithoutTuition_langInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutTuition_langInput | ClassUpdateManyWithWhereWithoutTuition_langInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDeckInput = {
    create?: XOR<UserCreateWithoutDeckInput, UserUncheckedCreateWithoutDeckInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeckInput
    connect?: UserWhereUniqueInput
  }

  export type LessonCardCreateNestedManyWithoutDeckInput = {
    create?: XOR<LessonCardCreateWithoutDeckInput, LessonCardUncheckedCreateWithoutDeckInput> | LessonCardCreateWithoutDeckInput[] | LessonCardUncheckedCreateWithoutDeckInput[]
    connectOrCreate?: LessonCardCreateOrConnectWithoutDeckInput | LessonCardCreateOrConnectWithoutDeckInput[]
    createMany?: LessonCardCreateManyDeckInputEnvelope
    connect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
  }

  export type LessonCardUncheckedCreateNestedManyWithoutDeckInput = {
    create?: XOR<LessonCardCreateWithoutDeckInput, LessonCardUncheckedCreateWithoutDeckInput> | LessonCardCreateWithoutDeckInput[] | LessonCardUncheckedCreateWithoutDeckInput[]
    connectOrCreate?: LessonCardCreateOrConnectWithoutDeckInput | LessonCardCreateOrConnectWithoutDeckInput[]
    createMany?: LessonCardCreateManyDeckInputEnvelope
    connect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutDeckNestedInput = {
    create?: XOR<UserCreateWithoutDeckInput, UserUncheckedCreateWithoutDeckInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeckInput
    upsert?: UserUpsertWithoutDeckInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeckInput, UserUpdateWithoutDeckInput>, UserUncheckedUpdateWithoutDeckInput>
  }

  export type LessonCardUpdateManyWithoutDeckNestedInput = {
    create?: XOR<LessonCardCreateWithoutDeckInput, LessonCardUncheckedCreateWithoutDeckInput> | LessonCardCreateWithoutDeckInput[] | LessonCardUncheckedCreateWithoutDeckInput[]
    connectOrCreate?: LessonCardCreateOrConnectWithoutDeckInput | LessonCardCreateOrConnectWithoutDeckInput[]
    upsert?: LessonCardUpsertWithWhereUniqueWithoutDeckInput | LessonCardUpsertWithWhereUniqueWithoutDeckInput[]
    createMany?: LessonCardCreateManyDeckInputEnvelope
    set?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    disconnect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    delete?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    connect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    update?: LessonCardUpdateWithWhereUniqueWithoutDeckInput | LessonCardUpdateWithWhereUniqueWithoutDeckInput[]
    updateMany?: LessonCardUpdateManyWithWhereWithoutDeckInput | LessonCardUpdateManyWithWhereWithoutDeckInput[]
    deleteMany?: LessonCardScalarWhereInput | LessonCardScalarWhereInput[]
  }

  export type LessonCardUncheckedUpdateManyWithoutDeckNestedInput = {
    create?: XOR<LessonCardCreateWithoutDeckInput, LessonCardUncheckedCreateWithoutDeckInput> | LessonCardCreateWithoutDeckInput[] | LessonCardUncheckedCreateWithoutDeckInput[]
    connectOrCreate?: LessonCardCreateOrConnectWithoutDeckInput | LessonCardCreateOrConnectWithoutDeckInput[]
    upsert?: LessonCardUpsertWithWhereUniqueWithoutDeckInput | LessonCardUpsertWithWhereUniqueWithoutDeckInput[]
    createMany?: LessonCardCreateManyDeckInputEnvelope
    set?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    disconnect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    delete?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    connect?: LessonCardWhereUniqueInput | LessonCardWhereUniqueInput[]
    update?: LessonCardUpdateWithWhereUniqueWithoutDeckInput | LessonCardUpdateWithWhereUniqueWithoutDeckInput[]
    updateMany?: LessonCardUpdateManyWithWhereWithoutDeckInput | LessonCardUpdateManyWithWhereWithoutDeckInput[]
    deleteMany?: LessonCardScalarWhereInput | LessonCardScalarWhereInput[]
  }

  export type DeckCreateNestedOneWithoutCardInput = {
    create?: XOR<DeckCreateWithoutCardInput, DeckUncheckedCreateWithoutCardInput>
    connectOrCreate?: DeckCreateOrConnectWithoutCardInput
    connect?: DeckWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutLessonCardInput = {
    create?: XOR<CourseCreateWithoutLessonCardInput, CourseUncheckedCreateWithoutLessonCardInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLessonCardInput
    connect?: CourseWhereUniqueInput
  }

  export type LessonCreateNestedOneWithoutLessonCardInput = {
    create?: XOR<LessonCreateWithoutLessonCardInput, LessonUncheckedCreateWithoutLessonCardInput>
    connectOrCreate?: LessonCreateOrConnectWithoutLessonCardInput
    connect?: LessonWhereUniqueInput
  }

  export type DeckUpdateOneRequiredWithoutCardNestedInput = {
    create?: XOR<DeckCreateWithoutCardInput, DeckUncheckedCreateWithoutCardInput>
    connectOrCreate?: DeckCreateOrConnectWithoutCardInput
    upsert?: DeckUpsertWithoutCardInput
    connect?: DeckWhereUniqueInput
    update?: XOR<XOR<DeckUpdateToOneWithWhereWithoutCardInput, DeckUpdateWithoutCardInput>, DeckUncheckedUpdateWithoutCardInput>
  }

  export type CourseUpdateOneRequiredWithoutLessonCardNestedInput = {
    create?: XOR<CourseCreateWithoutLessonCardInput, CourseUncheckedCreateWithoutLessonCardInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLessonCardInput
    upsert?: CourseUpsertWithoutLessonCardInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutLessonCardInput, CourseUpdateWithoutLessonCardInput>, CourseUncheckedUpdateWithoutLessonCardInput>
  }

  export type LessonUpdateOneRequiredWithoutLessonCardNestedInput = {
    create?: XOR<LessonCreateWithoutLessonCardInput, LessonUncheckedCreateWithoutLessonCardInput>
    connectOrCreate?: LessonCreateOrConnectWithoutLessonCardInput
    upsert?: LessonUpsertWithoutLessonCardInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutLessonCardInput, LessonUpdateWithoutLessonCardInput>, LessonUncheckedUpdateWithoutLessonCardInput>
  }

  export type UserCreateNestedOneWithoutUserCardInput = {
    create?: XOR<UserCreateWithoutUserCardInput, UserUncheckedCreateWithoutUserCardInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCardInput
    connect?: UserWhereUniqueInput
  }

  export type LessonCreateNestedOneWithoutUserCardInput = {
    create?: XOR<LessonCreateWithoutUserCardInput, LessonUncheckedCreateWithoutUserCardInput>
    connectOrCreate?: LessonCreateOrConnectWithoutUserCardInput
    connect?: LessonWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserCardNestedInput = {
    create?: XOR<UserCreateWithoutUserCardInput, UserUncheckedCreateWithoutUserCardInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserCardInput
    upsert?: UserUpsertWithoutUserCardInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserCardInput, UserUpdateWithoutUserCardInput>, UserUncheckedUpdateWithoutUserCardInput>
  }

  export type LessonUpdateOneWithoutUserCardNestedInput = {
    create?: XOR<LessonCreateWithoutUserCardInput, LessonUncheckedCreateWithoutUserCardInput>
    connectOrCreate?: LessonCreateOrConnectWithoutUserCardInput
    upsert?: LessonUpsertWithoutUserCardInput
    disconnect?: LessonWhereInput | boolean
    delete?: LessonWhereInput | boolean
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutUserCardInput, LessonUpdateWithoutUserCardInput>, LessonUncheckedUpdateWithoutUserCardInput>
  }

  export type UserCreateNestedOneWithoutVocabularyInboxInput = {
    create?: XOR<UserCreateWithoutVocabularyInboxInput, UserUncheckedCreateWithoutVocabularyInboxInput>
    connectOrCreate?: UserCreateOrConnectWithoutVocabularyInboxInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutVocabularyInboxNestedInput = {
    create?: XOR<UserCreateWithoutVocabularyInboxInput, UserUncheckedCreateWithoutVocabularyInboxInput>
    connectOrCreate?: UserCreateOrConnectWithoutVocabularyInboxInput
    upsert?: UserUpsertWithoutVocabularyInboxInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVocabularyInboxInput, UserUpdateWithoutVocabularyInboxInput>, UserUncheckedUpdateWithoutVocabularyInboxInput>
  }

  export type ClassCreateNestedOneWithoutBooking_requestsInput = {
    create?: XOR<ClassCreateWithoutBooking_requestsInput, ClassUncheckedCreateWithoutBooking_requestsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutBooking_requestsInput
    connect?: ClassWhereUniqueInput
  }

  export type EnumBookingRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingRequestStatus
  }

  export type ClassUpdateOneRequiredWithoutBooking_requestsNestedInput = {
    create?: XOR<ClassCreateWithoutBooking_requestsInput, ClassUncheckedCreateWithoutBooking_requestsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutBooking_requestsInput
    upsert?: ClassUpsertWithoutBooking_requestsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutBooking_requestsInput, ClassUpdateWithoutBooking_requestsInput>, ClassUncheckedUpdateWithoutBooking_requestsInput>
  }

  export type CourseTaskCreateNestedOneWithoutClassTaskInput = {
    create?: XOR<CourseTaskCreateWithoutClassTaskInput, CourseTaskUncheckedCreateWithoutClassTaskInput>
    connectOrCreate?: CourseTaskCreateOrConnectWithoutClassTaskInput
    connect?: CourseTaskWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutClassTaskInput = {
    create?: XOR<ClassCreateWithoutClassTaskInput, ClassUncheckedCreateWithoutClassTaskInput>
    connectOrCreate?: ClassCreateOrConnectWithoutClassTaskInput
    connect?: ClassWhereUniqueInput
  }

  export type StudentTaskCreateNestedManyWithoutClass_taskInput = {
    create?: XOR<StudentTaskCreateWithoutClass_taskInput, StudentTaskUncheckedCreateWithoutClass_taskInput> | StudentTaskCreateWithoutClass_taskInput[] | StudentTaskUncheckedCreateWithoutClass_taskInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutClass_taskInput | StudentTaskCreateOrConnectWithoutClass_taskInput[]
    createMany?: StudentTaskCreateManyClass_taskInputEnvelope
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
  }

  export type StudentAnswerCreateNestedManyWithoutClass_taskInput = {
    create?: XOR<StudentAnswerCreateWithoutClass_taskInput, StudentAnswerUncheckedCreateWithoutClass_taskInput> | StudentAnswerCreateWithoutClass_taskInput[] | StudentAnswerUncheckedCreateWithoutClass_taskInput[]
    connectOrCreate?: StudentAnswerCreateOrConnectWithoutClass_taskInput | StudentAnswerCreateOrConnectWithoutClass_taskInput[]
    createMany?: StudentAnswerCreateManyClass_taskInputEnvelope
    connect?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
  }

  export type StudentTaskUncheckedCreateNestedManyWithoutClass_taskInput = {
    create?: XOR<StudentTaskCreateWithoutClass_taskInput, StudentTaskUncheckedCreateWithoutClass_taskInput> | StudentTaskCreateWithoutClass_taskInput[] | StudentTaskUncheckedCreateWithoutClass_taskInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutClass_taskInput | StudentTaskCreateOrConnectWithoutClass_taskInput[]
    createMany?: StudentTaskCreateManyClass_taskInputEnvelope
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
  }

  export type StudentAnswerUncheckedCreateNestedManyWithoutClass_taskInput = {
    create?: XOR<StudentAnswerCreateWithoutClass_taskInput, StudentAnswerUncheckedCreateWithoutClass_taskInput> | StudentAnswerCreateWithoutClass_taskInput[] | StudentAnswerUncheckedCreateWithoutClass_taskInput[]
    connectOrCreate?: StudentAnswerCreateOrConnectWithoutClass_taskInput | StudentAnswerCreateOrConnectWithoutClass_taskInput[]
    createMany?: StudentAnswerCreateManyClass_taskInputEnvelope
    connect?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
  }

  export type CourseTaskUpdateOneRequiredWithoutClassTaskNestedInput = {
    create?: XOR<CourseTaskCreateWithoutClassTaskInput, CourseTaskUncheckedCreateWithoutClassTaskInput>
    connectOrCreate?: CourseTaskCreateOrConnectWithoutClassTaskInput
    upsert?: CourseTaskUpsertWithoutClassTaskInput
    connect?: CourseTaskWhereUniqueInput
    update?: XOR<XOR<CourseTaskUpdateToOneWithWhereWithoutClassTaskInput, CourseTaskUpdateWithoutClassTaskInput>, CourseTaskUncheckedUpdateWithoutClassTaskInput>
  }

  export type ClassUpdateOneRequiredWithoutClassTaskNestedInput = {
    create?: XOR<ClassCreateWithoutClassTaskInput, ClassUncheckedCreateWithoutClassTaskInput>
    connectOrCreate?: ClassCreateOrConnectWithoutClassTaskInput
    upsert?: ClassUpsertWithoutClassTaskInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutClassTaskInput, ClassUpdateWithoutClassTaskInput>, ClassUncheckedUpdateWithoutClassTaskInput>
  }

  export type StudentTaskUpdateManyWithoutClass_taskNestedInput = {
    create?: XOR<StudentTaskCreateWithoutClass_taskInput, StudentTaskUncheckedCreateWithoutClass_taskInput> | StudentTaskCreateWithoutClass_taskInput[] | StudentTaskUncheckedCreateWithoutClass_taskInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutClass_taskInput | StudentTaskCreateOrConnectWithoutClass_taskInput[]
    upsert?: StudentTaskUpsertWithWhereUniqueWithoutClass_taskInput | StudentTaskUpsertWithWhereUniqueWithoutClass_taskInput[]
    createMany?: StudentTaskCreateManyClass_taskInputEnvelope
    set?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    disconnect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    delete?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    update?: StudentTaskUpdateWithWhereUniqueWithoutClass_taskInput | StudentTaskUpdateWithWhereUniqueWithoutClass_taskInput[]
    updateMany?: StudentTaskUpdateManyWithWhereWithoutClass_taskInput | StudentTaskUpdateManyWithWhereWithoutClass_taskInput[]
    deleteMany?: StudentTaskScalarWhereInput | StudentTaskScalarWhereInput[]
  }

  export type StudentAnswerUpdateManyWithoutClass_taskNestedInput = {
    create?: XOR<StudentAnswerCreateWithoutClass_taskInput, StudentAnswerUncheckedCreateWithoutClass_taskInput> | StudentAnswerCreateWithoutClass_taskInput[] | StudentAnswerUncheckedCreateWithoutClass_taskInput[]
    connectOrCreate?: StudentAnswerCreateOrConnectWithoutClass_taskInput | StudentAnswerCreateOrConnectWithoutClass_taskInput[]
    upsert?: StudentAnswerUpsertWithWhereUniqueWithoutClass_taskInput | StudentAnswerUpsertWithWhereUniqueWithoutClass_taskInput[]
    createMany?: StudentAnswerCreateManyClass_taskInputEnvelope
    set?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
    disconnect?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
    delete?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
    connect?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
    update?: StudentAnswerUpdateWithWhereUniqueWithoutClass_taskInput | StudentAnswerUpdateWithWhereUniqueWithoutClass_taskInput[]
    updateMany?: StudentAnswerUpdateManyWithWhereWithoutClass_taskInput | StudentAnswerUpdateManyWithWhereWithoutClass_taskInput[]
    deleteMany?: StudentAnswerScalarWhereInput | StudentAnswerScalarWhereInput[]
  }

  export type StudentTaskUncheckedUpdateManyWithoutClass_taskNestedInput = {
    create?: XOR<StudentTaskCreateWithoutClass_taskInput, StudentTaskUncheckedCreateWithoutClass_taskInput> | StudentTaskCreateWithoutClass_taskInput[] | StudentTaskUncheckedCreateWithoutClass_taskInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutClass_taskInput | StudentTaskCreateOrConnectWithoutClass_taskInput[]
    upsert?: StudentTaskUpsertWithWhereUniqueWithoutClass_taskInput | StudentTaskUpsertWithWhereUniqueWithoutClass_taskInput[]
    createMany?: StudentTaskCreateManyClass_taskInputEnvelope
    set?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    disconnect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    delete?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    update?: StudentTaskUpdateWithWhereUniqueWithoutClass_taskInput | StudentTaskUpdateWithWhereUniqueWithoutClass_taskInput[]
    updateMany?: StudentTaskUpdateManyWithWhereWithoutClass_taskInput | StudentTaskUpdateManyWithWhereWithoutClass_taskInput[]
    deleteMany?: StudentTaskScalarWhereInput | StudentTaskScalarWhereInput[]
  }

  export type StudentAnswerUncheckedUpdateManyWithoutClass_taskNestedInput = {
    create?: XOR<StudentAnswerCreateWithoutClass_taskInput, StudentAnswerUncheckedCreateWithoutClass_taskInput> | StudentAnswerCreateWithoutClass_taskInput[] | StudentAnswerUncheckedCreateWithoutClass_taskInput[]
    connectOrCreate?: StudentAnswerCreateOrConnectWithoutClass_taskInput | StudentAnswerCreateOrConnectWithoutClass_taskInput[]
    upsert?: StudentAnswerUpsertWithWhereUniqueWithoutClass_taskInput | StudentAnswerUpsertWithWhereUniqueWithoutClass_taskInput[]
    createMany?: StudentAnswerCreateManyClass_taskInputEnvelope
    set?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
    disconnect?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
    delete?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
    connect?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
    update?: StudentAnswerUpdateWithWhereUniqueWithoutClass_taskInput | StudentAnswerUpdateWithWhereUniqueWithoutClass_taskInput[]
    updateMany?: StudentAnswerUpdateManyWithWhereWithoutClass_taskInput | StudentAnswerUpdateManyWithWhereWithoutClass_taskInput[]
    deleteMany?: StudentAnswerScalarWhereInput | StudentAnswerScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutIs_student_ofInput = {
    create?: XOR<UserCreateWithoutIs_student_ofInput, UserUncheckedCreateWithoutIs_student_ofInput>
    connectOrCreate?: UserCreateOrConnectWithoutIs_student_ofInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutStudentsInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput
    connect?: ClassWhereUniqueInput
  }

  export type StudentTaskCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentTaskCreateWithoutStudentInput, StudentTaskUncheckedCreateWithoutStudentInput> | StudentTaskCreateWithoutStudentInput[] | StudentTaskUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutStudentInput | StudentTaskCreateOrConnectWithoutStudentInput[]
    createMany?: StudentTaskCreateManyStudentInputEnvelope
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
  }

  export type StudentAnswerCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAnswerCreateWithoutStudentInput, StudentAnswerUncheckedCreateWithoutStudentInput> | StudentAnswerCreateWithoutStudentInput[] | StudentAnswerUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAnswerCreateOrConnectWithoutStudentInput | StudentAnswerCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAnswerCreateManyStudentInputEnvelope
    connect?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
  }

  export type StudentTaskUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentTaskCreateWithoutStudentInput, StudentTaskUncheckedCreateWithoutStudentInput> | StudentTaskCreateWithoutStudentInput[] | StudentTaskUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutStudentInput | StudentTaskCreateOrConnectWithoutStudentInput[]
    createMany?: StudentTaskCreateManyStudentInputEnvelope
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
  }

  export type StudentAnswerUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAnswerCreateWithoutStudentInput, StudentAnswerUncheckedCreateWithoutStudentInput> | StudentAnswerCreateWithoutStudentInput[] | StudentAnswerUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAnswerCreateOrConnectWithoutStudentInput | StudentAnswerCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAnswerCreateManyStudentInputEnvelope
    connect?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutIs_student_ofNestedInput = {
    create?: XOR<UserCreateWithoutIs_student_ofInput, UserUncheckedCreateWithoutIs_student_ofInput>
    connectOrCreate?: UserCreateOrConnectWithoutIs_student_ofInput
    upsert?: UserUpsertWithoutIs_student_ofInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIs_student_ofInput, UserUpdateWithoutIs_student_ofInput>, UserUncheckedUpdateWithoutIs_student_ofInput>
  }

  export type ClassUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput
    upsert?: ClassUpsertWithoutStudentsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutStudentsInput, ClassUpdateWithoutStudentsInput>, ClassUncheckedUpdateWithoutStudentsInput>
  }

  export type StudentTaskUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentTaskCreateWithoutStudentInput, StudentTaskUncheckedCreateWithoutStudentInput> | StudentTaskCreateWithoutStudentInput[] | StudentTaskUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutStudentInput | StudentTaskCreateOrConnectWithoutStudentInput[]
    upsert?: StudentTaskUpsertWithWhereUniqueWithoutStudentInput | StudentTaskUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentTaskCreateManyStudentInputEnvelope
    set?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    disconnect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    delete?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    update?: StudentTaskUpdateWithWhereUniqueWithoutStudentInput | StudentTaskUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentTaskUpdateManyWithWhereWithoutStudentInput | StudentTaskUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentTaskScalarWhereInput | StudentTaskScalarWhereInput[]
  }

  export type StudentAnswerUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAnswerCreateWithoutStudentInput, StudentAnswerUncheckedCreateWithoutStudentInput> | StudentAnswerCreateWithoutStudentInput[] | StudentAnswerUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAnswerCreateOrConnectWithoutStudentInput | StudentAnswerCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAnswerUpsertWithWhereUniqueWithoutStudentInput | StudentAnswerUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAnswerCreateManyStudentInputEnvelope
    set?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
    disconnect?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
    delete?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
    connect?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
    update?: StudentAnswerUpdateWithWhereUniqueWithoutStudentInput | StudentAnswerUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAnswerUpdateManyWithWhereWithoutStudentInput | StudentAnswerUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAnswerScalarWhereInput | StudentAnswerScalarWhereInput[]
  }

  export type StudentTaskUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentTaskCreateWithoutStudentInput, StudentTaskUncheckedCreateWithoutStudentInput> | StudentTaskCreateWithoutStudentInput[] | StudentTaskUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutStudentInput | StudentTaskCreateOrConnectWithoutStudentInput[]
    upsert?: StudentTaskUpsertWithWhereUniqueWithoutStudentInput | StudentTaskUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentTaskCreateManyStudentInputEnvelope
    set?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    disconnect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    delete?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    update?: StudentTaskUpdateWithWhereUniqueWithoutStudentInput | StudentTaskUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentTaskUpdateManyWithWhereWithoutStudentInput | StudentTaskUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentTaskScalarWhereInput | StudentTaskScalarWhereInput[]
  }

  export type StudentAnswerUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAnswerCreateWithoutStudentInput, StudentAnswerUncheckedCreateWithoutStudentInput> | StudentAnswerCreateWithoutStudentInput[] | StudentAnswerUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAnswerCreateOrConnectWithoutStudentInput | StudentAnswerCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAnswerUpsertWithWhereUniqueWithoutStudentInput | StudentAnswerUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAnswerCreateManyStudentInputEnvelope
    set?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
    disconnect?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
    delete?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
    connect?: StudentAnswerWhereUniqueInput | StudentAnswerWhereUniqueInput[]
    update?: StudentAnswerUpdateWithWhereUniqueWithoutStudentInput | StudentAnswerUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAnswerUpdateManyWithWhereWithoutStudentInput | StudentAnswerUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAnswerScalarWhereInput | StudentAnswerScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutStudent_answersInput = {
    create?: XOR<StudentCreateWithoutStudent_answersInput, StudentUncheckedCreateWithoutStudent_answersInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudent_answersInput
    connect?: StudentWhereUniqueInput
  }

  export type ClassTaskCreateNestedOneWithoutStudent_answerInput = {
    create?: XOR<ClassTaskCreateWithoutStudent_answerInput, ClassTaskUncheckedCreateWithoutStudent_answerInput>
    connectOrCreate?: ClassTaskCreateOrConnectWithoutStudent_answerInput
    connect?: ClassTaskWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutStudent_answersNestedInput = {
    create?: XOR<StudentCreateWithoutStudent_answersInput, StudentUncheckedCreateWithoutStudent_answersInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudent_answersInput
    upsert?: StudentUpsertWithoutStudent_answersInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudent_answersInput, StudentUpdateWithoutStudent_answersInput>, StudentUncheckedUpdateWithoutStudent_answersInput>
  }

  export type ClassTaskUpdateOneRequiredWithoutStudent_answerNestedInput = {
    create?: XOR<ClassTaskCreateWithoutStudent_answerInput, ClassTaskUncheckedCreateWithoutStudent_answerInput>
    connectOrCreate?: ClassTaskCreateOrConnectWithoutStudent_answerInput
    upsert?: ClassTaskUpsertWithoutStudent_answerInput
    connect?: ClassTaskWhereUniqueInput
    update?: XOR<XOR<ClassTaskUpdateToOneWithWhereWithoutStudent_answerInput, ClassTaskUpdateWithoutStudent_answerInput>, ClassTaskUncheckedUpdateWithoutStudent_answerInput>
  }

  export type StudentCreateNestedOneWithoutStudent_taskInput = {
    create?: XOR<StudentCreateWithoutStudent_taskInput, StudentUncheckedCreateWithoutStudent_taskInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudent_taskInput
    connect?: StudentWhereUniqueInput
  }

  export type ClassTaskCreateNestedOneWithoutStudent_tasksInput = {
    create?: XOR<ClassTaskCreateWithoutStudent_tasksInput, ClassTaskUncheckedCreateWithoutStudent_tasksInput>
    connectOrCreate?: ClassTaskCreateOrConnectWithoutStudent_tasksInput
    connect?: ClassTaskWhereUniqueInput
  }

  export type EnumStudentTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.StudentTaskStatus
  }

  export type StudentUpdateOneRequiredWithoutStudent_taskNestedInput = {
    create?: XOR<StudentCreateWithoutStudent_taskInput, StudentUncheckedCreateWithoutStudent_taskInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudent_taskInput
    upsert?: StudentUpsertWithoutStudent_taskInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudent_taskInput, StudentUpdateWithoutStudent_taskInput>, StudentUncheckedUpdateWithoutStudent_taskInput>
  }

  export type ClassTaskUpdateOneRequiredWithoutStudent_tasksNestedInput = {
    create?: XOR<ClassTaskCreateWithoutStudent_tasksInput, ClassTaskUncheckedCreateWithoutStudent_tasksInput>
    connectOrCreate?: ClassTaskCreateOrConnectWithoutStudent_tasksInput
    upsert?: ClassTaskUpsertWithoutStudent_tasksInput
    connect?: ClassTaskWhereUniqueInput
    update?: XOR<XOR<ClassTaskUpdateToOneWithWhereWithoutStudent_tasksInput, ClassTaskUpdateWithoutStudent_tasksInput>, ClassTaskUncheckedUpdateWithoutStudent_tasksInput>
  }

  export type TaskTypeCreateNestedOneWithoutTaskInput = {
    create?: XOR<TaskTypeCreateWithoutTaskInput, TaskTypeUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskTypeCreateOrConnectWithoutTaskInput
    connect?: TaskTypeWhereUniqueInput
  }

  export type TaskContextCreateNestedOneWithoutTaskInput = {
    create?: XOR<TaskContextCreateWithoutTaskInput, TaskContextUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskContextCreateOrConnectWithoutTaskInput
    connect?: TaskContextWhereUniqueInput
  }

  export type LessonCreateNestedOneWithoutTasksInput = {
    create?: XOR<LessonCreateWithoutTasksInput, LessonUncheckedCreateWithoutTasksInput>
    connectOrCreate?: LessonCreateOrConnectWithoutTasksInput
    connect?: LessonWhereUniqueInput
  }

  export type TaskFormCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskFormCreateWithoutTaskInput, TaskFormUncheckedCreateWithoutTaskInput> | TaskFormCreateWithoutTaskInput[] | TaskFormUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskFormCreateOrConnectWithoutTaskInput | TaskFormCreateOrConnectWithoutTaskInput[]
    connect?: TaskFormWhereUniqueInput | TaskFormWhereUniqueInput[]
  }

  export type TaskOptionCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskOptionCreateWithoutTaskInput, TaskOptionUncheckedCreateWithoutTaskInput> | TaskOptionCreateWithoutTaskInput[] | TaskOptionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskOptionCreateOrConnectWithoutTaskInput | TaskOptionCreateOrConnectWithoutTaskInput[]
    createMany?: TaskOptionCreateManyTaskInputEnvelope
    connect?: TaskOptionWhereUniqueInput | TaskOptionWhereUniqueInput[]
  }

  export type CourseTaskCreateNestedManyWithoutTaskInput = {
    create?: XOR<CourseTaskCreateWithoutTaskInput, CourseTaskUncheckedCreateWithoutTaskInput> | CourseTaskCreateWithoutTaskInput[] | CourseTaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutTaskInput | CourseTaskCreateOrConnectWithoutTaskInput[]
    createMany?: CourseTaskCreateManyTaskInputEnvelope
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
  }

  export type TaskFormUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskFormCreateWithoutTaskInput, TaskFormUncheckedCreateWithoutTaskInput> | TaskFormCreateWithoutTaskInput[] | TaskFormUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskFormCreateOrConnectWithoutTaskInput | TaskFormCreateOrConnectWithoutTaskInput[]
    connect?: TaskFormWhereUniqueInput | TaskFormWhereUniqueInput[]
  }

  export type TaskOptionUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskOptionCreateWithoutTaskInput, TaskOptionUncheckedCreateWithoutTaskInput> | TaskOptionCreateWithoutTaskInput[] | TaskOptionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskOptionCreateOrConnectWithoutTaskInput | TaskOptionCreateOrConnectWithoutTaskInput[]
    createMany?: TaskOptionCreateManyTaskInputEnvelope
    connect?: TaskOptionWhereUniqueInput | TaskOptionWhereUniqueInput[]
  }

  export type CourseTaskUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<CourseTaskCreateWithoutTaskInput, CourseTaskUncheckedCreateWithoutTaskInput> | CourseTaskCreateWithoutTaskInput[] | CourseTaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutTaskInput | CourseTaskCreateOrConnectWithoutTaskInput[]
    createMany?: CourseTaskCreateManyTaskInputEnvelope
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
  }

  export type TaskTypeUpdateOneRequiredWithoutTaskNestedInput = {
    create?: XOR<TaskTypeCreateWithoutTaskInput, TaskTypeUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskTypeCreateOrConnectWithoutTaskInput
    upsert?: TaskTypeUpsertWithoutTaskInput
    connect?: TaskTypeWhereUniqueInput
    update?: XOR<XOR<TaskTypeUpdateToOneWithWhereWithoutTaskInput, TaskTypeUpdateWithoutTaskInput>, TaskTypeUncheckedUpdateWithoutTaskInput>
  }

  export type TaskContextUpdateOneRequiredWithoutTaskNestedInput = {
    create?: XOR<TaskContextCreateWithoutTaskInput, TaskContextUncheckedCreateWithoutTaskInput>
    connectOrCreate?: TaskContextCreateOrConnectWithoutTaskInput
    upsert?: TaskContextUpsertWithoutTaskInput
    connect?: TaskContextWhereUniqueInput
    update?: XOR<XOR<TaskContextUpdateToOneWithWhereWithoutTaskInput, TaskContextUpdateWithoutTaskInput>, TaskContextUncheckedUpdateWithoutTaskInput>
  }

  export type LessonUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<LessonCreateWithoutTasksInput, LessonUncheckedCreateWithoutTasksInput>
    connectOrCreate?: LessonCreateOrConnectWithoutTasksInput
    upsert?: LessonUpsertWithoutTasksInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutTasksInput, LessonUpdateWithoutTasksInput>, LessonUncheckedUpdateWithoutTasksInput>
  }

  export type TaskFormUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskFormCreateWithoutTaskInput, TaskFormUncheckedCreateWithoutTaskInput> | TaskFormCreateWithoutTaskInput[] | TaskFormUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskFormCreateOrConnectWithoutTaskInput | TaskFormCreateOrConnectWithoutTaskInput[]
    upsert?: TaskFormUpsertWithWhereUniqueWithoutTaskInput | TaskFormUpsertWithWhereUniqueWithoutTaskInput[]
    set?: TaskFormWhereUniqueInput | TaskFormWhereUniqueInput[]
    disconnect?: TaskFormWhereUniqueInput | TaskFormWhereUniqueInput[]
    delete?: TaskFormWhereUniqueInput | TaskFormWhereUniqueInput[]
    connect?: TaskFormWhereUniqueInput | TaskFormWhereUniqueInput[]
    update?: TaskFormUpdateWithWhereUniqueWithoutTaskInput | TaskFormUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskFormUpdateManyWithWhereWithoutTaskInput | TaskFormUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskFormScalarWhereInput | TaskFormScalarWhereInput[]
  }

  export type TaskOptionUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskOptionCreateWithoutTaskInput, TaskOptionUncheckedCreateWithoutTaskInput> | TaskOptionCreateWithoutTaskInput[] | TaskOptionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskOptionCreateOrConnectWithoutTaskInput | TaskOptionCreateOrConnectWithoutTaskInput[]
    upsert?: TaskOptionUpsertWithWhereUniqueWithoutTaskInput | TaskOptionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskOptionCreateManyTaskInputEnvelope
    set?: TaskOptionWhereUniqueInput | TaskOptionWhereUniqueInput[]
    disconnect?: TaskOptionWhereUniqueInput | TaskOptionWhereUniqueInput[]
    delete?: TaskOptionWhereUniqueInput | TaskOptionWhereUniqueInput[]
    connect?: TaskOptionWhereUniqueInput | TaskOptionWhereUniqueInput[]
    update?: TaskOptionUpdateWithWhereUniqueWithoutTaskInput | TaskOptionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskOptionUpdateManyWithWhereWithoutTaskInput | TaskOptionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskOptionScalarWhereInput | TaskOptionScalarWhereInput[]
  }

  export type CourseTaskUpdateManyWithoutTaskNestedInput = {
    create?: XOR<CourseTaskCreateWithoutTaskInput, CourseTaskUncheckedCreateWithoutTaskInput> | CourseTaskCreateWithoutTaskInput[] | CourseTaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutTaskInput | CourseTaskCreateOrConnectWithoutTaskInput[]
    upsert?: CourseTaskUpsertWithWhereUniqueWithoutTaskInput | CourseTaskUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: CourseTaskCreateManyTaskInputEnvelope
    set?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    disconnect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    delete?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    update?: CourseTaskUpdateWithWhereUniqueWithoutTaskInput | CourseTaskUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: CourseTaskUpdateManyWithWhereWithoutTaskInput | CourseTaskUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: CourseTaskScalarWhereInput | CourseTaskScalarWhereInput[]
  }

  export type TaskFormUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskFormCreateWithoutTaskInput, TaskFormUncheckedCreateWithoutTaskInput> | TaskFormCreateWithoutTaskInput[] | TaskFormUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskFormCreateOrConnectWithoutTaskInput | TaskFormCreateOrConnectWithoutTaskInput[]
    upsert?: TaskFormUpsertWithWhereUniqueWithoutTaskInput | TaskFormUpsertWithWhereUniqueWithoutTaskInput[]
    set?: TaskFormWhereUniqueInput | TaskFormWhereUniqueInput[]
    disconnect?: TaskFormWhereUniqueInput | TaskFormWhereUniqueInput[]
    delete?: TaskFormWhereUniqueInput | TaskFormWhereUniqueInput[]
    connect?: TaskFormWhereUniqueInput | TaskFormWhereUniqueInput[]
    update?: TaskFormUpdateWithWhereUniqueWithoutTaskInput | TaskFormUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskFormUpdateManyWithWhereWithoutTaskInput | TaskFormUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskFormScalarWhereInput | TaskFormScalarWhereInput[]
  }

  export type TaskOptionUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskOptionCreateWithoutTaskInput, TaskOptionUncheckedCreateWithoutTaskInput> | TaskOptionCreateWithoutTaskInput[] | TaskOptionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskOptionCreateOrConnectWithoutTaskInput | TaskOptionCreateOrConnectWithoutTaskInput[]
    upsert?: TaskOptionUpsertWithWhereUniqueWithoutTaskInput | TaskOptionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskOptionCreateManyTaskInputEnvelope
    set?: TaskOptionWhereUniqueInput | TaskOptionWhereUniqueInput[]
    disconnect?: TaskOptionWhereUniqueInput | TaskOptionWhereUniqueInput[]
    delete?: TaskOptionWhereUniqueInput | TaskOptionWhereUniqueInput[]
    connect?: TaskOptionWhereUniqueInput | TaskOptionWhereUniqueInput[]
    update?: TaskOptionUpdateWithWhereUniqueWithoutTaskInput | TaskOptionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskOptionUpdateManyWithWhereWithoutTaskInput | TaskOptionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskOptionScalarWhereInput | TaskOptionScalarWhereInput[]
  }

  export type CourseTaskUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<CourseTaskCreateWithoutTaskInput, CourseTaskUncheckedCreateWithoutTaskInput> | CourseTaskCreateWithoutTaskInput[] | CourseTaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: CourseTaskCreateOrConnectWithoutTaskInput | CourseTaskCreateOrConnectWithoutTaskInput[]
    upsert?: CourseTaskUpsertWithWhereUniqueWithoutTaskInput | CourseTaskUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: CourseTaskCreateManyTaskInputEnvelope
    set?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    disconnect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    delete?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    connect?: CourseTaskWhereUniqueInput | CourseTaskWhereUniqueInput[]
    update?: CourseTaskUpdateWithWhereUniqueWithoutTaskInput | CourseTaskUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: CourseTaskUpdateManyWithWhereWithoutTaskInput | CourseTaskUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: CourseTaskScalarWhereInput | CourseTaskScalarWhereInput[]
  }

  export type TaskCreateNestedManyWithoutTask_formsInput = {
    create?: XOR<TaskCreateWithoutTask_formsInput, TaskUncheckedCreateWithoutTask_formsInput> | TaskCreateWithoutTask_formsInput[] | TaskUncheckedCreateWithoutTask_formsInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTask_formsInput | TaskCreateOrConnectWithoutTask_formsInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutTask_formsInput = {
    create?: XOR<TaskCreateWithoutTask_formsInput, TaskUncheckedCreateWithoutTask_formsInput> | TaskCreateWithoutTask_formsInput[] | TaskUncheckedCreateWithoutTask_formsInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTask_formsInput | TaskCreateOrConnectWithoutTask_formsInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUpdateManyWithoutTask_formsNestedInput = {
    create?: XOR<TaskCreateWithoutTask_formsInput, TaskUncheckedCreateWithoutTask_formsInput> | TaskCreateWithoutTask_formsInput[] | TaskUncheckedCreateWithoutTask_formsInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTask_formsInput | TaskCreateOrConnectWithoutTask_formsInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTask_formsInput | TaskUpsertWithWhereUniqueWithoutTask_formsInput[]
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTask_formsInput | TaskUpdateWithWhereUniqueWithoutTask_formsInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTask_formsInput | TaskUpdateManyWithWhereWithoutTask_formsInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutTask_formsNestedInput = {
    create?: XOR<TaskCreateWithoutTask_formsInput, TaskUncheckedCreateWithoutTask_formsInput> | TaskCreateWithoutTask_formsInput[] | TaskUncheckedCreateWithoutTask_formsInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTask_formsInput | TaskCreateOrConnectWithoutTask_formsInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTask_formsInput | TaskUpsertWithWhereUniqueWithoutTask_formsInput[]
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTask_formsInput | TaskUpdateWithWhereUniqueWithoutTask_formsInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTask_formsInput | TaskUpdateManyWithWhereWithoutTask_formsInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskCreateNestedManyWithoutTask_contextInput = {
    create?: XOR<TaskCreateWithoutTask_contextInput, TaskUncheckedCreateWithoutTask_contextInput> | TaskCreateWithoutTask_contextInput[] | TaskUncheckedCreateWithoutTask_contextInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTask_contextInput | TaskCreateOrConnectWithoutTask_contextInput[]
    createMany?: TaskCreateManyTask_contextInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutTask_contextInput = {
    create?: XOR<TaskCreateWithoutTask_contextInput, TaskUncheckedCreateWithoutTask_contextInput> | TaskCreateWithoutTask_contextInput[] | TaskUncheckedCreateWithoutTask_contextInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTask_contextInput | TaskCreateOrConnectWithoutTask_contextInput[]
    createMany?: TaskCreateManyTask_contextInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUpdateManyWithoutTask_contextNestedInput = {
    create?: XOR<TaskCreateWithoutTask_contextInput, TaskUncheckedCreateWithoutTask_contextInput> | TaskCreateWithoutTask_contextInput[] | TaskUncheckedCreateWithoutTask_contextInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTask_contextInput | TaskCreateOrConnectWithoutTask_contextInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTask_contextInput | TaskUpsertWithWhereUniqueWithoutTask_contextInput[]
    createMany?: TaskCreateManyTask_contextInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTask_contextInput | TaskUpdateWithWhereUniqueWithoutTask_contextInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTask_contextInput | TaskUpdateManyWithWhereWithoutTask_contextInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutTask_contextNestedInput = {
    create?: XOR<TaskCreateWithoutTask_contextInput, TaskUncheckedCreateWithoutTask_contextInput> | TaskCreateWithoutTask_contextInput[] | TaskUncheckedCreateWithoutTask_contextInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTask_contextInput | TaskCreateOrConnectWithoutTask_contextInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTask_contextInput | TaskUpsertWithWhereUniqueWithoutTask_contextInput[]
    createMany?: TaskCreateManyTask_contextInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTask_contextInput | TaskUpdateWithWhereUniqueWithoutTask_contextInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTask_contextInput | TaskUpdateManyWithWhereWithoutTask_contextInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutTask_optionsInput = {
    create?: XOR<TaskCreateWithoutTask_optionsInput, TaskUncheckedCreateWithoutTask_optionsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTask_optionsInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutTask_optionsNestedInput = {
    create?: XOR<TaskCreateWithoutTask_optionsInput, TaskUncheckedCreateWithoutTask_optionsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutTask_optionsInput
    upsert?: TaskUpsertWithoutTask_optionsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutTask_optionsInput, TaskUpdateWithoutTask_optionsInput>, TaskUncheckedUpdateWithoutTask_optionsInput>
  }

  export type TaskCreateNestedManyWithoutTask_typeInput = {
    create?: XOR<TaskCreateWithoutTask_typeInput, TaskUncheckedCreateWithoutTask_typeInput> | TaskCreateWithoutTask_typeInput[] | TaskUncheckedCreateWithoutTask_typeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTask_typeInput | TaskCreateOrConnectWithoutTask_typeInput[]
    createMany?: TaskCreateManyTask_typeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutTask_typeInput = {
    create?: XOR<TaskCreateWithoutTask_typeInput, TaskUncheckedCreateWithoutTask_typeInput> | TaskCreateWithoutTask_typeInput[] | TaskUncheckedCreateWithoutTask_typeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTask_typeInput | TaskCreateOrConnectWithoutTask_typeInput[]
    createMany?: TaskCreateManyTask_typeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUpdateManyWithoutTask_typeNestedInput = {
    create?: XOR<TaskCreateWithoutTask_typeInput, TaskUncheckedCreateWithoutTask_typeInput> | TaskCreateWithoutTask_typeInput[] | TaskUncheckedCreateWithoutTask_typeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTask_typeInput | TaskCreateOrConnectWithoutTask_typeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTask_typeInput | TaskUpsertWithWhereUniqueWithoutTask_typeInput[]
    createMany?: TaskCreateManyTask_typeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTask_typeInput | TaskUpdateWithWhereUniqueWithoutTask_typeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTask_typeInput | TaskUpdateManyWithWhereWithoutTask_typeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutTask_typeNestedInput = {
    create?: XOR<TaskCreateWithoutTask_typeInput, TaskUncheckedCreateWithoutTask_typeInput> | TaskCreateWithoutTask_typeInput[] | TaskUncheckedCreateWithoutTask_typeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTask_typeInput | TaskCreateOrConnectWithoutTask_typeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTask_typeInput | TaskUpsertWithWhereUniqueWithoutTask_typeInput[]
    createMany?: TaskCreateManyTask_typeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTask_typeInput | TaskUpdateWithWhereUniqueWithoutTask_typeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTask_typeInput | TaskUpdateManyWithWhereWithoutTask_typeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumDataRemovalStatusEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRemovalStatusEnum | EnumDataRemovalStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DataRemovalStatusEnum[] | ListEnumDataRemovalStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataRemovalStatusEnum[] | ListEnumDataRemovalStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDataRemovalStatusEnumFilter<$PrismaModel> | $Enums.DataRemovalStatusEnum
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumDataRemovalStatusEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataRemovalStatusEnum | EnumDataRemovalStatusEnumFieldRefInput<$PrismaModel>
    in?: $Enums.DataRemovalStatusEnum[] | ListEnumDataRemovalStatusEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataRemovalStatusEnum[] | ListEnumDataRemovalStatusEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumDataRemovalStatusEnumWithAggregatesFilter<$PrismaModel> | $Enums.DataRemovalStatusEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataRemovalStatusEnumFilter<$PrismaModel>
    _max?: NestedEnumDataRemovalStatusEnumFilter<$PrismaModel>
  }

  export type NestedEnumClassSizesEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ClassSizesEnum | EnumClassSizesEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ClassSizesEnum[] | ListEnumClassSizesEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClassSizesEnum[] | ListEnumClassSizesEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumClassSizesEnumFilter<$PrismaModel> | $Enums.ClassSizesEnum
  }

  export type NestedEnumClassSizesEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClassSizesEnum | EnumClassSizesEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ClassSizesEnum[] | ListEnumClassSizesEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClassSizesEnum[] | ListEnumClassSizesEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumClassSizesEnumWithAggregatesFilter<$PrismaModel> | $Enums.ClassSizesEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClassSizesEnumFilter<$PrismaModel>
    _max?: NestedEnumClassSizesEnumFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumBookingRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingRequestStatus | EnumBookingRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingRequestStatus[] | ListEnumBookingRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingRequestStatus[] | ListEnumBookingRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingRequestStatusFilter<$PrismaModel> | $Enums.BookingRequestStatus
  }

  export type NestedEnumBookingRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingRequestStatus | EnumBookingRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingRequestStatus[] | ListEnumBookingRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingRequestStatus[] | ListEnumBookingRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumStudentTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentTaskStatus | EnumStudentTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentTaskStatus[] | ListEnumStudentTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentTaskStatus[] | ListEnumStudentTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentTaskStatusFilter<$PrismaModel> | $Enums.StudentTaskStatus
  }

  export type NestedEnumStudentTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StudentTaskStatus | EnumStudentTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StudentTaskStatus[] | ListEnumStudentTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StudentTaskStatus[] | ListEnumStudentTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStudentTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.StudentTaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStudentTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumStudentTaskStatusFilter<$PrismaModel>
  }

  export type UserRoleCreateWithoutUserInput = {
    role: RoleCreateNestedOneWithoutUser_rolesInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    role_id: string
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserApplicationPreferencesCreateWithoutUserInput = {
    accepted_privacy_policy: boolean
    accepted_cookies_policy: boolean
    application: ApplicationCreateNestedOneWithoutUser_application_preferencesInput
  }

  export type UserApplicationPreferencesUncheckedCreateWithoutUserInput = {
    application_id: string
    accepted_privacy_policy: boolean
    accepted_cookies_policy: boolean
  }

  export type UserApplicationPreferencesCreateOrConnectWithoutUserInput = {
    where: UserApplicationPreferencesWhereUniqueInput
    create: XOR<UserApplicationPreferencesCreateWithoutUserInput, UserApplicationPreferencesUncheckedCreateWithoutUserInput>
  }

  export type UserApplicationPreferencesCreateManyUserInputEnvelope = {
    data: UserApplicationPreferencesCreateManyUserInput | UserApplicationPreferencesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MentorCreateWithoutUserInput = {
    mentor_id: string
    mentor_description_en?: string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    mentor_classes?: MentorsClassesCreateNestedManyWithoutMentorInput
    MentorPayModel?: MentorPayModelCreateNestedManyWithoutMentorInput
  }

  export type MentorUncheckedCreateWithoutUserInput = {
    mentor_id: string
    mentor_description_en?: string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    mentor_classes?: MentorsClassesUncheckedCreateNestedManyWithoutMentorInput
    MentorPayModel?: MentorPayModelUncheckedCreateNestedManyWithoutMentorInput
  }

  export type MentorCreateOrConnectWithoutUserInput = {
    where: MentorWhereUniqueInput
    create: XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput>
  }

  export type MentorCreateManyUserInputEnvelope = {
    data: MentorCreateManyUserInput | MentorCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutUserInput = {
    student_id: string
    student_nickname?: string | null
    enrolled_date?: Date | string | null
    left_date?: Date | string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class: ClassCreateNestedOneWithoutStudentsInput
    student_task?: StudentTaskCreateNestedManyWithoutStudentInput
    student_answers?: StudentAnswerCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    student_id: string
    student_nickname?: string | null
    enrolled_date?: Date | string | null
    left_date?: Date | string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class_id: string
    student_task?: StudentTaskUncheckedCreateNestedManyWithoutStudentInput
    student_answers?: StudentAnswerUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type StudentCreateManyUserInputEnvelope = {
    data: StudentCreateManyUserInput | StudentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DataRemovalRequestCreateWithoutUserInput = {
    data_removal_request: string
    data_removal_status?: $Enums.DataRemovalStatusEnum
    data_removal_date: Date | string
  }

  export type DataRemovalRequestUncheckedCreateWithoutUserInput = {
    data_removal_request_id?: number
    data_removal_request: string
    data_removal_status?: $Enums.DataRemovalStatusEnum
    data_removal_date: Date | string
  }

  export type DataRemovalRequestCreateOrConnectWithoutUserInput = {
    where: DataRemovalRequestWhereUniqueInput
    create: XOR<DataRemovalRequestCreateWithoutUserInput, DataRemovalRequestUncheckedCreateWithoutUserInput>
  }

  export type DataRemovalRequestCreateManyUserInputEnvelope = {
    data: DataRemovalRequestCreateManyUserInput | DataRemovalRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DeckCreateWithoutUserInput = {
    deck_id: string
    deck_description?: string | null
    Card?: LessonCardCreateNestedManyWithoutDeckInput
  }

  export type DeckUncheckedCreateWithoutUserInput = {
    deck_id: string
    deck_description?: string | null
    Card?: LessonCardUncheckedCreateNestedManyWithoutDeckInput
  }

  export type DeckCreateOrConnectWithoutUserInput = {
    where: DeckWhereUniqueInput
    create: XOR<DeckCreateWithoutUserInput, DeckUncheckedCreateWithoutUserInput>
  }

  export type DeckCreateManyUserInputEnvelope = {
    data: DeckCreateManyUserInput | DeckCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserCardCreateWithoutUserInput = {
    user_card_id: string
    question: string
    answer: string
    example?: string | null
    lesson?: LessonCreateNestedOneWithoutUserCardInput
  }

  export type UserCardUncheckedCreateWithoutUserInput = {
    user_card_id: string
    question: string
    answer: string
    example?: string | null
    lesson_id?: number | null
  }

  export type UserCardCreateOrConnectWithoutUserInput = {
    where: UserCardWhereUniqueInput
    create: XOR<UserCardCreateWithoutUserInput, UserCardUncheckedCreateWithoutUserInput>
  }

  export type UserCardCreateManyUserInputEnvelope = {
    data: UserCardCreateManyUserInput | UserCardCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VocabularyInboxCreateWithoutUserInput = {
    question: string
    answer: string
  }

  export type VocabularyInboxUncheckedCreateWithoutUserInput = {
    question: string
    answer: string
  }

  export type VocabularyInboxCreateOrConnectWithoutUserInput = {
    where: VocabularyInboxWhereUniqueInput
    create: XOR<VocabularyInboxCreateWithoutUserInput, VocabularyInboxUncheckedCreateWithoutUserInput>
  }

  export type VocabularyInboxCreateManyUserInputEnvelope = {
    data: VocabularyInboxCreateManyUserInput | VocabularyInboxCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    user_email?: StringFilter<"UserRole"> | string
    role_id?: StringFilter<"UserRole"> | string
  }

  export type UserApplicationPreferencesUpsertWithWhereUniqueWithoutUserInput = {
    where: UserApplicationPreferencesWhereUniqueInput
    update: XOR<UserApplicationPreferencesUpdateWithoutUserInput, UserApplicationPreferencesUncheckedUpdateWithoutUserInput>
    create: XOR<UserApplicationPreferencesCreateWithoutUserInput, UserApplicationPreferencesUncheckedCreateWithoutUserInput>
  }

  export type UserApplicationPreferencesUpdateWithWhereUniqueWithoutUserInput = {
    where: UserApplicationPreferencesWhereUniqueInput
    data: XOR<UserApplicationPreferencesUpdateWithoutUserInput, UserApplicationPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserApplicationPreferencesUpdateManyWithWhereWithoutUserInput = {
    where: UserApplicationPreferencesScalarWhereInput
    data: XOR<UserApplicationPreferencesUpdateManyMutationInput, UserApplicationPreferencesUncheckedUpdateManyWithoutUserInput>
  }

  export type UserApplicationPreferencesScalarWhereInput = {
    AND?: UserApplicationPreferencesScalarWhereInput | UserApplicationPreferencesScalarWhereInput[]
    OR?: UserApplicationPreferencesScalarWhereInput[]
    NOT?: UserApplicationPreferencesScalarWhereInput | UserApplicationPreferencesScalarWhereInput[]
    user_email?: StringFilter<"UserApplicationPreferences"> | string
    application_id?: StringFilter<"UserApplicationPreferences"> | string
    accepted_privacy_policy?: BoolFilter<"UserApplicationPreferences"> | boolean
    accepted_cookies_policy?: BoolFilter<"UserApplicationPreferences"> | boolean
  }

  export type MentorUpsertWithWhereUniqueWithoutUserInput = {
    where: MentorWhereUniqueInput
    update: XOR<MentorUpdateWithoutUserInput, MentorUncheckedUpdateWithoutUserInput>
    create: XOR<MentorCreateWithoutUserInput, MentorUncheckedCreateWithoutUserInput>
  }

  export type MentorUpdateWithWhereUniqueWithoutUserInput = {
    where: MentorWhereUniqueInput
    data: XOR<MentorUpdateWithoutUserInput, MentorUncheckedUpdateWithoutUserInput>
  }

  export type MentorUpdateManyWithWhereWithoutUserInput = {
    where: MentorScalarWhereInput
    data: XOR<MentorUpdateManyMutationInput, MentorUncheckedUpdateManyWithoutUserInput>
  }

  export type MentorScalarWhereInput = {
    AND?: MentorScalarWhereInput | MentorScalarWhereInput[]
    OR?: MentorScalarWhereInput[]
    NOT?: MentorScalarWhereInput | MentorScalarWhereInput[]
    mentor_id?: StringFilter<"Mentor"> | string
    user_id?: StringFilter<"Mentor"> | string
    mentor_description_en?: StringNullableFilter<"Mentor"> | string | null
    created_date?: DateTimeNullableFilter<"Mentor"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Mentor"> | Date | string | null
    deleted?: BoolFilter<"Mentor"> | boolean
  }

  export type StudentUpsertWithWhereUniqueWithoutUserInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutUserInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateManyWithWhereWithoutUserInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutUserInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    student_id?: StringFilter<"Student"> | string
    user_id?: StringFilter<"Student"> | string
    student_nickname?: StringNullableFilter<"Student"> | string | null
    enrolled_date?: DateTimeNullableFilter<"Student"> | Date | string | null
    left_date?: DateTimeNullableFilter<"Student"> | Date | string | null
    created_date?: DateTimeNullableFilter<"Student"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Student"> | Date | string | null
    deleted?: BoolFilter<"Student"> | boolean
    class_id?: StringFilter<"Student"> | string
  }

  export type DataRemovalRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: DataRemovalRequestWhereUniqueInput
    update: XOR<DataRemovalRequestUpdateWithoutUserInput, DataRemovalRequestUncheckedUpdateWithoutUserInput>
    create: XOR<DataRemovalRequestCreateWithoutUserInput, DataRemovalRequestUncheckedCreateWithoutUserInput>
  }

  export type DataRemovalRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: DataRemovalRequestWhereUniqueInput
    data: XOR<DataRemovalRequestUpdateWithoutUserInput, DataRemovalRequestUncheckedUpdateWithoutUserInput>
  }

  export type DataRemovalRequestUpdateManyWithWhereWithoutUserInput = {
    where: DataRemovalRequestScalarWhereInput
    data: XOR<DataRemovalRequestUpdateManyMutationInput, DataRemovalRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type DataRemovalRequestScalarWhereInput = {
    AND?: DataRemovalRequestScalarWhereInput | DataRemovalRequestScalarWhereInput[]
    OR?: DataRemovalRequestScalarWhereInput[]
    NOT?: DataRemovalRequestScalarWhereInput | DataRemovalRequestScalarWhereInput[]
    data_removal_request_id?: IntFilter<"DataRemovalRequest"> | number
    user_email?: StringFilter<"DataRemovalRequest"> | string
    data_removal_request?: StringFilter<"DataRemovalRequest"> | string
    data_removal_status?: EnumDataRemovalStatusEnumFilter<"DataRemovalRequest"> | $Enums.DataRemovalStatusEnum
    data_removal_date?: DateTimeFilter<"DataRemovalRequest"> | Date | string
  }

  export type DeckUpsertWithWhereUniqueWithoutUserInput = {
    where: DeckWhereUniqueInput
    update: XOR<DeckUpdateWithoutUserInput, DeckUncheckedUpdateWithoutUserInput>
    create: XOR<DeckCreateWithoutUserInput, DeckUncheckedCreateWithoutUserInput>
  }

  export type DeckUpdateWithWhereUniqueWithoutUserInput = {
    where: DeckWhereUniqueInput
    data: XOR<DeckUpdateWithoutUserInput, DeckUncheckedUpdateWithoutUserInput>
  }

  export type DeckUpdateManyWithWhereWithoutUserInput = {
    where: DeckScalarWhereInput
    data: XOR<DeckUpdateManyMutationInput, DeckUncheckedUpdateManyWithoutUserInput>
  }

  export type DeckScalarWhereInput = {
    AND?: DeckScalarWhereInput | DeckScalarWhereInput[]
    OR?: DeckScalarWhereInput[]
    NOT?: DeckScalarWhereInput | DeckScalarWhereInput[]
    deck_id?: StringFilter<"Deck"> | string
    user_id?: StringFilter<"Deck"> | string
    deck_description?: StringNullableFilter<"Deck"> | string | null
  }

  export type UserCardUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCardWhereUniqueInput
    update: XOR<UserCardUpdateWithoutUserInput, UserCardUncheckedUpdateWithoutUserInput>
    create: XOR<UserCardCreateWithoutUserInput, UserCardUncheckedCreateWithoutUserInput>
  }

  export type UserCardUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCardWhereUniqueInput
    data: XOR<UserCardUpdateWithoutUserInput, UserCardUncheckedUpdateWithoutUserInput>
  }

  export type UserCardUpdateManyWithWhereWithoutUserInput = {
    where: UserCardScalarWhereInput
    data: XOR<UserCardUpdateManyMutationInput, UserCardUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCardScalarWhereInput = {
    AND?: UserCardScalarWhereInput | UserCardScalarWhereInput[]
    OR?: UserCardScalarWhereInput[]
    NOT?: UserCardScalarWhereInput | UserCardScalarWhereInput[]
    user_card_id?: StringFilter<"UserCard"> | string
    user_id?: StringFilter<"UserCard"> | string
    question?: StringFilter<"UserCard"> | string
    answer?: StringFilter<"UserCard"> | string
    example?: StringNullableFilter<"UserCard"> | string | null
    lesson_id?: IntNullableFilter<"UserCard"> | number | null
  }

  export type VocabularyInboxUpsertWithWhereUniqueWithoutUserInput = {
    where: VocabularyInboxWhereUniqueInput
    update: XOR<VocabularyInboxUpdateWithoutUserInput, VocabularyInboxUncheckedUpdateWithoutUserInput>
    create: XOR<VocabularyInboxCreateWithoutUserInput, VocabularyInboxUncheckedCreateWithoutUserInput>
  }

  export type VocabularyInboxUpdateWithWhereUniqueWithoutUserInput = {
    where: VocabularyInboxWhereUniqueInput
    data: XOR<VocabularyInboxUpdateWithoutUserInput, VocabularyInboxUncheckedUpdateWithoutUserInput>
  }

  export type VocabularyInboxUpdateManyWithWhereWithoutUserInput = {
    where: VocabularyInboxScalarWhereInput
    data: XOR<VocabularyInboxUpdateManyMutationInput, VocabularyInboxUncheckedUpdateManyWithoutUserInput>
  }

  export type VocabularyInboxScalarWhereInput = {
    AND?: VocabularyInboxScalarWhereInput | VocabularyInboxScalarWhereInput[]
    OR?: VocabularyInboxScalarWhereInput[]
    NOT?: VocabularyInboxScalarWhereInput | VocabularyInboxScalarWhereInput[]
    user_id?: StringFilter<"VocabularyInbox"> | string
    question?: StringFilter<"VocabularyInbox"> | string
    answer?: StringFilter<"VocabularyInbox"> | string
  }

  export type UserRoleCreateWithoutRoleInput = {
    user: UserCreateNestedOneWithoutUser_rolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    user_email: string
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserCreateWithoutUser_rolesInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_application_preferences?: UserApplicationPreferencesCreateNestedManyWithoutUserInput
    mentor?: MentorCreateNestedManyWithoutUserInput
    is_student_of?: StudentCreateNestedManyWithoutUserInput
    DataRemovalRequest?: DataRemovalRequestCreateNestedManyWithoutUserInput
    Deck?: DeckCreateNestedManyWithoutUserInput
    UserCard?: UserCardCreateNestedManyWithoutUserInput
    VocabularyInbox?: VocabularyInboxCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_rolesInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_application_preferences?: UserApplicationPreferencesUncheckedCreateNestedManyWithoutUserInput
    mentor?: MentorUncheckedCreateNestedManyWithoutUserInput
    is_student_of?: StudentUncheckedCreateNestedManyWithoutUserInput
    DataRemovalRequest?: DataRemovalRequestUncheckedCreateNestedManyWithoutUserInput
    Deck?: DeckUncheckedCreateNestedManyWithoutUserInput
    UserCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    VocabularyInbox?: VocabularyInboxUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_rolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_rolesInput, UserUncheckedCreateWithoutUser_rolesInput>
  }

  export type RoleCreateWithoutUser_rolesInput = {
    role_id: string
    role_name?: string | null
    role_description?: string | null
  }

  export type RoleUncheckedCreateWithoutUser_rolesInput = {
    role_id: string
    role_name?: string | null
    role_description?: string | null
  }

  export type RoleCreateOrConnectWithoutUser_rolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUser_rolesInput, RoleUncheckedCreateWithoutUser_rolesInput>
  }

  export type UserUpsertWithoutUser_rolesInput = {
    update: XOR<UserUpdateWithoutUser_rolesInput, UserUncheckedUpdateWithoutUser_rolesInput>
    create: XOR<UserCreateWithoutUser_rolesInput, UserUncheckedCreateWithoutUser_rolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_rolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_rolesInput, UserUncheckedUpdateWithoutUser_rolesInput>
  }

  export type UserUpdateWithoutUser_rolesInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_application_preferences?: UserApplicationPreferencesUpdateManyWithoutUserNestedInput
    mentor?: MentorUpdateManyWithoutUserNestedInput
    is_student_of?: StudentUpdateManyWithoutUserNestedInput
    DataRemovalRequest?: DataRemovalRequestUpdateManyWithoutUserNestedInput
    Deck?: DeckUpdateManyWithoutUserNestedInput
    UserCard?: UserCardUpdateManyWithoutUserNestedInput
    VocabularyInbox?: VocabularyInboxUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_rolesInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_application_preferences?: UserApplicationPreferencesUncheckedUpdateManyWithoutUserNestedInput
    mentor?: MentorUncheckedUpdateManyWithoutUserNestedInput
    is_student_of?: StudentUncheckedUpdateManyWithoutUserNestedInput
    DataRemovalRequest?: DataRemovalRequestUncheckedUpdateManyWithoutUserNestedInput
    Deck?: DeckUncheckedUpdateManyWithoutUserNestedInput
    UserCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    VocabularyInbox?: VocabularyInboxUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoleUpsertWithoutUser_rolesInput = {
    update: XOR<RoleUpdateWithoutUser_rolesInput, RoleUncheckedUpdateWithoutUser_rolesInput>
    create: XOR<RoleCreateWithoutUser_rolesInput, RoleUncheckedCreateWithoutUser_rolesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUser_rolesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUser_rolesInput, RoleUncheckedUpdateWithoutUser_rolesInput>
  }

  export type RoleUpdateWithoutUser_rolesInput = {
    role_id?: StringFieldUpdateOperationsInput | string
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    role_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoleUncheckedUpdateWithoutUser_rolesInput = {
    role_id?: StringFieldUpdateOperationsInput | string
    role_name?: NullableStringFieldUpdateOperationsInput | string | null
    role_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutUser_application_preferencesInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_roles?: UserRoleCreateNestedManyWithoutUserInput
    mentor?: MentorCreateNestedManyWithoutUserInput
    is_student_of?: StudentCreateNestedManyWithoutUserInput
    DataRemovalRequest?: DataRemovalRequestCreateNestedManyWithoutUserInput
    Deck?: DeckCreateNestedManyWithoutUserInput
    UserCard?: UserCardCreateNestedManyWithoutUserInput
    VocabularyInbox?: VocabularyInboxCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_application_preferencesInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    mentor?: MentorUncheckedCreateNestedManyWithoutUserInput
    is_student_of?: StudentUncheckedCreateNestedManyWithoutUserInput
    DataRemovalRequest?: DataRemovalRequestUncheckedCreateNestedManyWithoutUserInput
    Deck?: DeckUncheckedCreateNestedManyWithoutUserInput
    UserCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    VocabularyInbox?: VocabularyInboxUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_application_preferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_application_preferencesInput, UserUncheckedCreateWithoutUser_application_preferencesInput>
  }

  export type ApplicationCreateWithoutUser_application_preferencesInput = {
    application_id: string
    application_name: string
    application_description?: string | null
    application_url?: string | null
  }

  export type ApplicationUncheckedCreateWithoutUser_application_preferencesInput = {
    application_id: string
    application_name: string
    application_description?: string | null
    application_url?: string | null
  }

  export type ApplicationCreateOrConnectWithoutUser_application_preferencesInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutUser_application_preferencesInput, ApplicationUncheckedCreateWithoutUser_application_preferencesInput>
  }

  export type UserUpsertWithoutUser_application_preferencesInput = {
    update: XOR<UserUpdateWithoutUser_application_preferencesInput, UserUncheckedUpdateWithoutUser_application_preferencesInput>
    create: XOR<UserCreateWithoutUser_application_preferencesInput, UserUncheckedCreateWithoutUser_application_preferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_application_preferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_application_preferencesInput, UserUncheckedUpdateWithoutUser_application_preferencesInput>
  }

  export type UserUpdateWithoutUser_application_preferencesInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_roles?: UserRoleUpdateManyWithoutUserNestedInput
    mentor?: MentorUpdateManyWithoutUserNestedInput
    is_student_of?: StudentUpdateManyWithoutUserNestedInput
    DataRemovalRequest?: DataRemovalRequestUpdateManyWithoutUserNestedInput
    Deck?: DeckUpdateManyWithoutUserNestedInput
    UserCard?: UserCardUpdateManyWithoutUserNestedInput
    VocabularyInbox?: VocabularyInboxUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_application_preferencesInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    mentor?: MentorUncheckedUpdateManyWithoutUserNestedInput
    is_student_of?: StudentUncheckedUpdateManyWithoutUserNestedInput
    DataRemovalRequest?: DataRemovalRequestUncheckedUpdateManyWithoutUserNestedInput
    Deck?: DeckUncheckedUpdateManyWithoutUserNestedInput
    UserCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    VocabularyInbox?: VocabularyInboxUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ApplicationUpsertWithoutUser_application_preferencesInput = {
    update: XOR<ApplicationUpdateWithoutUser_application_preferencesInput, ApplicationUncheckedUpdateWithoutUser_application_preferencesInput>
    create: XOR<ApplicationCreateWithoutUser_application_preferencesInput, ApplicationUncheckedCreateWithoutUser_application_preferencesInput>
    where?: ApplicationWhereInput
  }

  export type ApplicationUpdateToOneWithWhereWithoutUser_application_preferencesInput = {
    where?: ApplicationWhereInput
    data: XOR<ApplicationUpdateWithoutUser_application_preferencesInput, ApplicationUncheckedUpdateWithoutUser_application_preferencesInput>
  }

  export type ApplicationUpdateWithoutUser_application_preferencesInput = {
    application_id?: StringFieldUpdateOperationsInput | string
    application_name?: StringFieldUpdateOperationsInput | string
    application_description?: NullableStringFieldUpdateOperationsInput | string | null
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApplicationUncheckedUpdateWithoutUser_application_preferencesInput = {
    application_id?: StringFieldUpdateOperationsInput | string
    application_name?: StringFieldUpdateOperationsInput | string
    application_description?: NullableStringFieldUpdateOperationsInput | string | null
    application_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserApplicationPreferencesCreateWithoutApplicationInput = {
    accepted_privacy_policy: boolean
    accepted_cookies_policy: boolean
    user: UserCreateNestedOneWithoutUser_application_preferencesInput
  }

  export type UserApplicationPreferencesUncheckedCreateWithoutApplicationInput = {
    user_email: string
    accepted_privacy_policy: boolean
    accepted_cookies_policy: boolean
  }

  export type UserApplicationPreferencesCreateOrConnectWithoutApplicationInput = {
    where: UserApplicationPreferencesWhereUniqueInput
    create: XOR<UserApplicationPreferencesCreateWithoutApplicationInput, UserApplicationPreferencesUncheckedCreateWithoutApplicationInput>
  }

  export type UserApplicationPreferencesCreateManyApplicationInputEnvelope = {
    data: UserApplicationPreferencesCreateManyApplicationInput | UserApplicationPreferencesCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type UserApplicationPreferencesUpsertWithWhereUniqueWithoutApplicationInput = {
    where: UserApplicationPreferencesWhereUniqueInput
    update: XOR<UserApplicationPreferencesUpdateWithoutApplicationInput, UserApplicationPreferencesUncheckedUpdateWithoutApplicationInput>
    create: XOR<UserApplicationPreferencesCreateWithoutApplicationInput, UserApplicationPreferencesUncheckedCreateWithoutApplicationInput>
  }

  export type UserApplicationPreferencesUpdateWithWhereUniqueWithoutApplicationInput = {
    where: UserApplicationPreferencesWhereUniqueInput
    data: XOR<UserApplicationPreferencesUpdateWithoutApplicationInput, UserApplicationPreferencesUncheckedUpdateWithoutApplicationInput>
  }

  export type UserApplicationPreferencesUpdateManyWithWhereWithoutApplicationInput = {
    where: UserApplicationPreferencesScalarWhereInput
    data: XOR<UserApplicationPreferencesUpdateManyMutationInput, UserApplicationPreferencesUncheckedUpdateManyWithoutApplicationInput>
  }

  export type UserCreateWithoutDataRemovalRequestInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_roles?: UserRoleCreateNestedManyWithoutUserInput
    user_application_preferences?: UserApplicationPreferencesCreateNestedManyWithoutUserInput
    mentor?: MentorCreateNestedManyWithoutUserInput
    is_student_of?: StudentCreateNestedManyWithoutUserInput
    Deck?: DeckCreateNestedManyWithoutUserInput
    UserCard?: UserCardCreateNestedManyWithoutUserInput
    VocabularyInbox?: VocabularyInboxCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDataRemovalRequestInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    user_application_preferences?: UserApplicationPreferencesUncheckedCreateNestedManyWithoutUserInput
    mentor?: MentorUncheckedCreateNestedManyWithoutUserInput
    is_student_of?: StudentUncheckedCreateNestedManyWithoutUserInput
    Deck?: DeckUncheckedCreateNestedManyWithoutUserInput
    UserCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    VocabularyInbox?: VocabularyInboxUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDataRemovalRequestInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDataRemovalRequestInput, UserUncheckedCreateWithoutDataRemovalRequestInput>
  }

  export type UserUpsertWithoutDataRemovalRequestInput = {
    update: XOR<UserUpdateWithoutDataRemovalRequestInput, UserUncheckedUpdateWithoutDataRemovalRequestInput>
    create: XOR<UserCreateWithoutDataRemovalRequestInput, UserUncheckedCreateWithoutDataRemovalRequestInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDataRemovalRequestInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDataRemovalRequestInput, UserUncheckedUpdateWithoutDataRemovalRequestInput>
  }

  export type UserUpdateWithoutDataRemovalRequestInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_roles?: UserRoleUpdateManyWithoutUserNestedInput
    user_application_preferences?: UserApplicationPreferencesUpdateManyWithoutUserNestedInput
    mentor?: MentorUpdateManyWithoutUserNestedInput
    is_student_of?: StudentUpdateManyWithoutUserNestedInput
    Deck?: DeckUpdateManyWithoutUserNestedInput
    UserCard?: UserCardUpdateManyWithoutUserNestedInput
    VocabularyInbox?: VocabularyInboxUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDataRemovalRequestInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    user_application_preferences?: UserApplicationPreferencesUncheckedUpdateManyWithoutUserNestedInput
    mentor?: MentorUncheckedUpdateManyWithoutUserNestedInput
    is_student_of?: StudentUncheckedUpdateManyWithoutUserNestedInput
    Deck?: DeckUncheckedUpdateManyWithoutUserNestedInput
    UserCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    VocabularyInbox?: VocabularyInboxUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassCallCreateWithoutMeeting_kindInput = {
    class_call_id: string
    call_date: Date | string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class: ClassCreateNestedOneWithoutClass_callsInput
  }

  export type ClassCallUncheckedCreateWithoutMeeting_kindInput = {
    class_call_id: string
    class_id: string
    call_date: Date | string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
  }

  export type ClassCallCreateOrConnectWithoutMeeting_kindInput = {
    where: ClassCallWhereUniqueInput
    create: XOR<ClassCallCreateWithoutMeeting_kindInput, ClassCallUncheckedCreateWithoutMeeting_kindInput>
  }

  export type ClassCallCreateManyMeeting_kindInputEnvelope = {
    data: ClassCallCreateManyMeeting_kindInput | ClassCallCreateManyMeeting_kindInput[]
    skipDuplicates?: boolean
  }

  export type ClassCallUpsertWithWhereUniqueWithoutMeeting_kindInput = {
    where: ClassCallWhereUniqueInput
    update: XOR<ClassCallUpdateWithoutMeeting_kindInput, ClassCallUncheckedUpdateWithoutMeeting_kindInput>
    create: XOR<ClassCallCreateWithoutMeeting_kindInput, ClassCallUncheckedCreateWithoutMeeting_kindInput>
  }

  export type ClassCallUpdateWithWhereUniqueWithoutMeeting_kindInput = {
    where: ClassCallWhereUniqueInput
    data: XOR<ClassCallUpdateWithoutMeeting_kindInput, ClassCallUncheckedUpdateWithoutMeeting_kindInput>
  }

  export type ClassCallUpdateManyWithWhereWithoutMeeting_kindInput = {
    where: ClassCallScalarWhereInput
    data: XOR<ClassCallUpdateManyMutationInput, ClassCallUncheckedUpdateManyWithoutMeeting_kindInput>
  }

  export type ClassCallScalarWhereInput = {
    AND?: ClassCallScalarWhereInput | ClassCallScalarWhereInput[]
    OR?: ClassCallScalarWhereInput[]
    NOT?: ClassCallScalarWhereInput | ClassCallScalarWhereInput[]
    class_call_id?: StringFilter<"ClassCall"> | string
    class_id?: StringFilter<"ClassCall"> | string
    call_date?: DateTimeFilter<"ClassCall"> | Date | string
    created_date?: DateTimeNullableFilter<"ClassCall"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"ClassCall"> | Date | string | null
    deleted?: BoolFilter<"ClassCall"> | boolean
    meeting_kind_id?: StringFilter<"ClassCall"> | string
  }

  export type CourseCreateWithoutCourseStructureInput = {
    course_code: string
    course_name?: string | null
    created_date?: Date | string | null
    course_level: CourseLevelCreateNestedOneWithoutCourseInput
    course_advice?: CourseAdviceCreateNestedManyWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutIs_instance_of_courseInput
    subject?: SubjectCreateNestedOneWithoutCourseInput
    CourseTask?: CourseTaskCreateNestedManyWithoutCourseInput
    Module?: ModuleCreateNestedManyWithoutCourseInput
    LessonCard?: LessonCardCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCourseStructureInput = {
    course_code: string
    course_name?: string | null
    course_level_id: string
    created_date?: Date | string | null
    subject_code: string
    course_advice?: CourseAdviceUncheckedCreateNestedManyWithoutCourseInput
    classes?: ClassUncheckedCreateNestedManyWithoutIs_instance_of_courseInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutCourseInput
    Module?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    LessonCard?: LessonCardUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCourseStructureInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCourseStructureInput, CourseUncheckedCreateWithoutCourseStructureInput>
  }

  export type ModuleCreateWithoutCourseStructureInput = {
    module_name: string
    module_description?: string | null
    module_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    course: CourseCreateNestedOneWithoutModuleInput
    sections?: SectionCreateNestedManyWithoutModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
    CourseTask?: CourseTaskCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutCourseStructureInput = {
    module_id?: number
    module_name: string
    module_description?: string | null
    module_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    course_id: string
    sections?: SectionUncheckedCreateNestedManyWithoutModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutCourseStructureInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutCourseStructureInput, ModuleUncheckedCreateWithoutCourseStructureInput>
  }

  export type SectionCreateWithoutCourseStructureInput = {
    section_name: string
    section_description?: string | null
    section_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    module: ModuleCreateNestedOneWithoutSectionsInput
    CourseTask?: CourseTaskCreateNestedManyWithoutSectionInput
    Lesson?: LessonCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutCourseStructureInput = {
    section_id?: number
    section_name: string
    section_description?: string | null
    section_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    module_id: number
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutSectionInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutCourseStructureInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutCourseStructureInput, SectionUncheckedCreateWithoutCourseStructureInput>
  }

  export type LessonCreateWithoutCourseStructureInput = {
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    section: SectionCreateNestedOneWithoutLessonInput
    tasks?: TaskCreateNestedManyWithoutLessonInput
    CourseTask?: CourseTaskCreateNestedManyWithoutLessonInput
    Module?: ModuleCreateNestedOneWithoutLessonsInput
    LessonCard?: LessonCardCreateNestedManyWithoutLessonInput
    UserCard?: UserCardCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutCourseStructureInput = {
    lesson_id?: number
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    section_id: number
    moduleModule_id?: number | null
    tasks?: TaskUncheckedCreateNestedManyWithoutLessonInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutLessonInput
    LessonCard?: LessonCardUncheckedCreateNestedManyWithoutLessonInput
    UserCard?: UserCardUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutCourseStructureInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutCourseStructureInput, LessonUncheckedCreateWithoutCourseStructureInput>
  }

  export type CourseUpsertWithoutCourseStructureInput = {
    update: XOR<CourseUpdateWithoutCourseStructureInput, CourseUncheckedUpdateWithoutCourseStructureInput>
    create: XOR<CourseCreateWithoutCourseStructureInput, CourseUncheckedCreateWithoutCourseStructureInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCourseStructureInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCourseStructureInput, CourseUncheckedUpdateWithoutCourseStructureInput>
  }

  export type CourseUpdateWithoutCourseStructureInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_level?: CourseLevelUpdateOneRequiredWithoutCourseNestedInput
    course_advice?: CourseAdviceUpdateManyWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutIs_instance_of_courseNestedInput
    subject?: SubjectUpdateOneWithoutCourseNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutCourseNestedInput
    Module?: ModuleUpdateManyWithoutCourseNestedInput
    LessonCard?: LessonCardUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCourseStructureInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    course_level_id?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject_code?: StringFieldUpdateOperationsInput | string
    course_advice?: CourseAdviceUncheckedUpdateManyWithoutCourseNestedInput
    classes?: ClassUncheckedUpdateManyWithoutIs_instance_of_courseNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutCourseNestedInput
    Module?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    LessonCard?: LessonCardUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ModuleUpsertWithoutCourseStructureInput = {
    update: XOR<ModuleUpdateWithoutCourseStructureInput, ModuleUncheckedUpdateWithoutCourseStructureInput>
    create: XOR<ModuleCreateWithoutCourseStructureInput, ModuleUncheckedCreateWithoutCourseStructureInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutCourseStructureInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutCourseStructureInput, ModuleUncheckedUpdateWithoutCourseStructureInput>
  }

  export type ModuleUpdateWithoutCourseStructureInput = {
    module_name?: StringFieldUpdateOperationsInput | string
    module_description?: NullableStringFieldUpdateOperationsInput | string | null
    module_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneRequiredWithoutModuleNestedInput
    sections?: SectionUpdateManyWithoutModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutCourseStructureInput = {
    module_id?: IntFieldUpdateOperationsInput | number
    module_name?: StringFieldUpdateOperationsInput | string
    module_description?: NullableStringFieldUpdateOperationsInput | string | null
    module_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    course_id?: StringFieldUpdateOperationsInput | string
    sections?: SectionUncheckedUpdateManyWithoutModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type SectionUpsertWithoutCourseStructureInput = {
    update: XOR<SectionUpdateWithoutCourseStructureInput, SectionUncheckedUpdateWithoutCourseStructureInput>
    create: XOR<SectionCreateWithoutCourseStructureInput, SectionUncheckedCreateWithoutCourseStructureInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutCourseStructureInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutCourseStructureInput, SectionUncheckedUpdateWithoutCourseStructureInput>
  }

  export type SectionUpdateWithoutCourseStructureInput = {
    section_name?: StringFieldUpdateOperationsInput | string
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    section_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    module?: ModuleUpdateOneRequiredWithoutSectionsNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutSectionNestedInput
    Lesson?: LessonUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutCourseStructureInput = {
    section_id?: IntFieldUpdateOperationsInput | number
    section_name?: StringFieldUpdateOperationsInput | string
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    section_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    module_id?: IntFieldUpdateOperationsInput | number
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutSectionNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type LessonUpsertWithoutCourseStructureInput = {
    update: XOR<LessonUpdateWithoutCourseStructureInput, LessonUncheckedUpdateWithoutCourseStructureInput>
    create: XOR<LessonCreateWithoutCourseStructureInput, LessonUncheckedCreateWithoutCourseStructureInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutCourseStructureInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutCourseStructureInput, LessonUncheckedUpdateWithoutCourseStructureInput>
  }

  export type LessonUpdateWithoutCourseStructureInput = {
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    section?: SectionUpdateOneRequiredWithoutLessonNestedInput
    tasks?: TaskUpdateManyWithoutLessonNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutLessonNestedInput
    Module?: ModuleUpdateOneWithoutLessonsNestedInput
    LessonCard?: LessonCardUpdateManyWithoutLessonNestedInput
    UserCard?: UserCardUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutCourseStructureInput = {
    lesson_id?: IntFieldUpdateOperationsInput | number
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    section_id?: IntFieldUpdateOperationsInput | number
    moduleModule_id?: NullableIntFieldUpdateOperationsInput | number | null
    tasks?: TaskUncheckedUpdateManyWithoutLessonNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutLessonNestedInput
    LessonCard?: LessonCardUncheckedUpdateManyWithoutLessonNestedInput
    UserCard?: UserCardUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type ClassSizeCreateWithoutClassesInput = {
    class_size_id: string
    class_size_name: $Enums.ClassSizesEnum
    MentorPayModel?: MentorPayModelCreateNestedManyWithoutClass_sizeInput
  }

  export type ClassSizeUncheckedCreateWithoutClassesInput = {
    class_size_id: string
    class_size_name: $Enums.ClassSizesEnum
    MentorPayModel?: MentorPayModelUncheckedCreateNestedManyWithoutClass_sizeInput
  }

  export type ClassSizeCreateOrConnectWithoutClassesInput = {
    where: ClassSizeWhereUniqueInput
    create: XOR<ClassSizeCreateWithoutClassesInput, ClassSizeUncheckedCreateWithoutClassesInput>
  }

  export type CourseCreateWithoutClassesInput = {
    course_code: string
    course_name?: string | null
    created_date?: Date | string | null
    course_level: CourseLevelCreateNestedOneWithoutCourseInput
    course_advice?: CourseAdviceCreateNestedManyWithoutCourseInput
    subject?: SubjectCreateNestedOneWithoutCourseInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutCourseInput
    CourseTask?: CourseTaskCreateNestedManyWithoutCourseInput
    Module?: ModuleCreateNestedManyWithoutCourseInput
    LessonCard?: LessonCardCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutClassesInput = {
    course_code: string
    course_name?: string | null
    course_level_id: string
    created_date?: Date | string | null
    subject_code: string
    course_advice?: CourseAdviceUncheckedCreateNestedManyWithoutCourseInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutCourseInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutCourseInput
    Module?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    LessonCard?: LessonCardUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutClassesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutClassesInput, CourseUncheckedCreateWithoutClassesInput>
  }

  export type TimeOfDayCreateWithoutClassesInput = {
    time_of_day_id?: string
    time_of_day_name: string
  }

  export type TimeOfDayUncheckedCreateWithoutClassesInput = {
    time_of_day_id?: string
    time_of_day_name: string
  }

  export type TimeOfDayCreateOrConnectWithoutClassesInput = {
    where: TimeOfDayWhereUniqueInput
    create: XOR<TimeOfDayCreateWithoutClassesInput, TimeOfDayUncheckedCreateWithoutClassesInput>
  }

  export type TuitionLangCreateWithoutClassesInput = {
    tuition_lang_code?: string
    tuition_lang_name: string
  }

  export type TuitionLangUncheckedCreateWithoutClassesInput = {
    tuition_lang_code?: string
    tuition_lang_name: string
  }

  export type TuitionLangCreateOrConnectWithoutClassesInput = {
    where: TuitionLangWhereUniqueInput
    create: XOR<TuitionLangCreateWithoutClassesInput, TuitionLangUncheckedCreateWithoutClassesInput>
  }

  export type MentorsClassesCreateWithoutClassInput = {
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    mentor: MentorCreateNestedOneWithoutMentor_classesInput
  }

  export type MentorsClassesUncheckedCreateWithoutClassInput = {
    mentor_id: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
  }

  export type MentorsClassesCreateOrConnectWithoutClassInput = {
    where: MentorsClassesWhereUniqueInput
    create: XOR<MentorsClassesCreateWithoutClassInput, MentorsClassesUncheckedCreateWithoutClassInput>
  }

  export type MentorsClassesCreateManyClassInputEnvelope = {
    data: MentorsClassesCreateManyClassInput | MentorsClassesCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutClassInput = {
    student_id: string
    student_nickname?: string | null
    enrolled_date?: Date | string | null
    left_date?: Date | string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    user: UserCreateNestedOneWithoutIs_student_ofInput
    student_task?: StudentTaskCreateNestedManyWithoutStudentInput
    student_answers?: StudentAnswerCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutClassInput = {
    student_id: string
    user_id: string
    student_nickname?: string | null
    enrolled_date?: Date | string | null
    left_date?: Date | string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    student_task?: StudentTaskUncheckedCreateNestedManyWithoutStudentInput
    student_answers?: StudentAnswerUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutClassInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput>
  }

  export type StudentCreateManyClassInputEnvelope = {
    data: StudentCreateManyClassInput | StudentCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type BookingRequestCreateWithoutClassInput = {
    booking_request_id: string
    booking_date: Date | string
    booking_request_status?: $Enums.BookingRequestStatus
    user_stated_name?: string | null
    user_stated_phone?: string | null
    user_stated_email?: string | null
    user_stated_telegram_nickname?: string | null
  }

  export type BookingRequestUncheckedCreateWithoutClassInput = {
    booking_request_id: string
    booking_date: Date | string
    booking_request_status?: $Enums.BookingRequestStatus
    user_stated_name?: string | null
    user_stated_phone?: string | null
    user_stated_email?: string | null
    user_stated_telegram_nickname?: string | null
  }

  export type BookingRequestCreateOrConnectWithoutClassInput = {
    where: BookingRequestWhereUniqueInput
    create: XOR<BookingRequestCreateWithoutClassInput, BookingRequestUncheckedCreateWithoutClassInput>
  }

  export type BookingRequestCreateManyClassInputEnvelope = {
    data: BookingRequestCreateManyClassInput | BookingRequestCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ClassCallCreateWithoutClassInput = {
    class_call_id: string
    call_date: Date | string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    meeting_kind: MeetingKindCreateNestedOneWithoutClass_callsInput
  }

  export type ClassCallUncheckedCreateWithoutClassInput = {
    class_call_id: string
    call_date: Date | string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    meeting_kind_id: string
  }

  export type ClassCallCreateOrConnectWithoutClassInput = {
    where: ClassCallWhereUniqueInput
    create: XOR<ClassCallCreateWithoutClassInput, ClassCallUncheckedCreateWithoutClassInput>
  }

  export type ClassCallCreateManyClassInputEnvelope = {
    data: ClassCallCreateManyClassInput | ClassCallCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ClassTaskCreateWithoutClassInput = {
    course_task: CourseTaskCreateNestedOneWithoutClassTaskInput
    student_tasks?: StudentTaskCreateNestedManyWithoutClass_taskInput
    student_answer?: StudentAnswerCreateNestedManyWithoutClass_taskInput
  }

  export type ClassTaskUncheckedCreateWithoutClassInput = {
    class_task_id?: number
    course_task_id: string
    student_tasks?: StudentTaskUncheckedCreateNestedManyWithoutClass_taskInput
    student_answer?: StudentAnswerUncheckedCreateNestedManyWithoutClass_taskInput
  }

  export type ClassTaskCreateOrConnectWithoutClassInput = {
    where: ClassTaskWhereUniqueInput
    create: XOR<ClassTaskCreateWithoutClassInput, ClassTaskUncheckedCreateWithoutClassInput>
  }

  export type ClassTaskCreateManyClassInputEnvelope = {
    data: ClassTaskCreateManyClassInput | ClassTaskCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ClassSizeUpsertWithoutClassesInput = {
    update: XOR<ClassSizeUpdateWithoutClassesInput, ClassSizeUncheckedUpdateWithoutClassesInput>
    create: XOR<ClassSizeCreateWithoutClassesInput, ClassSizeUncheckedCreateWithoutClassesInput>
    where?: ClassSizeWhereInput
  }

  export type ClassSizeUpdateToOneWithWhereWithoutClassesInput = {
    where?: ClassSizeWhereInput
    data: XOR<ClassSizeUpdateWithoutClassesInput, ClassSizeUncheckedUpdateWithoutClassesInput>
  }

  export type ClassSizeUpdateWithoutClassesInput = {
    class_size_id?: StringFieldUpdateOperationsInput | string
    class_size_name?: EnumClassSizesEnumFieldUpdateOperationsInput | $Enums.ClassSizesEnum
    MentorPayModel?: MentorPayModelUpdateManyWithoutClass_sizeNestedInput
  }

  export type ClassSizeUncheckedUpdateWithoutClassesInput = {
    class_size_id?: StringFieldUpdateOperationsInput | string
    class_size_name?: EnumClassSizesEnumFieldUpdateOperationsInput | $Enums.ClassSizesEnum
    MentorPayModel?: MentorPayModelUncheckedUpdateManyWithoutClass_sizeNestedInput
  }

  export type CourseUpsertWithoutClassesInput = {
    update: XOR<CourseUpdateWithoutClassesInput, CourseUncheckedUpdateWithoutClassesInput>
    create: XOR<CourseCreateWithoutClassesInput, CourseUncheckedCreateWithoutClassesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutClassesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutClassesInput, CourseUncheckedUpdateWithoutClassesInput>
  }

  export type CourseUpdateWithoutClassesInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_level?: CourseLevelUpdateOneRequiredWithoutCourseNestedInput
    course_advice?: CourseAdviceUpdateManyWithoutCourseNestedInput
    subject?: SubjectUpdateOneWithoutCourseNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutCourseNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutCourseNestedInput
    Module?: ModuleUpdateManyWithoutCourseNestedInput
    LessonCard?: LessonCardUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutClassesInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    course_level_id?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject_code?: StringFieldUpdateOperationsInput | string
    course_advice?: CourseAdviceUncheckedUpdateManyWithoutCourseNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutCourseNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutCourseNestedInput
    Module?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    LessonCard?: LessonCardUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type TimeOfDayUpsertWithoutClassesInput = {
    update: XOR<TimeOfDayUpdateWithoutClassesInput, TimeOfDayUncheckedUpdateWithoutClassesInput>
    create: XOR<TimeOfDayCreateWithoutClassesInput, TimeOfDayUncheckedCreateWithoutClassesInput>
    where?: TimeOfDayWhereInput
  }

  export type TimeOfDayUpdateToOneWithWhereWithoutClassesInput = {
    where?: TimeOfDayWhereInput
    data: XOR<TimeOfDayUpdateWithoutClassesInput, TimeOfDayUncheckedUpdateWithoutClassesInput>
  }

  export type TimeOfDayUpdateWithoutClassesInput = {
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    time_of_day_name?: StringFieldUpdateOperationsInput | string
  }

  export type TimeOfDayUncheckedUpdateWithoutClassesInput = {
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    time_of_day_name?: StringFieldUpdateOperationsInput | string
  }

  export type TuitionLangUpsertWithoutClassesInput = {
    update: XOR<TuitionLangUpdateWithoutClassesInput, TuitionLangUncheckedUpdateWithoutClassesInput>
    create: XOR<TuitionLangCreateWithoutClassesInput, TuitionLangUncheckedCreateWithoutClassesInput>
    where?: TuitionLangWhereInput
  }

  export type TuitionLangUpdateToOneWithWhereWithoutClassesInput = {
    where?: TuitionLangWhereInput
    data: XOR<TuitionLangUpdateWithoutClassesInput, TuitionLangUncheckedUpdateWithoutClassesInput>
  }

  export type TuitionLangUpdateWithoutClassesInput = {
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    tuition_lang_name?: StringFieldUpdateOperationsInput | string
  }

  export type TuitionLangUncheckedUpdateWithoutClassesInput = {
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    tuition_lang_name?: StringFieldUpdateOperationsInput | string
  }

  export type MentorsClassesUpsertWithWhereUniqueWithoutClassInput = {
    where: MentorsClassesWhereUniqueInput
    update: XOR<MentorsClassesUpdateWithoutClassInput, MentorsClassesUncheckedUpdateWithoutClassInput>
    create: XOR<MentorsClassesCreateWithoutClassInput, MentorsClassesUncheckedCreateWithoutClassInput>
  }

  export type MentorsClassesUpdateWithWhereUniqueWithoutClassInput = {
    where: MentorsClassesWhereUniqueInput
    data: XOR<MentorsClassesUpdateWithoutClassInput, MentorsClassesUncheckedUpdateWithoutClassInput>
  }

  export type MentorsClassesUpdateManyWithWhereWithoutClassInput = {
    where: MentorsClassesScalarWhereInput
    data: XOR<MentorsClassesUpdateManyMutationInput, MentorsClassesUncheckedUpdateManyWithoutClassInput>
  }

  export type MentorsClassesScalarWhereInput = {
    AND?: MentorsClassesScalarWhereInput | MentorsClassesScalarWhereInput[]
    OR?: MentorsClassesScalarWhereInput[]
    NOT?: MentorsClassesScalarWhereInput | MentorsClassesScalarWhereInput[]
    mentor_id?: StringFilter<"MentorsClasses"> | string
    class_id?: StringFilter<"MentorsClasses"> | string
    created_date?: DateTimeNullableFilter<"MentorsClasses"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"MentorsClasses"> | Date | string | null
    deleted?: BoolFilter<"MentorsClasses"> | boolean
  }

  export type StudentUpsertWithWhereUniqueWithoutClassInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutClassInput, StudentUncheckedUpdateWithoutClassInput>
    create: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutClassInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutClassInput, StudentUncheckedUpdateWithoutClassInput>
  }

  export type StudentUpdateManyWithWhereWithoutClassInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutClassInput>
  }

  export type BookingRequestUpsertWithWhereUniqueWithoutClassInput = {
    where: BookingRequestWhereUniqueInput
    update: XOR<BookingRequestUpdateWithoutClassInput, BookingRequestUncheckedUpdateWithoutClassInput>
    create: XOR<BookingRequestCreateWithoutClassInput, BookingRequestUncheckedCreateWithoutClassInput>
  }

  export type BookingRequestUpdateWithWhereUniqueWithoutClassInput = {
    where: BookingRequestWhereUniqueInput
    data: XOR<BookingRequestUpdateWithoutClassInput, BookingRequestUncheckedUpdateWithoutClassInput>
  }

  export type BookingRequestUpdateManyWithWhereWithoutClassInput = {
    where: BookingRequestScalarWhereInput
    data: XOR<BookingRequestUpdateManyMutationInput, BookingRequestUncheckedUpdateManyWithoutClassInput>
  }

  export type BookingRequestScalarWhereInput = {
    AND?: BookingRequestScalarWhereInput | BookingRequestScalarWhereInput[]
    OR?: BookingRequestScalarWhereInput[]
    NOT?: BookingRequestScalarWhereInput | BookingRequestScalarWhereInput[]
    booking_request_id?: StringFilter<"BookingRequest"> | string
    class_id?: StringFilter<"BookingRequest"> | string
    booking_date?: DateTimeFilter<"BookingRequest"> | Date | string
    booking_request_status?: EnumBookingRequestStatusFilter<"BookingRequest"> | $Enums.BookingRequestStatus
    user_stated_name?: StringNullableFilter<"BookingRequest"> | string | null
    user_stated_phone?: StringNullableFilter<"BookingRequest"> | string | null
    user_stated_email?: StringNullableFilter<"BookingRequest"> | string | null
    user_stated_telegram_nickname?: StringNullableFilter<"BookingRequest"> | string | null
  }

  export type ClassCallUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassCallWhereUniqueInput
    update: XOR<ClassCallUpdateWithoutClassInput, ClassCallUncheckedUpdateWithoutClassInput>
    create: XOR<ClassCallCreateWithoutClassInput, ClassCallUncheckedCreateWithoutClassInput>
  }

  export type ClassCallUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassCallWhereUniqueInput
    data: XOR<ClassCallUpdateWithoutClassInput, ClassCallUncheckedUpdateWithoutClassInput>
  }

  export type ClassCallUpdateManyWithWhereWithoutClassInput = {
    where: ClassCallScalarWhereInput
    data: XOR<ClassCallUpdateManyMutationInput, ClassCallUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassTaskUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassTaskWhereUniqueInput
    update: XOR<ClassTaskUpdateWithoutClassInput, ClassTaskUncheckedUpdateWithoutClassInput>
    create: XOR<ClassTaskCreateWithoutClassInput, ClassTaskUncheckedCreateWithoutClassInput>
  }

  export type ClassTaskUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassTaskWhereUniqueInput
    data: XOR<ClassTaskUpdateWithoutClassInput, ClassTaskUncheckedUpdateWithoutClassInput>
  }

  export type ClassTaskUpdateManyWithWhereWithoutClassInput = {
    where: ClassTaskScalarWhereInput
    data: XOR<ClassTaskUpdateManyMutationInput, ClassTaskUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassTaskScalarWhereInput = {
    AND?: ClassTaskScalarWhereInput | ClassTaskScalarWhereInput[]
    OR?: ClassTaskScalarWhereInput[]
    NOT?: ClassTaskScalarWhereInput | ClassTaskScalarWhereInput[]
    class_task_id?: IntFilter<"ClassTask"> | number
    course_task_id?: StringFilter<"ClassTask"> | string
    class_id?: StringFilter<"ClassTask"> | string
  }

  export type ClassCreateWithoutClass_callsInput = {
    class_id: string
    class_code?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class_size_id: ClassSizeCreateNestedOneWithoutClassesInput
    is_instance_of_course: CourseCreateNestedOneWithoutClassesInput
    time_of_day: TimeOfDayCreateNestedOneWithoutClassesInput
    tuition_lang: TuitionLangCreateNestedOneWithoutClassesInput
    mentor_classes?: MentorsClassesCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutClass_callsInput = {
    class_id: string
    class_code?: string | null
    course_id: string
    start_date: Date | string
    end_date?: Date | string | null
    tuition_lang_code: string
    time_of_day_id: string
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    classSizeClass_size_id: string
    mentor_classes?: MentorsClassesUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestUncheckedCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutClass_callsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutClass_callsInput, ClassUncheckedCreateWithoutClass_callsInput>
  }

  export type MeetingKindCreateWithoutClass_callsInput = {
    meeting_kind_id: string
    meeting_kind_name: string
  }

  export type MeetingKindUncheckedCreateWithoutClass_callsInput = {
    meeting_kind_id: string
    meeting_kind_name: string
  }

  export type MeetingKindCreateOrConnectWithoutClass_callsInput = {
    where: MeetingKindWhereUniqueInput
    create: XOR<MeetingKindCreateWithoutClass_callsInput, MeetingKindUncheckedCreateWithoutClass_callsInput>
  }

  export type ClassUpsertWithoutClass_callsInput = {
    update: XOR<ClassUpdateWithoutClass_callsInput, ClassUncheckedUpdateWithoutClass_callsInput>
    create: XOR<ClassCreateWithoutClass_callsInput, ClassUncheckedCreateWithoutClass_callsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutClass_callsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutClass_callsInput, ClassUncheckedUpdateWithoutClass_callsInput>
  }

  export type ClassUpdateWithoutClass_callsInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class_size_id?: ClassSizeUpdateOneRequiredWithoutClassesNestedInput
    is_instance_of_course?: CourseUpdateOneRequiredWithoutClassesNestedInput
    time_of_day?: TimeOfDayUpdateOneRequiredWithoutClassesNestedInput
    tuition_lang?: TuitionLangUpdateOneRequiredWithoutClassesNestedInput
    mentor_classes?: MentorsClassesUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutClass_callsInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    course_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    classSizeClass_size_id?: StringFieldUpdateOperationsInput | string
    mentor_classes?: MentorsClassesUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUncheckedUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUncheckedUpdateManyWithoutClassNestedInput
  }

  export type MeetingKindUpsertWithoutClass_callsInput = {
    update: XOR<MeetingKindUpdateWithoutClass_callsInput, MeetingKindUncheckedUpdateWithoutClass_callsInput>
    create: XOR<MeetingKindCreateWithoutClass_callsInput, MeetingKindUncheckedCreateWithoutClass_callsInput>
    where?: MeetingKindWhereInput
  }

  export type MeetingKindUpdateToOneWithWhereWithoutClass_callsInput = {
    where?: MeetingKindWhereInput
    data: XOR<MeetingKindUpdateWithoutClass_callsInput, MeetingKindUncheckedUpdateWithoutClass_callsInput>
  }

  export type MeetingKindUpdateWithoutClass_callsInput = {
    meeting_kind_id?: StringFieldUpdateOperationsInput | string
    meeting_kind_name?: StringFieldUpdateOperationsInput | string
  }

  export type MeetingKindUncheckedUpdateWithoutClass_callsInput = {
    meeting_kind_id?: StringFieldUpdateOperationsInput | string
    meeting_kind_name?: StringFieldUpdateOperationsInput | string
  }

  export type ClassCreateWithoutClass_size_idInput = {
    class_id: string
    class_code?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    is_instance_of_course: CourseCreateNestedOneWithoutClassesInput
    time_of_day: TimeOfDayCreateNestedOneWithoutClassesInput
    tuition_lang: TuitionLangCreateNestedOneWithoutClassesInput
    mentor_classes?: MentorsClassesCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestCreateNestedManyWithoutClassInput
    class_calls?: ClassCallCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutClass_size_idInput = {
    class_id: string
    class_code?: string | null
    course_id: string
    start_date: Date | string
    end_date?: Date | string | null
    tuition_lang_code: string
    time_of_day_id: string
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    mentor_classes?: MentorsClassesUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestUncheckedCreateNestedManyWithoutClassInput
    class_calls?: ClassCallUncheckedCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutClass_size_idInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutClass_size_idInput, ClassUncheckedCreateWithoutClass_size_idInput>
  }

  export type ClassCreateManyClass_size_idInputEnvelope = {
    data: ClassCreateManyClass_size_idInput | ClassCreateManyClass_size_idInput[]
    skipDuplicates?: boolean
  }

  export type MentorPayModelCreateWithoutClass_sizeInput = {
    start_date: Date | string
    pay_rate_per_hour: number
    created_date?: Date | string | null
    end_date?: Date | string | null
    deleted?: boolean
    mentor: MentorCreateNestedOneWithoutMentorPayModelInput
  }

  export type MentorPayModelUncheckedCreateWithoutClass_sizeInput = {
    mentor_id: string
    start_date: Date | string
    pay_rate_per_hour: number
    created_date?: Date | string | null
    end_date?: Date | string | null
    deleted?: boolean
  }

  export type MentorPayModelCreateOrConnectWithoutClass_sizeInput = {
    where: MentorPayModelWhereUniqueInput
    create: XOR<MentorPayModelCreateWithoutClass_sizeInput, MentorPayModelUncheckedCreateWithoutClass_sizeInput>
  }

  export type MentorPayModelCreateManyClass_sizeInputEnvelope = {
    data: MentorPayModelCreateManyClass_sizeInput | MentorPayModelCreateManyClass_sizeInput[]
    skipDuplicates?: boolean
  }

  export type ClassUpsertWithWhereUniqueWithoutClass_size_idInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutClass_size_idInput, ClassUncheckedUpdateWithoutClass_size_idInput>
    create: XOR<ClassCreateWithoutClass_size_idInput, ClassUncheckedCreateWithoutClass_size_idInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutClass_size_idInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutClass_size_idInput, ClassUncheckedUpdateWithoutClass_size_idInput>
  }

  export type ClassUpdateManyWithWhereWithoutClass_size_idInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutClass_size_idInput>
  }

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[]
    OR?: ClassScalarWhereInput[]
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[]
    class_id?: StringFilter<"Class"> | string
    class_code?: StringNullableFilter<"Class"> | string | null
    course_id?: StringFilter<"Class"> | string
    start_date?: DateTimeFilter<"Class"> | Date | string
    end_date?: DateTimeNullableFilter<"Class"> | Date | string | null
    tuition_lang_code?: StringFilter<"Class"> | string
    time_of_day_id?: StringFilter<"Class"> | string
    start_time_gmt3?: StringFilter<"Class"> | string
    created_date?: DateTimeNullableFilter<"Class"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Class"> | Date | string | null
    deleted?: BoolFilter<"Class"> | boolean
    classSizeClass_size_id?: StringFilter<"Class"> | string
  }

  export type MentorPayModelUpsertWithWhereUniqueWithoutClass_sizeInput = {
    where: MentorPayModelWhereUniqueInput
    update: XOR<MentorPayModelUpdateWithoutClass_sizeInput, MentorPayModelUncheckedUpdateWithoutClass_sizeInput>
    create: XOR<MentorPayModelCreateWithoutClass_sizeInput, MentorPayModelUncheckedCreateWithoutClass_sizeInput>
  }

  export type MentorPayModelUpdateWithWhereUniqueWithoutClass_sizeInput = {
    where: MentorPayModelWhereUniqueInput
    data: XOR<MentorPayModelUpdateWithoutClass_sizeInput, MentorPayModelUncheckedUpdateWithoutClass_sizeInput>
  }

  export type MentorPayModelUpdateManyWithWhereWithoutClass_sizeInput = {
    where: MentorPayModelScalarWhereInput
    data: XOR<MentorPayModelUpdateManyMutationInput, MentorPayModelUncheckedUpdateManyWithoutClass_sizeInput>
  }

  export type MentorPayModelScalarWhereInput = {
    AND?: MentorPayModelScalarWhereInput | MentorPayModelScalarWhereInput[]
    OR?: MentorPayModelScalarWhereInput[]
    NOT?: MentorPayModelScalarWhereInput | MentorPayModelScalarWhereInput[]
    mentor_id?: StringFilter<"MentorPayModel"> | string
    class_size_id?: StringFilter<"MentorPayModel"> | string
    start_date?: DateTimeFilter<"MentorPayModel"> | Date | string
    pay_rate_per_hour?: FloatFilter<"MentorPayModel"> | number
    created_date?: DateTimeNullableFilter<"MentorPayModel"> | Date | string | null
    end_date?: DateTimeNullableFilter<"MentorPayModel"> | Date | string | null
    deleted?: BoolFilter<"MentorPayModel"> | boolean
  }

  export type CourseLevelCreateWithoutCourseInput = {
    course_level_id: string
    course_level_name: string
    CourseLevelsPerSubject?: CourseLevelsPerSubjectCreateNestedManyWithoutCourse_levelInput
  }

  export type CourseLevelUncheckedCreateWithoutCourseInput = {
    course_level_id: string
    course_level_name: string
    CourseLevelsPerSubject?: CourseLevelsPerSubjectUncheckedCreateNestedManyWithoutCourse_levelInput
  }

  export type CourseLevelCreateOrConnectWithoutCourseInput = {
    where: CourseLevelWhereUniqueInput
    create: XOR<CourseLevelCreateWithoutCourseInput, CourseLevelUncheckedCreateWithoutCourseInput>
  }

  export type CourseAdviceCreateWithoutCourseInput = {
    advice_id: string
    advice_text?: string | null
    last_used_date?: string | null
    created_date: string
  }

  export type CourseAdviceUncheckedCreateWithoutCourseInput = {
    advice_id: string
    advice_text?: string | null
    last_used_date?: string | null
    created_date: string
  }

  export type CourseAdviceCreateOrConnectWithoutCourseInput = {
    where: CourseAdviceWhereUniqueInput
    create: XOR<CourseAdviceCreateWithoutCourseInput, CourseAdviceUncheckedCreateWithoutCourseInput>
  }

  export type CourseAdviceCreateManyCourseInputEnvelope = {
    data: CourseAdviceCreateManyCourseInput | CourseAdviceCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type ClassCreateWithoutIs_instance_of_courseInput = {
    class_id: string
    class_code?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class_size_id: ClassSizeCreateNestedOneWithoutClassesInput
    time_of_day: TimeOfDayCreateNestedOneWithoutClassesInput
    tuition_lang: TuitionLangCreateNestedOneWithoutClassesInput
    mentor_classes?: MentorsClassesCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestCreateNestedManyWithoutClassInput
    class_calls?: ClassCallCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutIs_instance_of_courseInput = {
    class_id: string
    class_code?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    tuition_lang_code: string
    time_of_day_id: string
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    classSizeClass_size_id: string
    mentor_classes?: MentorsClassesUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestUncheckedCreateNestedManyWithoutClassInput
    class_calls?: ClassCallUncheckedCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutIs_instance_of_courseInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutIs_instance_of_courseInput, ClassUncheckedCreateWithoutIs_instance_of_courseInput>
  }

  export type ClassCreateManyIs_instance_of_courseInputEnvelope = {
    data: ClassCreateManyIs_instance_of_courseInput | ClassCreateManyIs_instance_of_courseInput[]
    skipDuplicates?: boolean
  }

  export type SubjectCreateWithoutCourseInput = {
    subject_code: string
    subject_name: string
    CourseLevelsPerSubject?: CourseLevelsPerSubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutCourseInput = {
    subject_code: string
    subject_name: string
    CourseLevelsPerSubject?: CourseLevelsPerSubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutCourseInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutCourseInput, SubjectUncheckedCreateWithoutCourseInput>
  }

  export type CourseStructureCreateWithoutCourseInput = {
    module: ModuleCreateNestedOneWithoutCourseStructureInput
    section: SectionCreateNestedOneWithoutCourseStructureInput
    lesson: LessonCreateNestedOneWithoutCourseStructureInput
  }

  export type CourseStructureUncheckedCreateWithoutCourseInput = {
    module_id: number
    section_id: number
    lesson_id: number
  }

  export type CourseStructureCreateOrConnectWithoutCourseInput = {
    where: CourseStructureWhereUniqueInput
    create: XOR<CourseStructureCreateWithoutCourseInput, CourseStructureUncheckedCreateWithoutCourseInput>
  }

  export type CourseStructureCreateManyCourseInputEnvelope = {
    data: CourseStructureCreateManyCourseInput | CourseStructureCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseTaskCreateWithoutCourseInput = {
    course_task_id: string
    question: string
    module: ModuleCreateNestedOneWithoutCourseTaskInput
    section: SectionCreateNestedOneWithoutCourseTaskInput
    lesson: LessonCreateNestedOneWithoutCourseTaskInput
    task: TaskCreateNestedOneWithoutCourseTaskInput
    ClassTask?: ClassTaskCreateNestedManyWithoutCourse_taskInput
  }

  export type CourseTaskUncheckedCreateWithoutCourseInput = {
    course_task_id: string
    module_id: number
    section_id: number
    lesson_id: number
    task_id: number
    question: string
    ClassTask?: ClassTaskUncheckedCreateNestedManyWithoutCourse_taskInput
  }

  export type CourseTaskCreateOrConnectWithoutCourseInput = {
    where: CourseTaskWhereUniqueInput
    create: XOR<CourseTaskCreateWithoutCourseInput, CourseTaskUncheckedCreateWithoutCourseInput>
  }

  export type CourseTaskCreateManyCourseInputEnvelope = {
    data: CourseTaskCreateManyCourseInput | CourseTaskCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type ModuleCreateWithoutCourseInput = {
    module_name: string
    module_description?: string | null
    module_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    sections?: SectionCreateNestedManyWithoutModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutModuleInput
    CourseTask?: CourseTaskCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutCourseInput = {
    module_id?: number
    module_name: string
    module_description?: string | null
    module_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    sections?: SectionUncheckedCreateNestedManyWithoutModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutModuleInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutCourseInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput>
  }

  export type ModuleCreateManyCourseInputEnvelope = {
    data: ModuleCreateManyCourseInput | ModuleCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type LessonCardCreateWithoutCourseInput = {
    card_id: string
    question: string
    answer: string
    example?: string | null
    deck: DeckCreateNestedOneWithoutCardInput
    lesson: LessonCreateNestedOneWithoutLessonCardInput
  }

  export type LessonCardUncheckedCreateWithoutCourseInput = {
    card_id: string
    deck_id: string
    question: string
    answer: string
    example?: string | null
    lesson_id: number
  }

  export type LessonCardCreateOrConnectWithoutCourseInput = {
    where: LessonCardWhereUniqueInput
    create: XOR<LessonCardCreateWithoutCourseInput, LessonCardUncheckedCreateWithoutCourseInput>
  }

  export type LessonCardCreateManyCourseInputEnvelope = {
    data: LessonCardCreateManyCourseInput | LessonCardCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CourseLevelUpsertWithoutCourseInput = {
    update: XOR<CourseLevelUpdateWithoutCourseInput, CourseLevelUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseLevelCreateWithoutCourseInput, CourseLevelUncheckedCreateWithoutCourseInput>
    where?: CourseLevelWhereInput
  }

  export type CourseLevelUpdateToOneWithWhereWithoutCourseInput = {
    where?: CourseLevelWhereInput
    data: XOR<CourseLevelUpdateWithoutCourseInput, CourseLevelUncheckedUpdateWithoutCourseInput>
  }

  export type CourseLevelUpdateWithoutCourseInput = {
    course_level_id?: StringFieldUpdateOperationsInput | string
    course_level_name?: StringFieldUpdateOperationsInput | string
    CourseLevelsPerSubject?: CourseLevelsPerSubjectUpdateManyWithoutCourse_levelNestedInput
  }

  export type CourseLevelUncheckedUpdateWithoutCourseInput = {
    course_level_id?: StringFieldUpdateOperationsInput | string
    course_level_name?: StringFieldUpdateOperationsInput | string
    CourseLevelsPerSubject?: CourseLevelsPerSubjectUncheckedUpdateManyWithoutCourse_levelNestedInput
  }

  export type CourseAdviceUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseAdviceWhereUniqueInput
    update: XOR<CourseAdviceUpdateWithoutCourseInput, CourseAdviceUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseAdviceCreateWithoutCourseInput, CourseAdviceUncheckedCreateWithoutCourseInput>
  }

  export type CourseAdviceUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseAdviceWhereUniqueInput
    data: XOR<CourseAdviceUpdateWithoutCourseInput, CourseAdviceUncheckedUpdateWithoutCourseInput>
  }

  export type CourseAdviceUpdateManyWithWhereWithoutCourseInput = {
    where: CourseAdviceScalarWhereInput
    data: XOR<CourseAdviceUpdateManyMutationInput, CourseAdviceUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseAdviceScalarWhereInput = {
    AND?: CourseAdviceScalarWhereInput | CourseAdviceScalarWhereInput[]
    OR?: CourseAdviceScalarWhereInput[]
    NOT?: CourseAdviceScalarWhereInput | CourseAdviceScalarWhereInput[]
    advice_id?: StringFilter<"CourseAdvice"> | string
    course_code?: StringFilter<"CourseAdvice"> | string
    advice_text?: StringNullableFilter<"CourseAdvice"> | string | null
    last_used_date?: StringNullableFilter<"CourseAdvice"> | string | null
    created_date?: StringFilter<"CourseAdvice"> | string
  }

  export type ClassUpsertWithWhereUniqueWithoutIs_instance_of_courseInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutIs_instance_of_courseInput, ClassUncheckedUpdateWithoutIs_instance_of_courseInput>
    create: XOR<ClassCreateWithoutIs_instance_of_courseInput, ClassUncheckedCreateWithoutIs_instance_of_courseInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutIs_instance_of_courseInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutIs_instance_of_courseInput, ClassUncheckedUpdateWithoutIs_instance_of_courseInput>
  }

  export type ClassUpdateManyWithWhereWithoutIs_instance_of_courseInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutIs_instance_of_courseInput>
  }

  export type SubjectUpsertWithoutCourseInput = {
    update: XOR<SubjectUpdateWithoutCourseInput, SubjectUncheckedUpdateWithoutCourseInput>
    create: XOR<SubjectCreateWithoutCourseInput, SubjectUncheckedCreateWithoutCourseInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutCourseInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutCourseInput, SubjectUncheckedUpdateWithoutCourseInput>
  }

  export type SubjectUpdateWithoutCourseInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
    subject_name?: StringFieldUpdateOperationsInput | string
    CourseLevelsPerSubject?: CourseLevelsPerSubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutCourseInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
    subject_name?: StringFieldUpdateOperationsInput | string
    CourseLevelsPerSubject?: CourseLevelsPerSubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type CourseStructureUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseStructureWhereUniqueInput
    update: XOR<CourseStructureUpdateWithoutCourseInput, CourseStructureUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseStructureCreateWithoutCourseInput, CourseStructureUncheckedCreateWithoutCourseInput>
  }

  export type CourseStructureUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseStructureWhereUniqueInput
    data: XOR<CourseStructureUpdateWithoutCourseInput, CourseStructureUncheckedUpdateWithoutCourseInput>
  }

  export type CourseStructureUpdateManyWithWhereWithoutCourseInput = {
    where: CourseStructureScalarWhereInput
    data: XOR<CourseStructureUpdateManyMutationInput, CourseStructureUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseStructureScalarWhereInput = {
    AND?: CourseStructureScalarWhereInput | CourseStructureScalarWhereInput[]
    OR?: CourseStructureScalarWhereInput[]
    NOT?: CourseStructureScalarWhereInput | CourseStructureScalarWhereInput[]
    course_id?: StringFilter<"CourseStructure"> | string
    module_id?: IntFilter<"CourseStructure"> | number
    section_id?: IntFilter<"CourseStructure"> | number
    lesson_id?: IntFilter<"CourseStructure"> | number
  }

  export type CourseTaskUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseTaskWhereUniqueInput
    update: XOR<CourseTaskUpdateWithoutCourseInput, CourseTaskUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseTaskCreateWithoutCourseInput, CourseTaskUncheckedCreateWithoutCourseInput>
  }

  export type CourseTaskUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseTaskWhereUniqueInput
    data: XOR<CourseTaskUpdateWithoutCourseInput, CourseTaskUncheckedUpdateWithoutCourseInput>
  }

  export type CourseTaskUpdateManyWithWhereWithoutCourseInput = {
    where: CourseTaskScalarWhereInput
    data: XOR<CourseTaskUpdateManyMutationInput, CourseTaskUncheckedUpdateManyWithoutCourseInput>
  }

  export type CourseTaskScalarWhereInput = {
    AND?: CourseTaskScalarWhereInput | CourseTaskScalarWhereInput[]
    OR?: CourseTaskScalarWhereInput[]
    NOT?: CourseTaskScalarWhereInput | CourseTaskScalarWhereInput[]
    course_task_id?: StringFilter<"CourseTask"> | string
    course_id?: StringFilter<"CourseTask"> | string
    module_id?: IntFilter<"CourseTask"> | number
    section_id?: IntFilter<"CourseTask"> | number
    lesson_id?: IntFilter<"CourseTask"> | number
    task_id?: IntFilter<"CourseTask"> | number
    question?: StringFilter<"CourseTask"> | string
  }

  export type ModuleUpsertWithWhereUniqueWithoutCourseInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutCourseInput, ModuleUncheckedUpdateWithoutCourseInput>
    create: XOR<ModuleCreateWithoutCourseInput, ModuleUncheckedCreateWithoutCourseInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutCourseInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutCourseInput, ModuleUncheckedUpdateWithoutCourseInput>
  }

  export type ModuleUpdateManyWithWhereWithoutCourseInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutCourseInput>
  }

  export type ModuleScalarWhereInput = {
    AND?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    OR?: ModuleScalarWhereInput[]
    NOT?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    module_id?: IntFilter<"Module"> | number
    module_name?: StringFilter<"Module"> | string
    module_description?: StringNullableFilter<"Module"> | string | null
    module_order?: IntFilter<"Module"> | number
    created_date?: DateTimeNullableFilter<"Module"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Module"> | Date | string | null
    deleted?: BoolFilter<"Module"> | boolean
    course_id?: StringFilter<"Module"> | string
  }

  export type LessonCardUpsertWithWhereUniqueWithoutCourseInput = {
    where: LessonCardWhereUniqueInput
    update: XOR<LessonCardUpdateWithoutCourseInput, LessonCardUncheckedUpdateWithoutCourseInput>
    create: XOR<LessonCardCreateWithoutCourseInput, LessonCardUncheckedCreateWithoutCourseInput>
  }

  export type LessonCardUpdateWithWhereUniqueWithoutCourseInput = {
    where: LessonCardWhereUniqueInput
    data: XOR<LessonCardUpdateWithoutCourseInput, LessonCardUncheckedUpdateWithoutCourseInput>
  }

  export type LessonCardUpdateManyWithWhereWithoutCourseInput = {
    where: LessonCardScalarWhereInput
    data: XOR<LessonCardUpdateManyMutationInput, LessonCardUncheckedUpdateManyWithoutCourseInput>
  }

  export type LessonCardScalarWhereInput = {
    AND?: LessonCardScalarWhereInput | LessonCardScalarWhereInput[]
    OR?: LessonCardScalarWhereInput[]
    NOT?: LessonCardScalarWhereInput | LessonCardScalarWhereInput[]
    card_id?: StringFilter<"LessonCard"> | string
    deck_id?: StringFilter<"LessonCard"> | string
    question?: StringFilter<"LessonCard"> | string
    answer?: StringFilter<"LessonCard"> | string
    example?: StringNullableFilter<"LessonCard"> | string | null
    course_code?: StringFilter<"LessonCard"> | string
    lesson_id?: IntFilter<"LessonCard"> | number
  }

  export type CourseCreateWithoutCourse_adviceInput = {
    course_code: string
    course_name?: string | null
    created_date?: Date | string | null
    course_level: CourseLevelCreateNestedOneWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutIs_instance_of_courseInput
    subject?: SubjectCreateNestedOneWithoutCourseInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutCourseInput
    CourseTask?: CourseTaskCreateNestedManyWithoutCourseInput
    Module?: ModuleCreateNestedManyWithoutCourseInput
    LessonCard?: LessonCardCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCourse_adviceInput = {
    course_code: string
    course_name?: string | null
    course_level_id: string
    created_date?: Date | string | null
    subject_code: string
    classes?: ClassUncheckedCreateNestedManyWithoutIs_instance_of_courseInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutCourseInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutCourseInput
    Module?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    LessonCard?: LessonCardUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCourse_adviceInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCourse_adviceInput, CourseUncheckedCreateWithoutCourse_adviceInput>
  }

  export type CourseUpsertWithoutCourse_adviceInput = {
    update: XOR<CourseUpdateWithoutCourse_adviceInput, CourseUncheckedUpdateWithoutCourse_adviceInput>
    create: XOR<CourseCreateWithoutCourse_adviceInput, CourseUncheckedCreateWithoutCourse_adviceInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCourse_adviceInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCourse_adviceInput, CourseUncheckedUpdateWithoutCourse_adviceInput>
  }

  export type CourseUpdateWithoutCourse_adviceInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_level?: CourseLevelUpdateOneRequiredWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutIs_instance_of_courseNestedInput
    subject?: SubjectUpdateOneWithoutCourseNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutCourseNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutCourseNestedInput
    Module?: ModuleUpdateManyWithoutCourseNestedInput
    LessonCard?: LessonCardUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCourse_adviceInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    course_level_id?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject_code?: StringFieldUpdateOperationsInput | string
    classes?: ClassUncheckedUpdateManyWithoutIs_instance_of_courseNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutCourseNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutCourseNestedInput
    Module?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    LessonCard?: LessonCardUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateWithoutCourseTaskInput = {
    course_code: string
    course_name?: string | null
    created_date?: Date | string | null
    course_level: CourseLevelCreateNestedOneWithoutCourseInput
    course_advice?: CourseAdviceCreateNestedManyWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutIs_instance_of_courseInput
    subject?: SubjectCreateNestedOneWithoutCourseInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutCourseInput
    Module?: ModuleCreateNestedManyWithoutCourseInput
    LessonCard?: LessonCardCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCourseTaskInput = {
    course_code: string
    course_name?: string | null
    course_level_id: string
    created_date?: Date | string | null
    subject_code: string
    course_advice?: CourseAdviceUncheckedCreateNestedManyWithoutCourseInput
    classes?: ClassUncheckedCreateNestedManyWithoutIs_instance_of_courseInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutCourseInput
    Module?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    LessonCard?: LessonCardUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCourseTaskInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCourseTaskInput, CourseUncheckedCreateWithoutCourseTaskInput>
  }

  export type ModuleCreateWithoutCourseTaskInput = {
    module_name: string
    module_description?: string | null
    module_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    course: CourseCreateNestedOneWithoutModuleInput
    sections?: SectionCreateNestedManyWithoutModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutCourseTaskInput = {
    module_id?: number
    module_name: string
    module_description?: string | null
    module_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    course_id: string
    sections?: SectionUncheckedCreateNestedManyWithoutModuleInput
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutCourseTaskInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutCourseTaskInput, ModuleUncheckedCreateWithoutCourseTaskInput>
  }

  export type SectionCreateWithoutCourseTaskInput = {
    section_name: string
    section_description?: string | null
    section_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    module: ModuleCreateNestedOneWithoutSectionsInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutSectionInput
    Lesson?: LessonCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutCourseTaskInput = {
    section_id?: number
    section_name: string
    section_description?: string | null
    section_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    module_id: number
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutSectionInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutCourseTaskInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutCourseTaskInput, SectionUncheckedCreateWithoutCourseTaskInput>
  }

  export type LessonCreateWithoutCourseTaskInput = {
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    section: SectionCreateNestedOneWithoutLessonInput
    tasks?: TaskCreateNestedManyWithoutLessonInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutLessonInput
    Module?: ModuleCreateNestedOneWithoutLessonsInput
    LessonCard?: LessonCardCreateNestedManyWithoutLessonInput
    UserCard?: UserCardCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutCourseTaskInput = {
    lesson_id?: number
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    section_id: number
    moduleModule_id?: number | null
    tasks?: TaskUncheckedCreateNestedManyWithoutLessonInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutLessonInput
    LessonCard?: LessonCardUncheckedCreateNestedManyWithoutLessonInput
    UserCard?: UserCardUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutCourseTaskInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutCourseTaskInput, LessonUncheckedCreateWithoutCourseTaskInput>
  }

  export type TaskCreateWithoutCourseTaskInput = {
    task_description?: string | null
    task_text?: string | null
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    gap_map?: string | null
    task_type: TaskTypeCreateNestedOneWithoutTaskInput
    task_context: TaskContextCreateNestedOneWithoutTaskInput
    lesson: LessonCreateNestedOneWithoutTasksInput
    task_forms?: TaskFormCreateNestedManyWithoutTaskInput
    task_options?: TaskOptionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutCourseTaskInput = {
    task_id?: number
    task_description?: string | null
    task_text?: string | null
    task_type_id: number
    task_context_id: string
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    lesson_id: number
    gap_map?: string | null
    task_forms?: TaskFormUncheckedCreateNestedManyWithoutTaskInput
    task_options?: TaskOptionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutCourseTaskInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCourseTaskInput, TaskUncheckedCreateWithoutCourseTaskInput>
  }

  export type ClassTaskCreateWithoutCourse_taskInput = {
    class: ClassCreateNestedOneWithoutClassTaskInput
    student_tasks?: StudentTaskCreateNestedManyWithoutClass_taskInput
    student_answer?: StudentAnswerCreateNestedManyWithoutClass_taskInput
  }

  export type ClassTaskUncheckedCreateWithoutCourse_taskInput = {
    class_task_id?: number
    class_id: string
    student_tasks?: StudentTaskUncheckedCreateNestedManyWithoutClass_taskInput
    student_answer?: StudentAnswerUncheckedCreateNestedManyWithoutClass_taskInput
  }

  export type ClassTaskCreateOrConnectWithoutCourse_taskInput = {
    where: ClassTaskWhereUniqueInput
    create: XOR<ClassTaskCreateWithoutCourse_taskInput, ClassTaskUncheckedCreateWithoutCourse_taskInput>
  }

  export type ClassTaskCreateManyCourse_taskInputEnvelope = {
    data: ClassTaskCreateManyCourse_taskInput | ClassTaskCreateManyCourse_taskInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutCourseTaskInput = {
    update: XOR<CourseUpdateWithoutCourseTaskInput, CourseUncheckedUpdateWithoutCourseTaskInput>
    create: XOR<CourseCreateWithoutCourseTaskInput, CourseUncheckedCreateWithoutCourseTaskInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCourseTaskInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCourseTaskInput, CourseUncheckedUpdateWithoutCourseTaskInput>
  }

  export type CourseUpdateWithoutCourseTaskInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_level?: CourseLevelUpdateOneRequiredWithoutCourseNestedInput
    course_advice?: CourseAdviceUpdateManyWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutIs_instance_of_courseNestedInput
    subject?: SubjectUpdateOneWithoutCourseNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutCourseNestedInput
    Module?: ModuleUpdateManyWithoutCourseNestedInput
    LessonCard?: LessonCardUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCourseTaskInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    course_level_id?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject_code?: StringFieldUpdateOperationsInput | string
    course_advice?: CourseAdviceUncheckedUpdateManyWithoutCourseNestedInput
    classes?: ClassUncheckedUpdateManyWithoutIs_instance_of_courseNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutCourseNestedInput
    Module?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    LessonCard?: LessonCardUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ModuleUpsertWithoutCourseTaskInput = {
    update: XOR<ModuleUpdateWithoutCourseTaskInput, ModuleUncheckedUpdateWithoutCourseTaskInput>
    create: XOR<ModuleCreateWithoutCourseTaskInput, ModuleUncheckedCreateWithoutCourseTaskInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutCourseTaskInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutCourseTaskInput, ModuleUncheckedUpdateWithoutCourseTaskInput>
  }

  export type ModuleUpdateWithoutCourseTaskInput = {
    module_name?: StringFieldUpdateOperationsInput | string
    module_description?: NullableStringFieldUpdateOperationsInput | string | null
    module_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneRequiredWithoutModuleNestedInput
    sections?: SectionUpdateManyWithoutModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutCourseTaskInput = {
    module_id?: IntFieldUpdateOperationsInput | number
    module_name?: StringFieldUpdateOperationsInput | string
    module_description?: NullableStringFieldUpdateOperationsInput | string | null
    module_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    course_id?: StringFieldUpdateOperationsInput | string
    sections?: SectionUncheckedUpdateManyWithoutModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type SectionUpsertWithoutCourseTaskInput = {
    update: XOR<SectionUpdateWithoutCourseTaskInput, SectionUncheckedUpdateWithoutCourseTaskInput>
    create: XOR<SectionCreateWithoutCourseTaskInput, SectionUncheckedCreateWithoutCourseTaskInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutCourseTaskInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutCourseTaskInput, SectionUncheckedUpdateWithoutCourseTaskInput>
  }

  export type SectionUpdateWithoutCourseTaskInput = {
    section_name?: StringFieldUpdateOperationsInput | string
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    section_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    module?: ModuleUpdateOneRequiredWithoutSectionsNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutSectionNestedInput
    Lesson?: LessonUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutCourseTaskInput = {
    section_id?: IntFieldUpdateOperationsInput | number
    section_name?: StringFieldUpdateOperationsInput | string
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    section_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    module_id?: IntFieldUpdateOperationsInput | number
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutSectionNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type LessonUpsertWithoutCourseTaskInput = {
    update: XOR<LessonUpdateWithoutCourseTaskInput, LessonUncheckedUpdateWithoutCourseTaskInput>
    create: XOR<LessonCreateWithoutCourseTaskInput, LessonUncheckedCreateWithoutCourseTaskInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutCourseTaskInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutCourseTaskInput, LessonUncheckedUpdateWithoutCourseTaskInput>
  }

  export type LessonUpdateWithoutCourseTaskInput = {
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    section?: SectionUpdateOneRequiredWithoutLessonNestedInput
    tasks?: TaskUpdateManyWithoutLessonNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutLessonNestedInput
    Module?: ModuleUpdateOneWithoutLessonsNestedInput
    LessonCard?: LessonCardUpdateManyWithoutLessonNestedInput
    UserCard?: UserCardUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutCourseTaskInput = {
    lesson_id?: IntFieldUpdateOperationsInput | number
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    section_id?: IntFieldUpdateOperationsInput | number
    moduleModule_id?: NullableIntFieldUpdateOperationsInput | number | null
    tasks?: TaskUncheckedUpdateManyWithoutLessonNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutLessonNestedInput
    LessonCard?: LessonCardUncheckedUpdateManyWithoutLessonNestedInput
    UserCard?: UserCardUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type TaskUpsertWithoutCourseTaskInput = {
    update: XOR<TaskUpdateWithoutCourseTaskInput, TaskUncheckedUpdateWithoutCourseTaskInput>
    create: XOR<TaskCreateWithoutCourseTaskInput, TaskUncheckedCreateWithoutCourseTaskInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutCourseTaskInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutCourseTaskInput, TaskUncheckedUpdateWithoutCourseTaskInput>
  }

  export type TaskUpdateWithoutCourseTaskInput = {
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
    task_type?: TaskTypeUpdateOneRequiredWithoutTaskNestedInput
    task_context?: TaskContextUpdateOneRequiredWithoutTaskNestedInput
    lesson?: LessonUpdateOneRequiredWithoutTasksNestedInput
    task_forms?: TaskFormUpdateManyWithoutTaskNestedInput
    task_options?: TaskOptionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutCourseTaskInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_type_id?: IntFieldUpdateOperationsInput | number
    task_context_id?: StringFieldUpdateOperationsInput | string
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    lesson_id?: IntFieldUpdateOperationsInput | number
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
    task_forms?: TaskFormUncheckedUpdateManyWithoutTaskNestedInput
    task_options?: TaskOptionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type ClassTaskUpsertWithWhereUniqueWithoutCourse_taskInput = {
    where: ClassTaskWhereUniqueInput
    update: XOR<ClassTaskUpdateWithoutCourse_taskInput, ClassTaskUncheckedUpdateWithoutCourse_taskInput>
    create: XOR<ClassTaskCreateWithoutCourse_taskInput, ClassTaskUncheckedCreateWithoutCourse_taskInput>
  }

  export type ClassTaskUpdateWithWhereUniqueWithoutCourse_taskInput = {
    where: ClassTaskWhereUniqueInput
    data: XOR<ClassTaskUpdateWithoutCourse_taskInput, ClassTaskUncheckedUpdateWithoutCourse_taskInput>
  }

  export type ClassTaskUpdateManyWithWhereWithoutCourse_taskInput = {
    where: ClassTaskScalarWhereInput
    data: XOR<ClassTaskUpdateManyMutationInput, ClassTaskUncheckedUpdateManyWithoutCourse_taskInput>
  }

  export type CourseCreateWithoutCourse_levelInput = {
    course_code: string
    course_name?: string | null
    created_date?: Date | string | null
    course_advice?: CourseAdviceCreateNestedManyWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutIs_instance_of_courseInput
    subject?: SubjectCreateNestedOneWithoutCourseInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutCourseInput
    CourseTask?: CourseTaskCreateNestedManyWithoutCourseInput
    Module?: ModuleCreateNestedManyWithoutCourseInput
    LessonCard?: LessonCardCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCourse_levelInput = {
    course_code: string
    course_name?: string | null
    created_date?: Date | string | null
    subject_code: string
    course_advice?: CourseAdviceUncheckedCreateNestedManyWithoutCourseInput
    classes?: ClassUncheckedCreateNestedManyWithoutIs_instance_of_courseInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutCourseInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutCourseInput
    Module?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    LessonCard?: LessonCardUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCourse_levelInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCourse_levelInput, CourseUncheckedCreateWithoutCourse_levelInput>
  }

  export type CourseCreateManyCourse_levelInputEnvelope = {
    data: CourseCreateManyCourse_levelInput | CourseCreateManyCourse_levelInput[]
    skipDuplicates?: boolean
  }

  export type CourseLevelsPerSubjectCreateWithoutCourse_levelInput = {
    subject: SubjectCreateNestedOneWithoutCourseLevelsPerSubjectInput
  }

  export type CourseLevelsPerSubjectUncheckedCreateWithoutCourse_levelInput = {
    subject_code: string
  }

  export type CourseLevelsPerSubjectCreateOrConnectWithoutCourse_levelInput = {
    where: CourseLevelsPerSubjectWhereUniqueInput
    create: XOR<CourseLevelsPerSubjectCreateWithoutCourse_levelInput, CourseLevelsPerSubjectUncheckedCreateWithoutCourse_levelInput>
  }

  export type CourseLevelsPerSubjectCreateManyCourse_levelInputEnvelope = {
    data: CourseLevelsPerSubjectCreateManyCourse_levelInput | CourseLevelsPerSubjectCreateManyCourse_levelInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithWhereUniqueWithoutCourse_levelInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutCourse_levelInput, CourseUncheckedUpdateWithoutCourse_levelInput>
    create: XOR<CourseCreateWithoutCourse_levelInput, CourseUncheckedCreateWithoutCourse_levelInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutCourse_levelInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutCourse_levelInput, CourseUncheckedUpdateWithoutCourse_levelInput>
  }

  export type CourseUpdateManyWithWhereWithoutCourse_levelInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutCourse_levelInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    course_code?: StringFilter<"Course"> | string
    course_name?: StringNullableFilter<"Course"> | string | null
    course_level_id?: StringFilter<"Course"> | string
    created_date?: DateTimeNullableFilter<"Course"> | Date | string | null
    subject_code?: StringFilter<"Course"> | string
  }

  export type CourseLevelsPerSubjectUpsertWithWhereUniqueWithoutCourse_levelInput = {
    where: CourseLevelsPerSubjectWhereUniqueInput
    update: XOR<CourseLevelsPerSubjectUpdateWithoutCourse_levelInput, CourseLevelsPerSubjectUncheckedUpdateWithoutCourse_levelInput>
    create: XOR<CourseLevelsPerSubjectCreateWithoutCourse_levelInput, CourseLevelsPerSubjectUncheckedCreateWithoutCourse_levelInput>
  }

  export type CourseLevelsPerSubjectUpdateWithWhereUniqueWithoutCourse_levelInput = {
    where: CourseLevelsPerSubjectWhereUniqueInput
    data: XOR<CourseLevelsPerSubjectUpdateWithoutCourse_levelInput, CourseLevelsPerSubjectUncheckedUpdateWithoutCourse_levelInput>
  }

  export type CourseLevelsPerSubjectUpdateManyWithWhereWithoutCourse_levelInput = {
    where: CourseLevelsPerSubjectScalarWhereInput
    data: XOR<CourseLevelsPerSubjectUpdateManyMutationInput, CourseLevelsPerSubjectUncheckedUpdateManyWithoutCourse_levelInput>
  }

  export type CourseLevelsPerSubjectScalarWhereInput = {
    AND?: CourseLevelsPerSubjectScalarWhereInput | CourseLevelsPerSubjectScalarWhereInput[]
    OR?: CourseLevelsPerSubjectScalarWhereInput[]
    NOT?: CourseLevelsPerSubjectScalarWhereInput | CourseLevelsPerSubjectScalarWhereInput[]
    course_level_id?: StringFilter<"CourseLevelsPerSubject"> | string
    subject_code?: StringFilter<"CourseLevelsPerSubject"> | string
  }

  export type CourseCreateWithoutSubjectInput = {
    course_code: string
    course_name?: string | null
    created_date?: Date | string | null
    course_level: CourseLevelCreateNestedOneWithoutCourseInput
    course_advice?: CourseAdviceCreateNestedManyWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutIs_instance_of_courseInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutCourseInput
    CourseTask?: CourseTaskCreateNestedManyWithoutCourseInput
    Module?: ModuleCreateNestedManyWithoutCourseInput
    LessonCard?: LessonCardCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutSubjectInput = {
    course_code: string
    course_name?: string | null
    course_level_id: string
    created_date?: Date | string | null
    course_advice?: CourseAdviceUncheckedCreateNestedManyWithoutCourseInput
    classes?: ClassUncheckedCreateNestedManyWithoutIs_instance_of_courseInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutCourseInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutCourseInput
    Module?: ModuleUncheckedCreateNestedManyWithoutCourseInput
    LessonCard?: LessonCardUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutSubjectInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutSubjectInput, CourseUncheckedCreateWithoutSubjectInput>
  }

  export type CourseCreateManySubjectInputEnvelope = {
    data: CourseCreateManySubjectInput | CourseCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type CourseLevelsPerSubjectCreateWithoutSubjectInput = {
    course_level: CourseLevelCreateNestedOneWithoutCourseLevelsPerSubjectInput
  }

  export type CourseLevelsPerSubjectUncheckedCreateWithoutSubjectInput = {
    course_level_id: string
  }

  export type CourseLevelsPerSubjectCreateOrConnectWithoutSubjectInput = {
    where: CourseLevelsPerSubjectWhereUniqueInput
    create: XOR<CourseLevelsPerSubjectCreateWithoutSubjectInput, CourseLevelsPerSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type CourseLevelsPerSubjectCreateManySubjectInputEnvelope = {
    data: CourseLevelsPerSubjectCreateManySubjectInput | CourseLevelsPerSubjectCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithWhereUniqueWithoutSubjectInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutSubjectInput, CourseUncheckedUpdateWithoutSubjectInput>
    create: XOR<CourseCreateWithoutSubjectInput, CourseUncheckedCreateWithoutSubjectInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutSubjectInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutSubjectInput, CourseUncheckedUpdateWithoutSubjectInput>
  }

  export type CourseUpdateManyWithWhereWithoutSubjectInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutSubjectInput>
  }

  export type CourseLevelsPerSubjectUpsertWithWhereUniqueWithoutSubjectInput = {
    where: CourseLevelsPerSubjectWhereUniqueInput
    update: XOR<CourseLevelsPerSubjectUpdateWithoutSubjectInput, CourseLevelsPerSubjectUncheckedUpdateWithoutSubjectInput>
    create: XOR<CourseLevelsPerSubjectCreateWithoutSubjectInput, CourseLevelsPerSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type CourseLevelsPerSubjectUpdateWithWhereUniqueWithoutSubjectInput = {
    where: CourseLevelsPerSubjectWhereUniqueInput
    data: XOR<CourseLevelsPerSubjectUpdateWithoutSubjectInput, CourseLevelsPerSubjectUncheckedUpdateWithoutSubjectInput>
  }

  export type CourseLevelsPerSubjectUpdateManyWithWhereWithoutSubjectInput = {
    where: CourseLevelsPerSubjectScalarWhereInput
    data: XOR<CourseLevelsPerSubjectUpdateManyMutationInput, CourseLevelsPerSubjectUncheckedUpdateManyWithoutSubjectInput>
  }

  export type CourseLevelCreateWithoutCourseLevelsPerSubjectInput = {
    course_level_id: string
    course_level_name: string
    course?: CourseCreateNestedManyWithoutCourse_levelInput
  }

  export type CourseLevelUncheckedCreateWithoutCourseLevelsPerSubjectInput = {
    course_level_id: string
    course_level_name: string
    course?: CourseUncheckedCreateNestedManyWithoutCourse_levelInput
  }

  export type CourseLevelCreateOrConnectWithoutCourseLevelsPerSubjectInput = {
    where: CourseLevelWhereUniqueInput
    create: XOR<CourseLevelCreateWithoutCourseLevelsPerSubjectInput, CourseLevelUncheckedCreateWithoutCourseLevelsPerSubjectInput>
  }

  export type SubjectCreateWithoutCourseLevelsPerSubjectInput = {
    subject_code: string
    subject_name: string
    Course?: CourseCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutCourseLevelsPerSubjectInput = {
    subject_code: string
    subject_name: string
    Course?: CourseUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutCourseLevelsPerSubjectInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutCourseLevelsPerSubjectInput, SubjectUncheckedCreateWithoutCourseLevelsPerSubjectInput>
  }

  export type CourseLevelUpsertWithoutCourseLevelsPerSubjectInput = {
    update: XOR<CourseLevelUpdateWithoutCourseLevelsPerSubjectInput, CourseLevelUncheckedUpdateWithoutCourseLevelsPerSubjectInput>
    create: XOR<CourseLevelCreateWithoutCourseLevelsPerSubjectInput, CourseLevelUncheckedCreateWithoutCourseLevelsPerSubjectInput>
    where?: CourseLevelWhereInput
  }

  export type CourseLevelUpdateToOneWithWhereWithoutCourseLevelsPerSubjectInput = {
    where?: CourseLevelWhereInput
    data: XOR<CourseLevelUpdateWithoutCourseLevelsPerSubjectInput, CourseLevelUncheckedUpdateWithoutCourseLevelsPerSubjectInput>
  }

  export type CourseLevelUpdateWithoutCourseLevelsPerSubjectInput = {
    course_level_id?: StringFieldUpdateOperationsInput | string
    course_level_name?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateManyWithoutCourse_levelNestedInput
  }

  export type CourseLevelUncheckedUpdateWithoutCourseLevelsPerSubjectInput = {
    course_level_id?: StringFieldUpdateOperationsInput | string
    course_level_name?: StringFieldUpdateOperationsInput | string
    course?: CourseUncheckedUpdateManyWithoutCourse_levelNestedInput
  }

  export type SubjectUpsertWithoutCourseLevelsPerSubjectInput = {
    update: XOR<SubjectUpdateWithoutCourseLevelsPerSubjectInput, SubjectUncheckedUpdateWithoutCourseLevelsPerSubjectInput>
    create: XOR<SubjectCreateWithoutCourseLevelsPerSubjectInput, SubjectUncheckedCreateWithoutCourseLevelsPerSubjectInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutCourseLevelsPerSubjectInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutCourseLevelsPerSubjectInput, SubjectUncheckedUpdateWithoutCourseLevelsPerSubjectInput>
  }

  export type SubjectUpdateWithoutCourseLevelsPerSubjectInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
    subject_name?: StringFieldUpdateOperationsInput | string
    Course?: CourseUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutCourseLevelsPerSubjectInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
    subject_name?: StringFieldUpdateOperationsInput | string
    Course?: CourseUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SectionCreateWithoutLessonInput = {
    section_name: string
    section_description?: string | null
    section_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    module: ModuleCreateNestedOneWithoutSectionsInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutSectionInput
    CourseTask?: CourseTaskCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutLessonInput = {
    section_id?: number
    section_name: string
    section_description?: string | null
    section_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    module_id: number
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutSectionInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutLessonInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutLessonInput, SectionUncheckedCreateWithoutLessonInput>
  }

  export type TaskCreateWithoutLessonInput = {
    task_description?: string | null
    task_text?: string | null
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    gap_map?: string | null
    task_type: TaskTypeCreateNestedOneWithoutTaskInput
    task_context: TaskContextCreateNestedOneWithoutTaskInput
    task_forms?: TaskFormCreateNestedManyWithoutTaskInput
    task_options?: TaskOptionCreateNestedManyWithoutTaskInput
    CourseTask?: CourseTaskCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutLessonInput = {
    task_id?: number
    task_description?: string | null
    task_text?: string | null
    task_type_id: number
    task_context_id: string
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    gap_map?: string | null
    task_forms?: TaskFormUncheckedCreateNestedManyWithoutTaskInput
    task_options?: TaskOptionUncheckedCreateNestedManyWithoutTaskInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutLessonInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutLessonInput, TaskUncheckedCreateWithoutLessonInput>
  }

  export type TaskCreateManyLessonInputEnvelope = {
    data: TaskCreateManyLessonInput | TaskCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type CourseStructureCreateWithoutLessonInput = {
    course: CourseCreateNestedOneWithoutCourseStructureInput
    module: ModuleCreateNestedOneWithoutCourseStructureInput
    section: SectionCreateNestedOneWithoutCourseStructureInput
  }

  export type CourseStructureUncheckedCreateWithoutLessonInput = {
    course_id: string
    module_id: number
    section_id: number
  }

  export type CourseStructureCreateOrConnectWithoutLessonInput = {
    where: CourseStructureWhereUniqueInput
    create: XOR<CourseStructureCreateWithoutLessonInput, CourseStructureUncheckedCreateWithoutLessonInput>
  }

  export type CourseStructureCreateManyLessonInputEnvelope = {
    data: CourseStructureCreateManyLessonInput | CourseStructureCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type CourseTaskCreateWithoutLessonInput = {
    course_task_id: string
    question: string
    course: CourseCreateNestedOneWithoutCourseTaskInput
    module: ModuleCreateNestedOneWithoutCourseTaskInput
    section: SectionCreateNestedOneWithoutCourseTaskInput
    task: TaskCreateNestedOneWithoutCourseTaskInput
    ClassTask?: ClassTaskCreateNestedManyWithoutCourse_taskInput
  }

  export type CourseTaskUncheckedCreateWithoutLessonInput = {
    course_task_id: string
    course_id: string
    module_id: number
    section_id: number
    task_id: number
    question: string
    ClassTask?: ClassTaskUncheckedCreateNestedManyWithoutCourse_taskInput
  }

  export type CourseTaskCreateOrConnectWithoutLessonInput = {
    where: CourseTaskWhereUniqueInput
    create: XOR<CourseTaskCreateWithoutLessonInput, CourseTaskUncheckedCreateWithoutLessonInput>
  }

  export type CourseTaskCreateManyLessonInputEnvelope = {
    data: CourseTaskCreateManyLessonInput | CourseTaskCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type ModuleCreateWithoutLessonsInput = {
    module_name: string
    module_description?: string | null
    module_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    course: CourseCreateNestedOneWithoutModuleInput
    sections?: SectionCreateNestedManyWithoutModuleInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutModuleInput
    CourseTask?: CourseTaskCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutLessonsInput = {
    module_id?: number
    module_name: string
    module_description?: string | null
    module_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    course_id: string
    sections?: SectionUncheckedCreateNestedManyWithoutModuleInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutModuleInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutLessonsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutLessonsInput, ModuleUncheckedCreateWithoutLessonsInput>
  }

  export type LessonCardCreateWithoutLessonInput = {
    card_id: string
    question: string
    answer: string
    example?: string | null
    deck: DeckCreateNestedOneWithoutCardInput
    course: CourseCreateNestedOneWithoutLessonCardInput
  }

  export type LessonCardUncheckedCreateWithoutLessonInput = {
    card_id: string
    deck_id: string
    question: string
    answer: string
    example?: string | null
    course_code: string
  }

  export type LessonCardCreateOrConnectWithoutLessonInput = {
    where: LessonCardWhereUniqueInput
    create: XOR<LessonCardCreateWithoutLessonInput, LessonCardUncheckedCreateWithoutLessonInput>
  }

  export type LessonCardCreateManyLessonInputEnvelope = {
    data: LessonCardCreateManyLessonInput | LessonCardCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type UserCardCreateWithoutLessonInput = {
    user_card_id: string
    question: string
    answer: string
    example?: string | null
    user: UserCreateNestedOneWithoutUserCardInput
  }

  export type UserCardUncheckedCreateWithoutLessonInput = {
    user_card_id: string
    user_id: string
    question: string
    answer: string
    example?: string | null
  }

  export type UserCardCreateOrConnectWithoutLessonInput = {
    where: UserCardWhereUniqueInput
    create: XOR<UserCardCreateWithoutLessonInput, UserCardUncheckedCreateWithoutLessonInput>
  }

  export type UserCardCreateManyLessonInputEnvelope = {
    data: UserCardCreateManyLessonInput | UserCardCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type SectionUpsertWithoutLessonInput = {
    update: XOR<SectionUpdateWithoutLessonInput, SectionUncheckedUpdateWithoutLessonInput>
    create: XOR<SectionCreateWithoutLessonInput, SectionUncheckedCreateWithoutLessonInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutLessonInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutLessonInput, SectionUncheckedUpdateWithoutLessonInput>
  }

  export type SectionUpdateWithoutLessonInput = {
    section_name?: StringFieldUpdateOperationsInput | string
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    section_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    module?: ModuleUpdateOneRequiredWithoutSectionsNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutSectionNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutLessonInput = {
    section_id?: IntFieldUpdateOperationsInput | number
    section_name?: StringFieldUpdateOperationsInput | string
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    section_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    module_id?: IntFieldUpdateOperationsInput | number
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutSectionNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutLessonInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutLessonInput, TaskUncheckedUpdateWithoutLessonInput>
    create: XOR<TaskCreateWithoutLessonInput, TaskUncheckedCreateWithoutLessonInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutLessonInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutLessonInput, TaskUncheckedUpdateWithoutLessonInput>
  }

  export type TaskUpdateManyWithWhereWithoutLessonInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutLessonInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    task_id?: IntFilter<"Task"> | number
    task_description?: StringNullableFilter<"Task"> | string | null
    task_text?: StringNullableFilter<"Task"> | string | null
    task_type_id?: IntFilter<"Task"> | number
    task_context_id?: StringFilter<"Task"> | string
    task_form_id?: IntNullableFilter<"Task"> | number | null
    task_created_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    task_updated_date?: DateTimeNullableFilter<"Task"> | Date | string | null
    deleted?: BoolFilter<"Task"> | boolean
    lesson_id?: IntFilter<"Task"> | number
    gap_map?: StringNullableFilter<"Task"> | string | null
  }

  export type CourseStructureUpsertWithWhereUniqueWithoutLessonInput = {
    where: CourseStructureWhereUniqueInput
    update: XOR<CourseStructureUpdateWithoutLessonInput, CourseStructureUncheckedUpdateWithoutLessonInput>
    create: XOR<CourseStructureCreateWithoutLessonInput, CourseStructureUncheckedCreateWithoutLessonInput>
  }

  export type CourseStructureUpdateWithWhereUniqueWithoutLessonInput = {
    where: CourseStructureWhereUniqueInput
    data: XOR<CourseStructureUpdateWithoutLessonInput, CourseStructureUncheckedUpdateWithoutLessonInput>
  }

  export type CourseStructureUpdateManyWithWhereWithoutLessonInput = {
    where: CourseStructureScalarWhereInput
    data: XOR<CourseStructureUpdateManyMutationInput, CourseStructureUncheckedUpdateManyWithoutLessonInput>
  }

  export type CourseTaskUpsertWithWhereUniqueWithoutLessonInput = {
    where: CourseTaskWhereUniqueInput
    update: XOR<CourseTaskUpdateWithoutLessonInput, CourseTaskUncheckedUpdateWithoutLessonInput>
    create: XOR<CourseTaskCreateWithoutLessonInput, CourseTaskUncheckedCreateWithoutLessonInput>
  }

  export type CourseTaskUpdateWithWhereUniqueWithoutLessonInput = {
    where: CourseTaskWhereUniqueInput
    data: XOR<CourseTaskUpdateWithoutLessonInput, CourseTaskUncheckedUpdateWithoutLessonInput>
  }

  export type CourseTaskUpdateManyWithWhereWithoutLessonInput = {
    where: CourseTaskScalarWhereInput
    data: XOR<CourseTaskUpdateManyMutationInput, CourseTaskUncheckedUpdateManyWithoutLessonInput>
  }

  export type ModuleUpsertWithoutLessonsInput = {
    update: XOR<ModuleUpdateWithoutLessonsInput, ModuleUncheckedUpdateWithoutLessonsInput>
    create: XOR<ModuleCreateWithoutLessonsInput, ModuleUncheckedCreateWithoutLessonsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutLessonsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutLessonsInput, ModuleUncheckedUpdateWithoutLessonsInput>
  }

  export type ModuleUpdateWithoutLessonsInput = {
    module_name?: StringFieldUpdateOperationsInput | string
    module_description?: NullableStringFieldUpdateOperationsInput | string | null
    module_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneRequiredWithoutModuleNestedInput
    sections?: SectionUpdateManyWithoutModuleNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutModuleNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutLessonsInput = {
    module_id?: IntFieldUpdateOperationsInput | number
    module_name?: StringFieldUpdateOperationsInput | string
    module_description?: NullableStringFieldUpdateOperationsInput | string | null
    module_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    course_id?: StringFieldUpdateOperationsInput | string
    sections?: SectionUncheckedUpdateManyWithoutModuleNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutModuleNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type LessonCardUpsertWithWhereUniqueWithoutLessonInput = {
    where: LessonCardWhereUniqueInput
    update: XOR<LessonCardUpdateWithoutLessonInput, LessonCardUncheckedUpdateWithoutLessonInput>
    create: XOR<LessonCardCreateWithoutLessonInput, LessonCardUncheckedCreateWithoutLessonInput>
  }

  export type LessonCardUpdateWithWhereUniqueWithoutLessonInput = {
    where: LessonCardWhereUniqueInput
    data: XOR<LessonCardUpdateWithoutLessonInput, LessonCardUncheckedUpdateWithoutLessonInput>
  }

  export type LessonCardUpdateManyWithWhereWithoutLessonInput = {
    where: LessonCardScalarWhereInput
    data: XOR<LessonCardUpdateManyMutationInput, LessonCardUncheckedUpdateManyWithoutLessonInput>
  }

  export type UserCardUpsertWithWhereUniqueWithoutLessonInput = {
    where: UserCardWhereUniqueInput
    update: XOR<UserCardUpdateWithoutLessonInput, UserCardUncheckedUpdateWithoutLessonInput>
    create: XOR<UserCardCreateWithoutLessonInput, UserCardUncheckedCreateWithoutLessonInput>
  }

  export type UserCardUpdateWithWhereUniqueWithoutLessonInput = {
    where: UserCardWhereUniqueInput
    data: XOR<UserCardUpdateWithoutLessonInput, UserCardUncheckedUpdateWithoutLessonInput>
  }

  export type UserCardUpdateManyWithWhereWithoutLessonInput = {
    where: UserCardScalarWhereInput
    data: XOR<UserCardUpdateManyMutationInput, UserCardUncheckedUpdateManyWithoutLessonInput>
  }

  export type UserCreateWithoutMentorInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_roles?: UserRoleCreateNestedManyWithoutUserInput
    user_application_preferences?: UserApplicationPreferencesCreateNestedManyWithoutUserInput
    is_student_of?: StudentCreateNestedManyWithoutUserInput
    DataRemovalRequest?: DataRemovalRequestCreateNestedManyWithoutUserInput
    Deck?: DeckCreateNestedManyWithoutUserInput
    UserCard?: UserCardCreateNestedManyWithoutUserInput
    VocabularyInbox?: VocabularyInboxCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMentorInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    user_application_preferences?: UserApplicationPreferencesUncheckedCreateNestedManyWithoutUserInput
    is_student_of?: StudentUncheckedCreateNestedManyWithoutUserInput
    DataRemovalRequest?: DataRemovalRequestUncheckedCreateNestedManyWithoutUserInput
    Deck?: DeckUncheckedCreateNestedManyWithoutUserInput
    UserCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    VocabularyInbox?: VocabularyInboxUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMentorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentorInput, UserUncheckedCreateWithoutMentorInput>
  }

  export type MentorsClassesCreateWithoutMentorInput = {
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class: ClassCreateNestedOneWithoutMentor_classesInput
  }

  export type MentorsClassesUncheckedCreateWithoutMentorInput = {
    class_id: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
  }

  export type MentorsClassesCreateOrConnectWithoutMentorInput = {
    where: MentorsClassesWhereUniqueInput
    create: XOR<MentorsClassesCreateWithoutMentorInput, MentorsClassesUncheckedCreateWithoutMentorInput>
  }

  export type MentorsClassesCreateManyMentorInputEnvelope = {
    data: MentorsClassesCreateManyMentorInput | MentorsClassesCreateManyMentorInput[]
    skipDuplicates?: boolean
  }

  export type MentorPayModelCreateWithoutMentorInput = {
    start_date: Date | string
    pay_rate_per_hour: number
    created_date?: Date | string | null
    end_date?: Date | string | null
    deleted?: boolean
    class_size: ClassSizeCreateNestedOneWithoutMentorPayModelInput
  }

  export type MentorPayModelUncheckedCreateWithoutMentorInput = {
    class_size_id: string
    start_date: Date | string
    pay_rate_per_hour: number
    created_date?: Date | string | null
    end_date?: Date | string | null
    deleted?: boolean
  }

  export type MentorPayModelCreateOrConnectWithoutMentorInput = {
    where: MentorPayModelWhereUniqueInput
    create: XOR<MentorPayModelCreateWithoutMentorInput, MentorPayModelUncheckedCreateWithoutMentorInput>
  }

  export type MentorPayModelCreateManyMentorInputEnvelope = {
    data: MentorPayModelCreateManyMentorInput | MentorPayModelCreateManyMentorInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMentorInput = {
    update: XOR<UserUpdateWithoutMentorInput, UserUncheckedUpdateWithoutMentorInput>
    create: XOR<UserCreateWithoutMentorInput, UserUncheckedCreateWithoutMentorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentorInput, UserUncheckedUpdateWithoutMentorInput>
  }

  export type UserUpdateWithoutMentorInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_roles?: UserRoleUpdateManyWithoutUserNestedInput
    user_application_preferences?: UserApplicationPreferencesUpdateManyWithoutUserNestedInput
    is_student_of?: StudentUpdateManyWithoutUserNestedInput
    DataRemovalRequest?: DataRemovalRequestUpdateManyWithoutUserNestedInput
    Deck?: DeckUpdateManyWithoutUserNestedInput
    UserCard?: UserCardUpdateManyWithoutUserNestedInput
    VocabularyInbox?: VocabularyInboxUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMentorInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    user_application_preferences?: UserApplicationPreferencesUncheckedUpdateManyWithoutUserNestedInput
    is_student_of?: StudentUncheckedUpdateManyWithoutUserNestedInput
    DataRemovalRequest?: DataRemovalRequestUncheckedUpdateManyWithoutUserNestedInput
    Deck?: DeckUncheckedUpdateManyWithoutUserNestedInput
    UserCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    VocabularyInbox?: VocabularyInboxUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MentorsClassesUpsertWithWhereUniqueWithoutMentorInput = {
    where: MentorsClassesWhereUniqueInput
    update: XOR<MentorsClassesUpdateWithoutMentorInput, MentorsClassesUncheckedUpdateWithoutMentorInput>
    create: XOR<MentorsClassesCreateWithoutMentorInput, MentorsClassesUncheckedCreateWithoutMentorInput>
  }

  export type MentorsClassesUpdateWithWhereUniqueWithoutMentorInput = {
    where: MentorsClassesWhereUniqueInput
    data: XOR<MentorsClassesUpdateWithoutMentorInput, MentorsClassesUncheckedUpdateWithoutMentorInput>
  }

  export type MentorsClassesUpdateManyWithWhereWithoutMentorInput = {
    where: MentorsClassesScalarWhereInput
    data: XOR<MentorsClassesUpdateManyMutationInput, MentorsClassesUncheckedUpdateManyWithoutMentorInput>
  }

  export type MentorPayModelUpsertWithWhereUniqueWithoutMentorInput = {
    where: MentorPayModelWhereUniqueInput
    update: XOR<MentorPayModelUpdateWithoutMentorInput, MentorPayModelUncheckedUpdateWithoutMentorInput>
    create: XOR<MentorPayModelCreateWithoutMentorInput, MentorPayModelUncheckedCreateWithoutMentorInput>
  }

  export type MentorPayModelUpdateWithWhereUniqueWithoutMentorInput = {
    where: MentorPayModelWhereUniqueInput
    data: XOR<MentorPayModelUpdateWithoutMentorInput, MentorPayModelUncheckedUpdateWithoutMentorInput>
  }

  export type MentorPayModelUpdateManyWithWhereWithoutMentorInput = {
    where: MentorPayModelScalarWhereInput
    data: XOR<MentorPayModelUpdateManyMutationInput, MentorPayModelUncheckedUpdateManyWithoutMentorInput>
  }

  export type MentorCreateWithoutMentor_classesInput = {
    mentor_id: string
    mentor_description_en?: string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    user: UserCreateNestedOneWithoutMentorInput
    MentorPayModel?: MentorPayModelCreateNestedManyWithoutMentorInput
  }

  export type MentorUncheckedCreateWithoutMentor_classesInput = {
    mentor_id: string
    user_id: string
    mentor_description_en?: string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    MentorPayModel?: MentorPayModelUncheckedCreateNestedManyWithoutMentorInput
  }

  export type MentorCreateOrConnectWithoutMentor_classesInput = {
    where: MentorWhereUniqueInput
    create: XOR<MentorCreateWithoutMentor_classesInput, MentorUncheckedCreateWithoutMentor_classesInput>
  }

  export type ClassCreateWithoutMentor_classesInput = {
    class_id: string
    class_code?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class_size_id: ClassSizeCreateNestedOneWithoutClassesInput
    is_instance_of_course: CourseCreateNestedOneWithoutClassesInput
    time_of_day: TimeOfDayCreateNestedOneWithoutClassesInput
    tuition_lang: TuitionLangCreateNestedOneWithoutClassesInput
    students?: StudentCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestCreateNestedManyWithoutClassInput
    class_calls?: ClassCallCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutMentor_classesInput = {
    class_id: string
    class_code?: string | null
    course_id: string
    start_date: Date | string
    end_date?: Date | string | null
    tuition_lang_code: string
    time_of_day_id: string
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    classSizeClass_size_id: string
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestUncheckedCreateNestedManyWithoutClassInput
    class_calls?: ClassCallUncheckedCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutMentor_classesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutMentor_classesInput, ClassUncheckedCreateWithoutMentor_classesInput>
  }

  export type MentorUpsertWithoutMentor_classesInput = {
    update: XOR<MentorUpdateWithoutMentor_classesInput, MentorUncheckedUpdateWithoutMentor_classesInput>
    create: XOR<MentorCreateWithoutMentor_classesInput, MentorUncheckedCreateWithoutMentor_classesInput>
    where?: MentorWhereInput
  }

  export type MentorUpdateToOneWithWhereWithoutMentor_classesInput = {
    where?: MentorWhereInput
    data: XOR<MentorUpdateWithoutMentor_classesInput, MentorUncheckedUpdateWithoutMentor_classesInput>
  }

  export type MentorUpdateWithoutMentor_classesInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    mentor_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutMentorNestedInput
    MentorPayModel?: MentorPayModelUpdateManyWithoutMentorNestedInput
  }

  export type MentorUncheckedUpdateWithoutMentor_classesInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    mentor_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    MentorPayModel?: MentorPayModelUncheckedUpdateManyWithoutMentorNestedInput
  }

  export type ClassUpsertWithoutMentor_classesInput = {
    update: XOR<ClassUpdateWithoutMentor_classesInput, ClassUncheckedUpdateWithoutMentor_classesInput>
    create: XOR<ClassCreateWithoutMentor_classesInput, ClassUncheckedCreateWithoutMentor_classesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutMentor_classesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutMentor_classesInput, ClassUncheckedUpdateWithoutMentor_classesInput>
  }

  export type ClassUpdateWithoutMentor_classesInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class_size_id?: ClassSizeUpdateOneRequiredWithoutClassesNestedInput
    is_instance_of_course?: CourseUpdateOneRequiredWithoutClassesNestedInput
    time_of_day?: TimeOfDayUpdateOneRequiredWithoutClassesNestedInput
    tuition_lang?: TuitionLangUpdateOneRequiredWithoutClassesNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutMentor_classesInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    course_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    classSizeClass_size_id?: StringFieldUpdateOperationsInput | string
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUncheckedUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUncheckedUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUncheckedUpdateManyWithoutClassNestedInput
  }

  export type MentorCreateWithoutMentorPayModelInput = {
    mentor_id: string
    mentor_description_en?: string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    user: UserCreateNestedOneWithoutMentorInput
    mentor_classes?: MentorsClassesCreateNestedManyWithoutMentorInput
  }

  export type MentorUncheckedCreateWithoutMentorPayModelInput = {
    mentor_id: string
    user_id: string
    mentor_description_en?: string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    mentor_classes?: MentorsClassesUncheckedCreateNestedManyWithoutMentorInput
  }

  export type MentorCreateOrConnectWithoutMentorPayModelInput = {
    where: MentorWhereUniqueInput
    create: XOR<MentorCreateWithoutMentorPayModelInput, MentorUncheckedCreateWithoutMentorPayModelInput>
  }

  export type ClassSizeCreateWithoutMentorPayModelInput = {
    class_size_id: string
    class_size_name: $Enums.ClassSizesEnum
    classes?: ClassCreateNestedManyWithoutClass_size_idInput
  }

  export type ClassSizeUncheckedCreateWithoutMentorPayModelInput = {
    class_size_id: string
    class_size_name: $Enums.ClassSizesEnum
    classes?: ClassUncheckedCreateNestedManyWithoutClass_size_idInput
  }

  export type ClassSizeCreateOrConnectWithoutMentorPayModelInput = {
    where: ClassSizeWhereUniqueInput
    create: XOR<ClassSizeCreateWithoutMentorPayModelInput, ClassSizeUncheckedCreateWithoutMentorPayModelInput>
  }

  export type MentorUpsertWithoutMentorPayModelInput = {
    update: XOR<MentorUpdateWithoutMentorPayModelInput, MentorUncheckedUpdateWithoutMentorPayModelInput>
    create: XOR<MentorCreateWithoutMentorPayModelInput, MentorUncheckedCreateWithoutMentorPayModelInput>
    where?: MentorWhereInput
  }

  export type MentorUpdateToOneWithWhereWithoutMentorPayModelInput = {
    where?: MentorWhereInput
    data: XOR<MentorUpdateWithoutMentorPayModelInput, MentorUncheckedUpdateWithoutMentorPayModelInput>
  }

  export type MentorUpdateWithoutMentorPayModelInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    mentor_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutMentorNestedInput
    mentor_classes?: MentorsClassesUpdateManyWithoutMentorNestedInput
  }

  export type MentorUncheckedUpdateWithoutMentorPayModelInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    mentor_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    mentor_classes?: MentorsClassesUncheckedUpdateManyWithoutMentorNestedInput
  }

  export type ClassSizeUpsertWithoutMentorPayModelInput = {
    update: XOR<ClassSizeUpdateWithoutMentorPayModelInput, ClassSizeUncheckedUpdateWithoutMentorPayModelInput>
    create: XOR<ClassSizeCreateWithoutMentorPayModelInput, ClassSizeUncheckedCreateWithoutMentorPayModelInput>
    where?: ClassSizeWhereInput
  }

  export type ClassSizeUpdateToOneWithWhereWithoutMentorPayModelInput = {
    where?: ClassSizeWhereInput
    data: XOR<ClassSizeUpdateWithoutMentorPayModelInput, ClassSizeUncheckedUpdateWithoutMentorPayModelInput>
  }

  export type ClassSizeUpdateWithoutMentorPayModelInput = {
    class_size_id?: StringFieldUpdateOperationsInput | string
    class_size_name?: EnumClassSizesEnumFieldUpdateOperationsInput | $Enums.ClassSizesEnum
    classes?: ClassUpdateManyWithoutClass_size_idNestedInput
  }

  export type ClassSizeUncheckedUpdateWithoutMentorPayModelInput = {
    class_size_id?: StringFieldUpdateOperationsInput | string
    class_size_name?: EnumClassSizesEnumFieldUpdateOperationsInput | $Enums.ClassSizesEnum
    classes?: ClassUncheckedUpdateManyWithoutClass_size_idNestedInput
  }

  export type CourseCreateWithoutModuleInput = {
    course_code: string
    course_name?: string | null
    created_date?: Date | string | null
    course_level: CourseLevelCreateNestedOneWithoutCourseInput
    course_advice?: CourseAdviceCreateNestedManyWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutIs_instance_of_courseInput
    subject?: SubjectCreateNestedOneWithoutCourseInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutCourseInput
    CourseTask?: CourseTaskCreateNestedManyWithoutCourseInput
    LessonCard?: LessonCardCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutModuleInput = {
    course_code: string
    course_name?: string | null
    course_level_id: string
    created_date?: Date | string | null
    subject_code: string
    course_advice?: CourseAdviceUncheckedCreateNestedManyWithoutCourseInput
    classes?: ClassUncheckedCreateNestedManyWithoutIs_instance_of_courseInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutCourseInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutCourseInput
    LessonCard?: LessonCardUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutModuleInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutModuleInput, CourseUncheckedCreateWithoutModuleInput>
  }

  export type SectionCreateWithoutModuleInput = {
    section_name: string
    section_description?: string | null
    section_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    CourseStructure?: CourseStructureCreateNestedManyWithoutSectionInput
    CourseTask?: CourseTaskCreateNestedManyWithoutSectionInput
    Lesson?: LessonCreateNestedManyWithoutSectionInput
  }

  export type SectionUncheckedCreateWithoutModuleInput = {
    section_id?: number
    section_name: string
    section_description?: string | null
    section_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutSectionInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutSectionInput
    Lesson?: LessonUncheckedCreateNestedManyWithoutSectionInput
  }

  export type SectionCreateOrConnectWithoutModuleInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutModuleInput, SectionUncheckedCreateWithoutModuleInput>
  }

  export type SectionCreateManyModuleInputEnvelope = {
    data: SectionCreateManyModuleInput | SectionCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutModuleInput = {
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    section: SectionCreateNestedOneWithoutLessonInput
    tasks?: TaskCreateNestedManyWithoutLessonInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutLessonInput
    CourseTask?: CourseTaskCreateNestedManyWithoutLessonInput
    LessonCard?: LessonCardCreateNestedManyWithoutLessonInput
    UserCard?: UserCardCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutModuleInput = {
    lesson_id?: number
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    section_id: number
    tasks?: TaskUncheckedCreateNestedManyWithoutLessonInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutLessonInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutLessonInput
    LessonCard?: LessonCardUncheckedCreateNestedManyWithoutLessonInput
    UserCard?: UserCardUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutModuleInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput>
  }

  export type LessonCreateManyModuleInputEnvelope = {
    data: LessonCreateManyModuleInput | LessonCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type CourseStructureCreateWithoutModuleInput = {
    course: CourseCreateNestedOneWithoutCourseStructureInput
    section: SectionCreateNestedOneWithoutCourseStructureInput
    lesson: LessonCreateNestedOneWithoutCourseStructureInput
  }

  export type CourseStructureUncheckedCreateWithoutModuleInput = {
    course_id: string
    section_id: number
    lesson_id: number
  }

  export type CourseStructureCreateOrConnectWithoutModuleInput = {
    where: CourseStructureWhereUniqueInput
    create: XOR<CourseStructureCreateWithoutModuleInput, CourseStructureUncheckedCreateWithoutModuleInput>
  }

  export type CourseStructureCreateManyModuleInputEnvelope = {
    data: CourseStructureCreateManyModuleInput | CourseStructureCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type CourseTaskCreateWithoutModuleInput = {
    course_task_id: string
    question: string
    course: CourseCreateNestedOneWithoutCourseTaskInput
    section: SectionCreateNestedOneWithoutCourseTaskInput
    lesson: LessonCreateNestedOneWithoutCourseTaskInput
    task: TaskCreateNestedOneWithoutCourseTaskInput
    ClassTask?: ClassTaskCreateNestedManyWithoutCourse_taskInput
  }

  export type CourseTaskUncheckedCreateWithoutModuleInput = {
    course_task_id: string
    course_id: string
    section_id: number
    lesson_id: number
    task_id: number
    question: string
    ClassTask?: ClassTaskUncheckedCreateNestedManyWithoutCourse_taskInput
  }

  export type CourseTaskCreateOrConnectWithoutModuleInput = {
    where: CourseTaskWhereUniqueInput
    create: XOR<CourseTaskCreateWithoutModuleInput, CourseTaskUncheckedCreateWithoutModuleInput>
  }

  export type CourseTaskCreateManyModuleInputEnvelope = {
    data: CourseTaskCreateManyModuleInput | CourseTaskCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutModuleInput = {
    update: XOR<CourseUpdateWithoutModuleInput, CourseUncheckedUpdateWithoutModuleInput>
    create: XOR<CourseCreateWithoutModuleInput, CourseUncheckedCreateWithoutModuleInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutModuleInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutModuleInput, CourseUncheckedUpdateWithoutModuleInput>
  }

  export type CourseUpdateWithoutModuleInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_level?: CourseLevelUpdateOneRequiredWithoutCourseNestedInput
    course_advice?: CourseAdviceUpdateManyWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutIs_instance_of_courseNestedInput
    subject?: SubjectUpdateOneWithoutCourseNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutCourseNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutCourseNestedInput
    LessonCard?: LessonCardUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutModuleInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    course_level_id?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject_code?: StringFieldUpdateOperationsInput | string
    course_advice?: CourseAdviceUncheckedUpdateManyWithoutCourseNestedInput
    classes?: ClassUncheckedUpdateManyWithoutIs_instance_of_courseNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutCourseNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutCourseNestedInput
    LessonCard?: LessonCardUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type SectionUpsertWithWhereUniqueWithoutModuleInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutModuleInput, SectionUncheckedUpdateWithoutModuleInput>
    create: XOR<SectionCreateWithoutModuleInput, SectionUncheckedCreateWithoutModuleInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutModuleInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutModuleInput, SectionUncheckedUpdateWithoutModuleInput>
  }

  export type SectionUpdateManyWithWhereWithoutModuleInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutModuleInput>
  }

  export type SectionScalarWhereInput = {
    AND?: SectionScalarWhereInput | SectionScalarWhereInput[]
    OR?: SectionScalarWhereInput[]
    NOT?: SectionScalarWhereInput | SectionScalarWhereInput[]
    section_id?: IntFilter<"Section"> | number
    section_name?: StringFilter<"Section"> | string
    section_description?: StringNullableFilter<"Section"> | string | null
    section_order?: IntFilter<"Section"> | number
    created_date?: DateTimeNullableFilter<"Section"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Section"> | Date | string | null
    deleted?: BoolFilter<"Section"> | boolean
    module_id?: IntFilter<"Section"> | number
  }

  export type LessonUpsertWithWhereUniqueWithoutModuleInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutModuleInput, LessonUncheckedUpdateWithoutModuleInput>
    create: XOR<LessonCreateWithoutModuleInput, LessonUncheckedCreateWithoutModuleInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutModuleInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutModuleInput, LessonUncheckedUpdateWithoutModuleInput>
  }

  export type LessonUpdateManyWithWhereWithoutModuleInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutModuleInput>
  }

  export type LessonScalarWhereInput = {
    AND?: LessonScalarWhereInput | LessonScalarWhereInput[]
    OR?: LessonScalarWhereInput[]
    NOT?: LessonScalarWhereInput | LessonScalarWhereInput[]
    lesson_id?: IntFilter<"Lesson"> | number
    lesson_name?: StringFilter<"Lesson"> | string
    lesson_description?: StringNullableFilter<"Lesson"> | string | null
    lesson_order?: IntFilter<"Lesson"> | number
    created_date?: DateTimeNullableFilter<"Lesson"> | Date | string | null
    updated_date?: DateTimeNullableFilter<"Lesson"> | Date | string | null
    deleted?: BoolFilter<"Lesson"> | boolean
    section_id?: IntFilter<"Lesson"> | number
    moduleModule_id?: IntNullableFilter<"Lesson"> | number | null
  }

  export type CourseStructureUpsertWithWhereUniqueWithoutModuleInput = {
    where: CourseStructureWhereUniqueInput
    update: XOR<CourseStructureUpdateWithoutModuleInput, CourseStructureUncheckedUpdateWithoutModuleInput>
    create: XOR<CourseStructureCreateWithoutModuleInput, CourseStructureUncheckedCreateWithoutModuleInput>
  }

  export type CourseStructureUpdateWithWhereUniqueWithoutModuleInput = {
    where: CourseStructureWhereUniqueInput
    data: XOR<CourseStructureUpdateWithoutModuleInput, CourseStructureUncheckedUpdateWithoutModuleInput>
  }

  export type CourseStructureUpdateManyWithWhereWithoutModuleInput = {
    where: CourseStructureScalarWhereInput
    data: XOR<CourseStructureUpdateManyMutationInput, CourseStructureUncheckedUpdateManyWithoutModuleInput>
  }

  export type CourseTaskUpsertWithWhereUniqueWithoutModuleInput = {
    where: CourseTaskWhereUniqueInput
    update: XOR<CourseTaskUpdateWithoutModuleInput, CourseTaskUncheckedUpdateWithoutModuleInput>
    create: XOR<CourseTaskCreateWithoutModuleInput, CourseTaskUncheckedCreateWithoutModuleInput>
  }

  export type CourseTaskUpdateWithWhereUniqueWithoutModuleInput = {
    where: CourseTaskWhereUniqueInput
    data: XOR<CourseTaskUpdateWithoutModuleInput, CourseTaskUncheckedUpdateWithoutModuleInput>
  }

  export type CourseTaskUpdateManyWithWhereWithoutModuleInput = {
    where: CourseTaskScalarWhereInput
    data: XOR<CourseTaskUpdateManyMutationInput, CourseTaskUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModuleCreateWithoutSectionsInput = {
    module_name: string
    module_description?: string | null
    module_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    course: CourseCreateNestedOneWithoutModuleInput
    lessons?: LessonCreateNestedManyWithoutModuleInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutModuleInput
    CourseTask?: CourseTaskCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutSectionsInput = {
    module_id?: number
    module_name: string
    module_description?: string | null
    module_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    course_id: string
    lessons?: LessonUncheckedCreateNestedManyWithoutModuleInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutModuleInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutSectionsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutSectionsInput, ModuleUncheckedCreateWithoutSectionsInput>
  }

  export type CourseStructureCreateWithoutSectionInput = {
    course: CourseCreateNestedOneWithoutCourseStructureInput
    module: ModuleCreateNestedOneWithoutCourseStructureInput
    lesson: LessonCreateNestedOneWithoutCourseStructureInput
  }

  export type CourseStructureUncheckedCreateWithoutSectionInput = {
    course_id: string
    module_id: number
    lesson_id: number
  }

  export type CourseStructureCreateOrConnectWithoutSectionInput = {
    where: CourseStructureWhereUniqueInput
    create: XOR<CourseStructureCreateWithoutSectionInput, CourseStructureUncheckedCreateWithoutSectionInput>
  }

  export type CourseStructureCreateManySectionInputEnvelope = {
    data: CourseStructureCreateManySectionInput | CourseStructureCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type CourseTaskCreateWithoutSectionInput = {
    course_task_id: string
    question: string
    course: CourseCreateNestedOneWithoutCourseTaskInput
    module: ModuleCreateNestedOneWithoutCourseTaskInput
    lesson: LessonCreateNestedOneWithoutCourseTaskInput
    task: TaskCreateNestedOneWithoutCourseTaskInput
    ClassTask?: ClassTaskCreateNestedManyWithoutCourse_taskInput
  }

  export type CourseTaskUncheckedCreateWithoutSectionInput = {
    course_task_id: string
    course_id: string
    module_id: number
    lesson_id: number
    task_id: number
    question: string
    ClassTask?: ClassTaskUncheckedCreateNestedManyWithoutCourse_taskInput
  }

  export type CourseTaskCreateOrConnectWithoutSectionInput = {
    where: CourseTaskWhereUniqueInput
    create: XOR<CourseTaskCreateWithoutSectionInput, CourseTaskUncheckedCreateWithoutSectionInput>
  }

  export type CourseTaskCreateManySectionInputEnvelope = {
    data: CourseTaskCreateManySectionInput | CourseTaskCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutSectionInput = {
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    tasks?: TaskCreateNestedManyWithoutLessonInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutLessonInput
    CourseTask?: CourseTaskCreateNestedManyWithoutLessonInput
    Module?: ModuleCreateNestedOneWithoutLessonsInput
    LessonCard?: LessonCardCreateNestedManyWithoutLessonInput
    UserCard?: UserCardCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutSectionInput = {
    lesson_id?: number
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    moduleModule_id?: number | null
    tasks?: TaskUncheckedCreateNestedManyWithoutLessonInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutLessonInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutLessonInput
    LessonCard?: LessonCardUncheckedCreateNestedManyWithoutLessonInput
    UserCard?: UserCardUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutSectionInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutSectionInput, LessonUncheckedCreateWithoutSectionInput>
  }

  export type LessonCreateManySectionInputEnvelope = {
    data: LessonCreateManySectionInput | LessonCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type ModuleUpsertWithoutSectionsInput = {
    update: XOR<ModuleUpdateWithoutSectionsInput, ModuleUncheckedUpdateWithoutSectionsInput>
    create: XOR<ModuleCreateWithoutSectionsInput, ModuleUncheckedCreateWithoutSectionsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutSectionsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutSectionsInput, ModuleUncheckedUpdateWithoutSectionsInput>
  }

  export type ModuleUpdateWithoutSectionsInput = {
    module_name?: StringFieldUpdateOperationsInput | string
    module_description?: NullableStringFieldUpdateOperationsInput | string | null
    module_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    course?: CourseUpdateOneRequiredWithoutModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutModuleNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutSectionsInput = {
    module_id?: IntFieldUpdateOperationsInput | number
    module_name?: StringFieldUpdateOperationsInput | string
    module_description?: NullableStringFieldUpdateOperationsInput | string | null
    module_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    course_id?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutModuleNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type CourseStructureUpsertWithWhereUniqueWithoutSectionInput = {
    where: CourseStructureWhereUniqueInput
    update: XOR<CourseStructureUpdateWithoutSectionInput, CourseStructureUncheckedUpdateWithoutSectionInput>
    create: XOR<CourseStructureCreateWithoutSectionInput, CourseStructureUncheckedCreateWithoutSectionInput>
  }

  export type CourseStructureUpdateWithWhereUniqueWithoutSectionInput = {
    where: CourseStructureWhereUniqueInput
    data: XOR<CourseStructureUpdateWithoutSectionInput, CourseStructureUncheckedUpdateWithoutSectionInput>
  }

  export type CourseStructureUpdateManyWithWhereWithoutSectionInput = {
    where: CourseStructureScalarWhereInput
    data: XOR<CourseStructureUpdateManyMutationInput, CourseStructureUncheckedUpdateManyWithoutSectionInput>
  }

  export type CourseTaskUpsertWithWhereUniqueWithoutSectionInput = {
    where: CourseTaskWhereUniqueInput
    update: XOR<CourseTaskUpdateWithoutSectionInput, CourseTaskUncheckedUpdateWithoutSectionInput>
    create: XOR<CourseTaskCreateWithoutSectionInput, CourseTaskUncheckedCreateWithoutSectionInput>
  }

  export type CourseTaskUpdateWithWhereUniqueWithoutSectionInput = {
    where: CourseTaskWhereUniqueInput
    data: XOR<CourseTaskUpdateWithoutSectionInput, CourseTaskUncheckedUpdateWithoutSectionInput>
  }

  export type CourseTaskUpdateManyWithWhereWithoutSectionInput = {
    where: CourseTaskScalarWhereInput
    data: XOR<CourseTaskUpdateManyMutationInput, CourseTaskUncheckedUpdateManyWithoutSectionInput>
  }

  export type LessonUpsertWithWhereUniqueWithoutSectionInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutSectionInput, LessonUncheckedUpdateWithoutSectionInput>
    create: XOR<LessonCreateWithoutSectionInput, LessonUncheckedCreateWithoutSectionInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutSectionInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutSectionInput, LessonUncheckedUpdateWithoutSectionInput>
  }

  export type LessonUpdateManyWithWhereWithoutSectionInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutSectionInput>
  }

  export type ClassCreateWithoutTime_of_dayInput = {
    class_id: string
    class_code?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class_size_id: ClassSizeCreateNestedOneWithoutClassesInput
    is_instance_of_course: CourseCreateNestedOneWithoutClassesInput
    tuition_lang: TuitionLangCreateNestedOneWithoutClassesInput
    mentor_classes?: MentorsClassesCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestCreateNestedManyWithoutClassInput
    class_calls?: ClassCallCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutTime_of_dayInput = {
    class_id: string
    class_code?: string | null
    course_id: string
    start_date: Date | string
    end_date?: Date | string | null
    tuition_lang_code: string
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    classSizeClass_size_id: string
    mentor_classes?: MentorsClassesUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestUncheckedCreateNestedManyWithoutClassInput
    class_calls?: ClassCallUncheckedCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutTime_of_dayInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutTime_of_dayInput, ClassUncheckedCreateWithoutTime_of_dayInput>
  }

  export type ClassCreateManyTime_of_dayInputEnvelope = {
    data: ClassCreateManyTime_of_dayInput | ClassCreateManyTime_of_dayInput[]
    skipDuplicates?: boolean
  }

  export type ClassUpsertWithWhereUniqueWithoutTime_of_dayInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutTime_of_dayInput, ClassUncheckedUpdateWithoutTime_of_dayInput>
    create: XOR<ClassCreateWithoutTime_of_dayInput, ClassUncheckedCreateWithoutTime_of_dayInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutTime_of_dayInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutTime_of_dayInput, ClassUncheckedUpdateWithoutTime_of_dayInput>
  }

  export type ClassUpdateManyWithWhereWithoutTime_of_dayInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutTime_of_dayInput>
  }

  export type ClassCreateWithoutTuition_langInput = {
    class_id: string
    class_code?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class_size_id: ClassSizeCreateNestedOneWithoutClassesInput
    is_instance_of_course: CourseCreateNestedOneWithoutClassesInput
    time_of_day: TimeOfDayCreateNestedOneWithoutClassesInput
    mentor_classes?: MentorsClassesCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestCreateNestedManyWithoutClassInput
    class_calls?: ClassCallCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutTuition_langInput = {
    class_id: string
    class_code?: string | null
    course_id: string
    start_date: Date | string
    end_date?: Date | string | null
    time_of_day_id: string
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    classSizeClass_size_id: string
    mentor_classes?: MentorsClassesUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestUncheckedCreateNestedManyWithoutClassInput
    class_calls?: ClassCallUncheckedCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutTuition_langInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutTuition_langInput, ClassUncheckedCreateWithoutTuition_langInput>
  }

  export type ClassCreateManyTuition_langInputEnvelope = {
    data: ClassCreateManyTuition_langInput | ClassCreateManyTuition_langInput[]
    skipDuplicates?: boolean
  }

  export type ClassUpsertWithWhereUniqueWithoutTuition_langInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutTuition_langInput, ClassUncheckedUpdateWithoutTuition_langInput>
    create: XOR<ClassCreateWithoutTuition_langInput, ClassUncheckedCreateWithoutTuition_langInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutTuition_langInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutTuition_langInput, ClassUncheckedUpdateWithoutTuition_langInput>
  }

  export type ClassUpdateManyWithWhereWithoutTuition_langInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutTuition_langInput>
  }

  export type UserCreateWithoutDeckInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_roles?: UserRoleCreateNestedManyWithoutUserInput
    user_application_preferences?: UserApplicationPreferencesCreateNestedManyWithoutUserInput
    mentor?: MentorCreateNestedManyWithoutUserInput
    is_student_of?: StudentCreateNestedManyWithoutUserInput
    DataRemovalRequest?: DataRemovalRequestCreateNestedManyWithoutUserInput
    UserCard?: UserCardCreateNestedManyWithoutUserInput
    VocabularyInbox?: VocabularyInboxCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDeckInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    user_application_preferences?: UserApplicationPreferencesUncheckedCreateNestedManyWithoutUserInput
    mentor?: MentorUncheckedCreateNestedManyWithoutUserInput
    is_student_of?: StudentUncheckedCreateNestedManyWithoutUserInput
    DataRemovalRequest?: DataRemovalRequestUncheckedCreateNestedManyWithoutUserInput
    UserCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    VocabularyInbox?: VocabularyInboxUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDeckInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeckInput, UserUncheckedCreateWithoutDeckInput>
  }

  export type LessonCardCreateWithoutDeckInput = {
    card_id: string
    question: string
    answer: string
    example?: string | null
    course: CourseCreateNestedOneWithoutLessonCardInput
    lesson: LessonCreateNestedOneWithoutLessonCardInput
  }

  export type LessonCardUncheckedCreateWithoutDeckInput = {
    card_id: string
    question: string
    answer: string
    example?: string | null
    course_code: string
    lesson_id: number
  }

  export type LessonCardCreateOrConnectWithoutDeckInput = {
    where: LessonCardWhereUniqueInput
    create: XOR<LessonCardCreateWithoutDeckInput, LessonCardUncheckedCreateWithoutDeckInput>
  }

  export type LessonCardCreateManyDeckInputEnvelope = {
    data: LessonCardCreateManyDeckInput | LessonCardCreateManyDeckInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDeckInput = {
    update: XOR<UserUpdateWithoutDeckInput, UserUncheckedUpdateWithoutDeckInput>
    create: XOR<UserCreateWithoutDeckInput, UserUncheckedCreateWithoutDeckInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeckInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeckInput, UserUncheckedUpdateWithoutDeckInput>
  }

  export type UserUpdateWithoutDeckInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_roles?: UserRoleUpdateManyWithoutUserNestedInput
    user_application_preferences?: UserApplicationPreferencesUpdateManyWithoutUserNestedInput
    mentor?: MentorUpdateManyWithoutUserNestedInput
    is_student_of?: StudentUpdateManyWithoutUserNestedInput
    DataRemovalRequest?: DataRemovalRequestUpdateManyWithoutUserNestedInput
    UserCard?: UserCardUpdateManyWithoutUserNestedInput
    VocabularyInbox?: VocabularyInboxUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeckInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    user_application_preferences?: UserApplicationPreferencesUncheckedUpdateManyWithoutUserNestedInput
    mentor?: MentorUncheckedUpdateManyWithoutUserNestedInput
    is_student_of?: StudentUncheckedUpdateManyWithoutUserNestedInput
    DataRemovalRequest?: DataRemovalRequestUncheckedUpdateManyWithoutUserNestedInput
    UserCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    VocabularyInbox?: VocabularyInboxUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LessonCardUpsertWithWhereUniqueWithoutDeckInput = {
    where: LessonCardWhereUniqueInput
    update: XOR<LessonCardUpdateWithoutDeckInput, LessonCardUncheckedUpdateWithoutDeckInput>
    create: XOR<LessonCardCreateWithoutDeckInput, LessonCardUncheckedCreateWithoutDeckInput>
  }

  export type LessonCardUpdateWithWhereUniqueWithoutDeckInput = {
    where: LessonCardWhereUniqueInput
    data: XOR<LessonCardUpdateWithoutDeckInput, LessonCardUncheckedUpdateWithoutDeckInput>
  }

  export type LessonCardUpdateManyWithWhereWithoutDeckInput = {
    where: LessonCardScalarWhereInput
    data: XOR<LessonCardUpdateManyMutationInput, LessonCardUncheckedUpdateManyWithoutDeckInput>
  }

  export type DeckCreateWithoutCardInput = {
    deck_id: string
    deck_description?: string | null
    user: UserCreateNestedOneWithoutDeckInput
  }

  export type DeckUncheckedCreateWithoutCardInput = {
    deck_id: string
    user_id: string
    deck_description?: string | null
  }

  export type DeckCreateOrConnectWithoutCardInput = {
    where: DeckWhereUniqueInput
    create: XOR<DeckCreateWithoutCardInput, DeckUncheckedCreateWithoutCardInput>
  }

  export type CourseCreateWithoutLessonCardInput = {
    course_code: string
    course_name?: string | null
    created_date?: Date | string | null
    course_level: CourseLevelCreateNestedOneWithoutCourseInput
    course_advice?: CourseAdviceCreateNestedManyWithoutCourseInput
    classes?: ClassCreateNestedManyWithoutIs_instance_of_courseInput
    subject?: SubjectCreateNestedOneWithoutCourseInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutCourseInput
    CourseTask?: CourseTaskCreateNestedManyWithoutCourseInput
    Module?: ModuleCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutLessonCardInput = {
    course_code: string
    course_name?: string | null
    course_level_id: string
    created_date?: Date | string | null
    subject_code: string
    course_advice?: CourseAdviceUncheckedCreateNestedManyWithoutCourseInput
    classes?: ClassUncheckedCreateNestedManyWithoutIs_instance_of_courseInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutCourseInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutCourseInput
    Module?: ModuleUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutLessonCardInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutLessonCardInput, CourseUncheckedCreateWithoutLessonCardInput>
  }

  export type LessonCreateWithoutLessonCardInput = {
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    section: SectionCreateNestedOneWithoutLessonInput
    tasks?: TaskCreateNestedManyWithoutLessonInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutLessonInput
    CourseTask?: CourseTaskCreateNestedManyWithoutLessonInput
    Module?: ModuleCreateNestedOneWithoutLessonsInput
    UserCard?: UserCardCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutLessonCardInput = {
    lesson_id?: number
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    section_id: number
    moduleModule_id?: number | null
    tasks?: TaskUncheckedCreateNestedManyWithoutLessonInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutLessonInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutLessonInput
    UserCard?: UserCardUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutLessonCardInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutLessonCardInput, LessonUncheckedCreateWithoutLessonCardInput>
  }

  export type DeckUpsertWithoutCardInput = {
    update: XOR<DeckUpdateWithoutCardInput, DeckUncheckedUpdateWithoutCardInput>
    create: XOR<DeckCreateWithoutCardInput, DeckUncheckedCreateWithoutCardInput>
    where?: DeckWhereInput
  }

  export type DeckUpdateToOneWithWhereWithoutCardInput = {
    where?: DeckWhereInput
    data: XOR<DeckUpdateWithoutCardInput, DeckUncheckedUpdateWithoutCardInput>
  }

  export type DeckUpdateWithoutCardInput = {
    deck_id?: StringFieldUpdateOperationsInput | string
    deck_description?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutDeckNestedInput
  }

  export type DeckUncheckedUpdateWithoutCardInput = {
    deck_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    deck_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseUpsertWithoutLessonCardInput = {
    update: XOR<CourseUpdateWithoutLessonCardInput, CourseUncheckedUpdateWithoutLessonCardInput>
    create: XOR<CourseCreateWithoutLessonCardInput, CourseUncheckedCreateWithoutLessonCardInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutLessonCardInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutLessonCardInput, CourseUncheckedUpdateWithoutLessonCardInput>
  }

  export type CourseUpdateWithoutLessonCardInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_level?: CourseLevelUpdateOneRequiredWithoutCourseNestedInput
    course_advice?: CourseAdviceUpdateManyWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutIs_instance_of_courseNestedInput
    subject?: SubjectUpdateOneWithoutCourseNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutCourseNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutCourseNestedInput
    Module?: ModuleUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutLessonCardInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    course_level_id?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject_code?: StringFieldUpdateOperationsInput | string
    course_advice?: CourseAdviceUncheckedUpdateManyWithoutCourseNestedInput
    classes?: ClassUncheckedUpdateManyWithoutIs_instance_of_courseNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutCourseNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutCourseNestedInput
    Module?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type LessonUpsertWithoutLessonCardInput = {
    update: XOR<LessonUpdateWithoutLessonCardInput, LessonUncheckedUpdateWithoutLessonCardInput>
    create: XOR<LessonCreateWithoutLessonCardInput, LessonUncheckedCreateWithoutLessonCardInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutLessonCardInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutLessonCardInput, LessonUncheckedUpdateWithoutLessonCardInput>
  }

  export type LessonUpdateWithoutLessonCardInput = {
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    section?: SectionUpdateOneRequiredWithoutLessonNestedInput
    tasks?: TaskUpdateManyWithoutLessonNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutLessonNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutLessonNestedInput
    Module?: ModuleUpdateOneWithoutLessonsNestedInput
    UserCard?: UserCardUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutLessonCardInput = {
    lesson_id?: IntFieldUpdateOperationsInput | number
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    section_id?: IntFieldUpdateOperationsInput | number
    moduleModule_id?: NullableIntFieldUpdateOperationsInput | number | null
    tasks?: TaskUncheckedUpdateManyWithoutLessonNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutLessonNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutLessonNestedInput
    UserCard?: UserCardUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type UserCreateWithoutUserCardInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_roles?: UserRoleCreateNestedManyWithoutUserInput
    user_application_preferences?: UserApplicationPreferencesCreateNestedManyWithoutUserInput
    mentor?: MentorCreateNestedManyWithoutUserInput
    is_student_of?: StudentCreateNestedManyWithoutUserInput
    DataRemovalRequest?: DataRemovalRequestCreateNestedManyWithoutUserInput
    Deck?: DeckCreateNestedManyWithoutUserInput
    VocabularyInbox?: VocabularyInboxCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserCardInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    user_application_preferences?: UserApplicationPreferencesUncheckedCreateNestedManyWithoutUserInput
    mentor?: MentorUncheckedCreateNestedManyWithoutUserInput
    is_student_of?: StudentUncheckedCreateNestedManyWithoutUserInput
    DataRemovalRequest?: DataRemovalRequestUncheckedCreateNestedManyWithoutUserInput
    Deck?: DeckUncheckedCreateNestedManyWithoutUserInput
    VocabularyInbox?: VocabularyInboxUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserCardInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserCardInput, UserUncheckedCreateWithoutUserCardInput>
  }

  export type LessonCreateWithoutUserCardInput = {
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    section: SectionCreateNestedOneWithoutLessonInput
    tasks?: TaskCreateNestedManyWithoutLessonInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutLessonInput
    CourseTask?: CourseTaskCreateNestedManyWithoutLessonInput
    Module?: ModuleCreateNestedOneWithoutLessonsInput
    LessonCard?: LessonCardCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutUserCardInput = {
    lesson_id?: number
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    section_id: number
    moduleModule_id?: number | null
    tasks?: TaskUncheckedCreateNestedManyWithoutLessonInput
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutLessonInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutLessonInput
    LessonCard?: LessonCardUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutUserCardInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutUserCardInput, LessonUncheckedCreateWithoutUserCardInput>
  }

  export type UserUpsertWithoutUserCardInput = {
    update: XOR<UserUpdateWithoutUserCardInput, UserUncheckedUpdateWithoutUserCardInput>
    create: XOR<UserCreateWithoutUserCardInput, UserUncheckedCreateWithoutUserCardInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserCardInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserCardInput, UserUncheckedUpdateWithoutUserCardInput>
  }

  export type UserUpdateWithoutUserCardInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_roles?: UserRoleUpdateManyWithoutUserNestedInput
    user_application_preferences?: UserApplicationPreferencesUpdateManyWithoutUserNestedInput
    mentor?: MentorUpdateManyWithoutUserNestedInput
    is_student_of?: StudentUpdateManyWithoutUserNestedInput
    DataRemovalRequest?: DataRemovalRequestUpdateManyWithoutUserNestedInput
    Deck?: DeckUpdateManyWithoutUserNestedInput
    VocabularyInbox?: VocabularyInboxUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserCardInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    user_application_preferences?: UserApplicationPreferencesUncheckedUpdateManyWithoutUserNestedInput
    mentor?: MentorUncheckedUpdateManyWithoutUserNestedInput
    is_student_of?: StudentUncheckedUpdateManyWithoutUserNestedInput
    DataRemovalRequest?: DataRemovalRequestUncheckedUpdateManyWithoutUserNestedInput
    Deck?: DeckUncheckedUpdateManyWithoutUserNestedInput
    VocabularyInbox?: VocabularyInboxUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LessonUpsertWithoutUserCardInput = {
    update: XOR<LessonUpdateWithoutUserCardInput, LessonUncheckedUpdateWithoutUserCardInput>
    create: XOR<LessonCreateWithoutUserCardInput, LessonUncheckedCreateWithoutUserCardInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutUserCardInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutUserCardInput, LessonUncheckedUpdateWithoutUserCardInput>
  }

  export type LessonUpdateWithoutUserCardInput = {
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    section?: SectionUpdateOneRequiredWithoutLessonNestedInput
    tasks?: TaskUpdateManyWithoutLessonNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutLessonNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutLessonNestedInput
    Module?: ModuleUpdateOneWithoutLessonsNestedInput
    LessonCard?: LessonCardUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutUserCardInput = {
    lesson_id?: IntFieldUpdateOperationsInput | number
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    section_id?: IntFieldUpdateOperationsInput | number
    moduleModule_id?: NullableIntFieldUpdateOperationsInput | number | null
    tasks?: TaskUncheckedUpdateManyWithoutLessonNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutLessonNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutLessonNestedInput
    LessonCard?: LessonCardUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type UserCreateWithoutVocabularyInboxInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_roles?: UserRoleCreateNestedManyWithoutUserInput
    user_application_preferences?: UserApplicationPreferencesCreateNestedManyWithoutUserInput
    mentor?: MentorCreateNestedManyWithoutUserInput
    is_student_of?: StudentCreateNestedManyWithoutUserInput
    DataRemovalRequest?: DataRemovalRequestCreateNestedManyWithoutUserInput
    Deck?: DeckCreateNestedManyWithoutUserInput
    UserCard?: UserCardCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVocabularyInboxInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    user_application_preferences?: UserApplicationPreferencesUncheckedCreateNestedManyWithoutUserInput
    mentor?: MentorUncheckedCreateNestedManyWithoutUserInput
    is_student_of?: StudentUncheckedCreateNestedManyWithoutUserInput
    DataRemovalRequest?: DataRemovalRequestUncheckedCreateNestedManyWithoutUserInput
    Deck?: DeckUncheckedCreateNestedManyWithoutUserInput
    UserCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVocabularyInboxInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVocabularyInboxInput, UserUncheckedCreateWithoutVocabularyInboxInput>
  }

  export type UserUpsertWithoutVocabularyInboxInput = {
    update: XOR<UserUpdateWithoutVocabularyInboxInput, UserUncheckedUpdateWithoutVocabularyInboxInput>
    create: XOR<UserCreateWithoutVocabularyInboxInput, UserUncheckedCreateWithoutVocabularyInboxInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVocabularyInboxInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVocabularyInboxInput, UserUncheckedUpdateWithoutVocabularyInboxInput>
  }

  export type UserUpdateWithoutVocabularyInboxInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_roles?: UserRoleUpdateManyWithoutUserNestedInput
    user_application_preferences?: UserApplicationPreferencesUpdateManyWithoutUserNestedInput
    mentor?: MentorUpdateManyWithoutUserNestedInput
    is_student_of?: StudentUpdateManyWithoutUserNestedInput
    DataRemovalRequest?: DataRemovalRequestUpdateManyWithoutUserNestedInput
    Deck?: DeckUpdateManyWithoutUserNestedInput
    UserCard?: UserCardUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVocabularyInboxInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    user_application_preferences?: UserApplicationPreferencesUncheckedUpdateManyWithoutUserNestedInput
    mentor?: MentorUncheckedUpdateManyWithoutUserNestedInput
    is_student_of?: StudentUncheckedUpdateManyWithoutUserNestedInput
    DataRemovalRequest?: DataRemovalRequestUncheckedUpdateManyWithoutUserNestedInput
    Deck?: DeckUncheckedUpdateManyWithoutUserNestedInput
    UserCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassCreateWithoutBooking_requestsInput = {
    class_id: string
    class_code?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class_size_id: ClassSizeCreateNestedOneWithoutClassesInput
    is_instance_of_course: CourseCreateNestedOneWithoutClassesInput
    time_of_day: TimeOfDayCreateNestedOneWithoutClassesInput
    tuition_lang: TuitionLangCreateNestedOneWithoutClassesInput
    mentor_classes?: MentorsClassesCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    class_calls?: ClassCallCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutBooking_requestsInput = {
    class_id: string
    class_code?: string | null
    course_id: string
    start_date: Date | string
    end_date?: Date | string | null
    tuition_lang_code: string
    time_of_day_id: string
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    classSizeClass_size_id: string
    mentor_classes?: MentorsClassesUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    class_calls?: ClassCallUncheckedCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutBooking_requestsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutBooking_requestsInput, ClassUncheckedCreateWithoutBooking_requestsInput>
  }

  export type ClassUpsertWithoutBooking_requestsInput = {
    update: XOR<ClassUpdateWithoutBooking_requestsInput, ClassUncheckedUpdateWithoutBooking_requestsInput>
    create: XOR<ClassCreateWithoutBooking_requestsInput, ClassUncheckedCreateWithoutBooking_requestsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutBooking_requestsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutBooking_requestsInput, ClassUncheckedUpdateWithoutBooking_requestsInput>
  }

  export type ClassUpdateWithoutBooking_requestsInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class_size_id?: ClassSizeUpdateOneRequiredWithoutClassesNestedInput
    is_instance_of_course?: CourseUpdateOneRequiredWithoutClassesNestedInput
    time_of_day?: TimeOfDayUpdateOneRequiredWithoutClassesNestedInput
    tuition_lang?: TuitionLangUpdateOneRequiredWithoutClassesNestedInput
    mentor_classes?: MentorsClassesUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutBooking_requestsInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    course_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    classSizeClass_size_id?: StringFieldUpdateOperationsInput | string
    mentor_classes?: MentorsClassesUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUncheckedUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUncheckedUpdateManyWithoutClassNestedInput
  }

  export type CourseTaskCreateWithoutClassTaskInput = {
    course_task_id: string
    question: string
    course: CourseCreateNestedOneWithoutCourseTaskInput
    module: ModuleCreateNestedOneWithoutCourseTaskInput
    section: SectionCreateNestedOneWithoutCourseTaskInput
    lesson: LessonCreateNestedOneWithoutCourseTaskInput
    task: TaskCreateNestedOneWithoutCourseTaskInput
  }

  export type CourseTaskUncheckedCreateWithoutClassTaskInput = {
    course_task_id: string
    course_id: string
    module_id: number
    section_id: number
    lesson_id: number
    task_id: number
    question: string
  }

  export type CourseTaskCreateOrConnectWithoutClassTaskInput = {
    where: CourseTaskWhereUniqueInput
    create: XOR<CourseTaskCreateWithoutClassTaskInput, CourseTaskUncheckedCreateWithoutClassTaskInput>
  }

  export type ClassCreateWithoutClassTaskInput = {
    class_id: string
    class_code?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class_size_id: ClassSizeCreateNestedOneWithoutClassesInput
    is_instance_of_course: CourseCreateNestedOneWithoutClassesInput
    time_of_day: TimeOfDayCreateNestedOneWithoutClassesInput
    tuition_lang: TuitionLangCreateNestedOneWithoutClassesInput
    mentor_classes?: MentorsClassesCreateNestedManyWithoutClassInput
    students?: StudentCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestCreateNestedManyWithoutClassInput
    class_calls?: ClassCallCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutClassTaskInput = {
    class_id: string
    class_code?: string | null
    course_id: string
    start_date: Date | string
    end_date?: Date | string | null
    tuition_lang_code: string
    time_of_day_id: string
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    classSizeClass_size_id: string
    mentor_classes?: MentorsClassesUncheckedCreateNestedManyWithoutClassInput
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestUncheckedCreateNestedManyWithoutClassInput
    class_calls?: ClassCallUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutClassTaskInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutClassTaskInput, ClassUncheckedCreateWithoutClassTaskInput>
  }

  export type StudentTaskCreateWithoutClass_taskInput = {
    task_status: $Enums.StudentTaskStatus
    student: StudentCreateNestedOneWithoutStudent_taskInput
  }

  export type StudentTaskUncheckedCreateWithoutClass_taskInput = {
    student_task_id?: number
    student_id: string
    task_status: $Enums.StudentTaskStatus
  }

  export type StudentTaskCreateOrConnectWithoutClass_taskInput = {
    where: StudentTaskWhereUniqueInput
    create: XOR<StudentTaskCreateWithoutClass_taskInput, StudentTaskUncheckedCreateWithoutClass_taskInput>
  }

  export type StudentTaskCreateManyClass_taskInputEnvelope = {
    data: StudentTaskCreateManyClass_taskInput | StudentTaskCreateManyClass_taskInput[]
    skipDuplicates?: boolean
  }

  export type StudentAnswerCreateWithoutClass_taskInput = {
    answer: string
    student: StudentCreateNestedOneWithoutStudent_answersInput
  }

  export type StudentAnswerUncheckedCreateWithoutClass_taskInput = {
    student_answer_id?: number
    student_id: string
    answer: string
  }

  export type StudentAnswerCreateOrConnectWithoutClass_taskInput = {
    where: StudentAnswerWhereUniqueInput
    create: XOR<StudentAnswerCreateWithoutClass_taskInput, StudentAnswerUncheckedCreateWithoutClass_taskInput>
  }

  export type StudentAnswerCreateManyClass_taskInputEnvelope = {
    data: StudentAnswerCreateManyClass_taskInput | StudentAnswerCreateManyClass_taskInput[]
    skipDuplicates?: boolean
  }

  export type CourseTaskUpsertWithoutClassTaskInput = {
    update: XOR<CourseTaskUpdateWithoutClassTaskInput, CourseTaskUncheckedUpdateWithoutClassTaskInput>
    create: XOR<CourseTaskCreateWithoutClassTaskInput, CourseTaskUncheckedCreateWithoutClassTaskInput>
    where?: CourseTaskWhereInput
  }

  export type CourseTaskUpdateToOneWithWhereWithoutClassTaskInput = {
    where?: CourseTaskWhereInput
    data: XOR<CourseTaskUpdateWithoutClassTaskInput, CourseTaskUncheckedUpdateWithoutClassTaskInput>
  }

  export type CourseTaskUpdateWithoutClassTaskInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutCourseTaskNestedInput
    module?: ModuleUpdateOneRequiredWithoutCourseTaskNestedInput
    section?: SectionUpdateOneRequiredWithoutCourseTaskNestedInput
    lesson?: LessonUpdateOneRequiredWithoutCourseTaskNestedInput
    task?: TaskUpdateOneRequiredWithoutCourseTaskNestedInput
  }

  export type CourseTaskUncheckedUpdateWithoutClassTaskInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    module_id?: IntFieldUpdateOperationsInput | number
    section_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
  }

  export type ClassUpsertWithoutClassTaskInput = {
    update: XOR<ClassUpdateWithoutClassTaskInput, ClassUncheckedUpdateWithoutClassTaskInput>
    create: XOR<ClassCreateWithoutClassTaskInput, ClassUncheckedCreateWithoutClassTaskInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutClassTaskInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutClassTaskInput, ClassUncheckedUpdateWithoutClassTaskInput>
  }

  export type ClassUpdateWithoutClassTaskInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class_size_id?: ClassSizeUpdateOneRequiredWithoutClassesNestedInput
    is_instance_of_course?: CourseUpdateOneRequiredWithoutClassesNestedInput
    time_of_day?: TimeOfDayUpdateOneRequiredWithoutClassesNestedInput
    tuition_lang?: TuitionLangUpdateOneRequiredWithoutClassesNestedInput
    mentor_classes?: MentorsClassesUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutClassTaskInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    course_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    classSizeClass_size_id?: StringFieldUpdateOperationsInput | string
    mentor_classes?: MentorsClassesUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUncheckedUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUncheckedUpdateManyWithoutClassNestedInput
  }

  export type StudentTaskUpsertWithWhereUniqueWithoutClass_taskInput = {
    where: StudentTaskWhereUniqueInput
    update: XOR<StudentTaskUpdateWithoutClass_taskInput, StudentTaskUncheckedUpdateWithoutClass_taskInput>
    create: XOR<StudentTaskCreateWithoutClass_taskInput, StudentTaskUncheckedCreateWithoutClass_taskInput>
  }

  export type StudentTaskUpdateWithWhereUniqueWithoutClass_taskInput = {
    where: StudentTaskWhereUniqueInput
    data: XOR<StudentTaskUpdateWithoutClass_taskInput, StudentTaskUncheckedUpdateWithoutClass_taskInput>
  }

  export type StudentTaskUpdateManyWithWhereWithoutClass_taskInput = {
    where: StudentTaskScalarWhereInput
    data: XOR<StudentTaskUpdateManyMutationInput, StudentTaskUncheckedUpdateManyWithoutClass_taskInput>
  }

  export type StudentTaskScalarWhereInput = {
    AND?: StudentTaskScalarWhereInput | StudentTaskScalarWhereInput[]
    OR?: StudentTaskScalarWhereInput[]
    NOT?: StudentTaskScalarWhereInput | StudentTaskScalarWhereInput[]
    student_task_id?: IntFilter<"StudentTask"> | number
    student_id?: StringFilter<"StudentTask"> | string
    class_task_id?: IntFilter<"StudentTask"> | number
    task_status?: EnumStudentTaskStatusFilter<"StudentTask"> | $Enums.StudentTaskStatus
  }

  export type StudentAnswerUpsertWithWhereUniqueWithoutClass_taskInput = {
    where: StudentAnswerWhereUniqueInput
    update: XOR<StudentAnswerUpdateWithoutClass_taskInput, StudentAnswerUncheckedUpdateWithoutClass_taskInput>
    create: XOR<StudentAnswerCreateWithoutClass_taskInput, StudentAnswerUncheckedCreateWithoutClass_taskInput>
  }

  export type StudentAnswerUpdateWithWhereUniqueWithoutClass_taskInput = {
    where: StudentAnswerWhereUniqueInput
    data: XOR<StudentAnswerUpdateWithoutClass_taskInput, StudentAnswerUncheckedUpdateWithoutClass_taskInput>
  }

  export type StudentAnswerUpdateManyWithWhereWithoutClass_taskInput = {
    where: StudentAnswerScalarWhereInput
    data: XOR<StudentAnswerUpdateManyMutationInput, StudentAnswerUncheckedUpdateManyWithoutClass_taskInput>
  }

  export type StudentAnswerScalarWhereInput = {
    AND?: StudentAnswerScalarWhereInput | StudentAnswerScalarWhereInput[]
    OR?: StudentAnswerScalarWhereInput[]
    NOT?: StudentAnswerScalarWhereInput | StudentAnswerScalarWhereInput[]
    student_answer_id?: IntFilter<"StudentAnswer"> | number
    student_id?: StringFilter<"StudentAnswer"> | string
    class_task_id?: IntFilter<"StudentAnswer"> | number
    answer?: StringFilter<"StudentAnswer"> | string
  }

  export type UserCreateWithoutIs_student_ofInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_roles?: UserRoleCreateNestedManyWithoutUserInput
    user_application_preferences?: UserApplicationPreferencesCreateNestedManyWithoutUserInput
    mentor?: MentorCreateNestedManyWithoutUserInput
    DataRemovalRequest?: DataRemovalRequestCreateNestedManyWithoutUserInput
    Deck?: DeckCreateNestedManyWithoutUserInput
    UserCard?: UserCardCreateNestedManyWithoutUserInput
    VocabularyInbox?: VocabularyInboxCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutIs_student_ofInput = {
    user_email: string
    created_at?: Date | string
    updated_at?: Date | string | null
    first_name: string
    last_name: string
    nickname?: string | null
    deleted?: boolean
    user_roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    user_application_preferences?: UserApplicationPreferencesUncheckedCreateNestedManyWithoutUserInput
    mentor?: MentorUncheckedCreateNestedManyWithoutUserInput
    DataRemovalRequest?: DataRemovalRequestUncheckedCreateNestedManyWithoutUserInput
    Deck?: DeckUncheckedCreateNestedManyWithoutUserInput
    UserCard?: UserCardUncheckedCreateNestedManyWithoutUserInput
    VocabularyInbox?: VocabularyInboxUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutIs_student_ofInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIs_student_ofInput, UserUncheckedCreateWithoutIs_student_ofInput>
  }

  export type ClassCreateWithoutStudentsInput = {
    class_id: string
    class_code?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class_size_id: ClassSizeCreateNestedOneWithoutClassesInput
    is_instance_of_course: CourseCreateNestedOneWithoutClassesInput
    time_of_day: TimeOfDayCreateNestedOneWithoutClassesInput
    tuition_lang: TuitionLangCreateNestedOneWithoutClassesInput
    mentor_classes?: MentorsClassesCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestCreateNestedManyWithoutClassInput
    class_calls?: ClassCallCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutStudentsInput = {
    class_id: string
    class_code?: string | null
    course_id: string
    start_date: Date | string
    end_date?: Date | string | null
    tuition_lang_code: string
    time_of_day_id: string
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    classSizeClass_size_id: string
    mentor_classes?: MentorsClassesUncheckedCreateNestedManyWithoutClassInput
    booking_requests?: BookingRequestUncheckedCreateNestedManyWithoutClassInput
    class_calls?: ClassCallUncheckedCreateNestedManyWithoutClassInput
    ClassTask?: ClassTaskUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutStudentsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
  }

  export type StudentTaskCreateWithoutStudentInput = {
    task_status: $Enums.StudentTaskStatus
    class_task: ClassTaskCreateNestedOneWithoutStudent_tasksInput
  }

  export type StudentTaskUncheckedCreateWithoutStudentInput = {
    student_task_id?: number
    class_task_id: number
    task_status: $Enums.StudentTaskStatus
  }

  export type StudentTaskCreateOrConnectWithoutStudentInput = {
    where: StudentTaskWhereUniqueInput
    create: XOR<StudentTaskCreateWithoutStudentInput, StudentTaskUncheckedCreateWithoutStudentInput>
  }

  export type StudentTaskCreateManyStudentInputEnvelope = {
    data: StudentTaskCreateManyStudentInput | StudentTaskCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentAnswerCreateWithoutStudentInput = {
    answer: string
    class_task: ClassTaskCreateNestedOneWithoutStudent_answerInput
  }

  export type StudentAnswerUncheckedCreateWithoutStudentInput = {
    student_answer_id?: number
    class_task_id: number
    answer: string
  }

  export type StudentAnswerCreateOrConnectWithoutStudentInput = {
    where: StudentAnswerWhereUniqueInput
    create: XOR<StudentAnswerCreateWithoutStudentInput, StudentAnswerUncheckedCreateWithoutStudentInput>
  }

  export type StudentAnswerCreateManyStudentInputEnvelope = {
    data: StudentAnswerCreateManyStudentInput | StudentAnswerCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutIs_student_ofInput = {
    update: XOR<UserUpdateWithoutIs_student_ofInput, UserUncheckedUpdateWithoutIs_student_ofInput>
    create: XOR<UserCreateWithoutIs_student_ofInput, UserUncheckedCreateWithoutIs_student_ofInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIs_student_ofInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIs_student_ofInput, UserUncheckedUpdateWithoutIs_student_ofInput>
  }

  export type UserUpdateWithoutIs_student_ofInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_roles?: UserRoleUpdateManyWithoutUserNestedInput
    user_application_preferences?: UserApplicationPreferencesUpdateManyWithoutUserNestedInput
    mentor?: MentorUpdateManyWithoutUserNestedInput
    DataRemovalRequest?: DataRemovalRequestUpdateManyWithoutUserNestedInput
    Deck?: DeckUpdateManyWithoutUserNestedInput
    UserCard?: UserCardUpdateManyWithoutUserNestedInput
    VocabularyInbox?: VocabularyInboxUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutIs_student_ofInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user_roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    user_application_preferences?: UserApplicationPreferencesUncheckedUpdateManyWithoutUserNestedInput
    mentor?: MentorUncheckedUpdateManyWithoutUserNestedInput
    DataRemovalRequest?: DataRemovalRequestUncheckedUpdateManyWithoutUserNestedInput
    Deck?: DeckUncheckedUpdateManyWithoutUserNestedInput
    UserCard?: UserCardUncheckedUpdateManyWithoutUserNestedInput
    VocabularyInbox?: VocabularyInboxUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassUpsertWithoutStudentsInput = {
    update: XOR<ClassUpdateWithoutStudentsInput, ClassUncheckedUpdateWithoutStudentsInput>
    create: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutStudentsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutStudentsInput, ClassUncheckedUpdateWithoutStudentsInput>
  }

  export type ClassUpdateWithoutStudentsInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class_size_id?: ClassSizeUpdateOneRequiredWithoutClassesNestedInput
    is_instance_of_course?: CourseUpdateOneRequiredWithoutClassesNestedInput
    time_of_day?: TimeOfDayUpdateOneRequiredWithoutClassesNestedInput
    tuition_lang?: TuitionLangUpdateOneRequiredWithoutClassesNestedInput
    mentor_classes?: MentorsClassesUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutStudentsInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    course_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    classSizeClass_size_id?: StringFieldUpdateOperationsInput | string
    mentor_classes?: MentorsClassesUncheckedUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUncheckedUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUncheckedUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUncheckedUpdateManyWithoutClassNestedInput
  }

  export type StudentTaskUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentTaskWhereUniqueInput
    update: XOR<StudentTaskUpdateWithoutStudentInput, StudentTaskUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentTaskCreateWithoutStudentInput, StudentTaskUncheckedCreateWithoutStudentInput>
  }

  export type StudentTaskUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentTaskWhereUniqueInput
    data: XOR<StudentTaskUpdateWithoutStudentInput, StudentTaskUncheckedUpdateWithoutStudentInput>
  }

  export type StudentTaskUpdateManyWithWhereWithoutStudentInput = {
    where: StudentTaskScalarWhereInput
    data: XOR<StudentTaskUpdateManyMutationInput, StudentTaskUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentAnswerUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentAnswerWhereUniqueInput
    update: XOR<StudentAnswerUpdateWithoutStudentInput, StudentAnswerUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentAnswerCreateWithoutStudentInput, StudentAnswerUncheckedCreateWithoutStudentInput>
  }

  export type StudentAnswerUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentAnswerWhereUniqueInput
    data: XOR<StudentAnswerUpdateWithoutStudentInput, StudentAnswerUncheckedUpdateWithoutStudentInput>
  }

  export type StudentAnswerUpdateManyWithWhereWithoutStudentInput = {
    where: StudentAnswerScalarWhereInput
    data: XOR<StudentAnswerUpdateManyMutationInput, StudentAnswerUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentCreateWithoutStudent_answersInput = {
    student_id: string
    student_nickname?: string | null
    enrolled_date?: Date | string | null
    left_date?: Date | string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    user: UserCreateNestedOneWithoutIs_student_ofInput
    class: ClassCreateNestedOneWithoutStudentsInput
    student_task?: StudentTaskCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudent_answersInput = {
    student_id: string
    user_id: string
    student_nickname?: string | null
    enrolled_date?: Date | string | null
    left_date?: Date | string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class_id: string
    student_task?: StudentTaskUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudent_answersInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudent_answersInput, StudentUncheckedCreateWithoutStudent_answersInput>
  }

  export type ClassTaskCreateWithoutStudent_answerInput = {
    course_task: CourseTaskCreateNestedOneWithoutClassTaskInput
    class: ClassCreateNestedOneWithoutClassTaskInput
    student_tasks?: StudentTaskCreateNestedManyWithoutClass_taskInput
  }

  export type ClassTaskUncheckedCreateWithoutStudent_answerInput = {
    class_task_id?: number
    course_task_id: string
    class_id: string
    student_tasks?: StudentTaskUncheckedCreateNestedManyWithoutClass_taskInput
  }

  export type ClassTaskCreateOrConnectWithoutStudent_answerInput = {
    where: ClassTaskWhereUniqueInput
    create: XOR<ClassTaskCreateWithoutStudent_answerInput, ClassTaskUncheckedCreateWithoutStudent_answerInput>
  }

  export type StudentUpsertWithoutStudent_answersInput = {
    update: XOR<StudentUpdateWithoutStudent_answersInput, StudentUncheckedUpdateWithoutStudent_answersInput>
    create: XOR<StudentCreateWithoutStudent_answersInput, StudentUncheckedCreateWithoutStudent_answersInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudent_answersInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudent_answersInput, StudentUncheckedUpdateWithoutStudent_answersInput>
  }

  export type StudentUpdateWithoutStudent_answersInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    student_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutIs_student_ofNestedInput
    class?: ClassUpdateOneRequiredWithoutStudentsNestedInput
    student_task?: StudentTaskUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudent_answersInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    student_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class_id?: StringFieldUpdateOperationsInput | string
    student_task?: StudentTaskUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ClassTaskUpsertWithoutStudent_answerInput = {
    update: XOR<ClassTaskUpdateWithoutStudent_answerInput, ClassTaskUncheckedUpdateWithoutStudent_answerInput>
    create: XOR<ClassTaskCreateWithoutStudent_answerInput, ClassTaskUncheckedCreateWithoutStudent_answerInput>
    where?: ClassTaskWhereInput
  }

  export type ClassTaskUpdateToOneWithWhereWithoutStudent_answerInput = {
    where?: ClassTaskWhereInput
    data: XOR<ClassTaskUpdateWithoutStudent_answerInput, ClassTaskUncheckedUpdateWithoutStudent_answerInput>
  }

  export type ClassTaskUpdateWithoutStudent_answerInput = {
    course_task?: CourseTaskUpdateOneRequiredWithoutClassTaskNestedInput
    class?: ClassUpdateOneRequiredWithoutClassTaskNestedInput
    student_tasks?: StudentTaskUpdateManyWithoutClass_taskNestedInput
  }

  export type ClassTaskUncheckedUpdateWithoutStudent_answerInput = {
    class_task_id?: IntFieldUpdateOperationsInput | number
    course_task_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    student_tasks?: StudentTaskUncheckedUpdateManyWithoutClass_taskNestedInput
  }

  export type StudentCreateWithoutStudent_taskInput = {
    student_id: string
    student_nickname?: string | null
    enrolled_date?: Date | string | null
    left_date?: Date | string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    user: UserCreateNestedOneWithoutIs_student_ofInput
    class: ClassCreateNestedOneWithoutStudentsInput
    student_answers?: StudentAnswerCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudent_taskInput = {
    student_id: string
    user_id: string
    student_nickname?: string | null
    enrolled_date?: Date | string | null
    left_date?: Date | string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class_id: string
    student_answers?: StudentAnswerUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudent_taskInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudent_taskInput, StudentUncheckedCreateWithoutStudent_taskInput>
  }

  export type ClassTaskCreateWithoutStudent_tasksInput = {
    course_task: CourseTaskCreateNestedOneWithoutClassTaskInput
    class: ClassCreateNestedOneWithoutClassTaskInput
    student_answer?: StudentAnswerCreateNestedManyWithoutClass_taskInput
  }

  export type ClassTaskUncheckedCreateWithoutStudent_tasksInput = {
    class_task_id?: number
    course_task_id: string
    class_id: string
    student_answer?: StudentAnswerUncheckedCreateNestedManyWithoutClass_taskInput
  }

  export type ClassTaskCreateOrConnectWithoutStudent_tasksInput = {
    where: ClassTaskWhereUniqueInput
    create: XOR<ClassTaskCreateWithoutStudent_tasksInput, ClassTaskUncheckedCreateWithoutStudent_tasksInput>
  }

  export type StudentUpsertWithoutStudent_taskInput = {
    update: XOR<StudentUpdateWithoutStudent_taskInput, StudentUncheckedUpdateWithoutStudent_taskInput>
    create: XOR<StudentCreateWithoutStudent_taskInput, StudentUncheckedCreateWithoutStudent_taskInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudent_taskInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudent_taskInput, StudentUncheckedUpdateWithoutStudent_taskInput>
  }

  export type StudentUpdateWithoutStudent_taskInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    student_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutIs_student_ofNestedInput
    class?: ClassUpdateOneRequiredWithoutStudentsNestedInput
    student_answers?: StudentAnswerUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudent_taskInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    student_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class_id?: StringFieldUpdateOperationsInput | string
    student_answers?: StudentAnswerUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ClassTaskUpsertWithoutStudent_tasksInput = {
    update: XOR<ClassTaskUpdateWithoutStudent_tasksInput, ClassTaskUncheckedUpdateWithoutStudent_tasksInput>
    create: XOR<ClassTaskCreateWithoutStudent_tasksInput, ClassTaskUncheckedCreateWithoutStudent_tasksInput>
    where?: ClassTaskWhereInput
  }

  export type ClassTaskUpdateToOneWithWhereWithoutStudent_tasksInput = {
    where?: ClassTaskWhereInput
    data: XOR<ClassTaskUpdateWithoutStudent_tasksInput, ClassTaskUncheckedUpdateWithoutStudent_tasksInput>
  }

  export type ClassTaskUpdateWithoutStudent_tasksInput = {
    course_task?: CourseTaskUpdateOneRequiredWithoutClassTaskNestedInput
    class?: ClassUpdateOneRequiredWithoutClassTaskNestedInput
    student_answer?: StudentAnswerUpdateManyWithoutClass_taskNestedInput
  }

  export type ClassTaskUncheckedUpdateWithoutStudent_tasksInput = {
    class_task_id?: IntFieldUpdateOperationsInput | number
    course_task_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    student_answer?: StudentAnswerUncheckedUpdateManyWithoutClass_taskNestedInput
  }

  export type TaskTypeCreateWithoutTaskInput = {
    task_type_name: string
    task_type_description?: string | null
  }

  export type TaskTypeUncheckedCreateWithoutTaskInput = {
    task_type_id?: number
    task_type_name: string
    task_type_description?: string | null
  }

  export type TaskTypeCreateOrConnectWithoutTaskInput = {
    where: TaskTypeWhereUniqueInput
    create: XOR<TaskTypeCreateWithoutTaskInput, TaskTypeUncheckedCreateWithoutTaskInput>
  }

  export type TaskContextCreateWithoutTaskInput = {
    task_context_id: string
    task_context_name: string
    task_context_description?: string | null
  }

  export type TaskContextUncheckedCreateWithoutTaskInput = {
    task_context_id: string
    task_context_name: string
    task_context_description?: string | null
  }

  export type TaskContextCreateOrConnectWithoutTaskInput = {
    where: TaskContextWhereUniqueInput
    create: XOR<TaskContextCreateWithoutTaskInput, TaskContextUncheckedCreateWithoutTaskInput>
  }

  export type LessonCreateWithoutTasksInput = {
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    section: SectionCreateNestedOneWithoutLessonInput
    CourseStructure?: CourseStructureCreateNestedManyWithoutLessonInput
    CourseTask?: CourseTaskCreateNestedManyWithoutLessonInput
    Module?: ModuleCreateNestedOneWithoutLessonsInput
    LessonCard?: LessonCardCreateNestedManyWithoutLessonInput
    UserCard?: UserCardCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutTasksInput = {
    lesson_id?: number
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    section_id: number
    moduleModule_id?: number | null
    CourseStructure?: CourseStructureUncheckedCreateNestedManyWithoutLessonInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutLessonInput
    LessonCard?: LessonCardUncheckedCreateNestedManyWithoutLessonInput
    UserCard?: UserCardUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutTasksInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutTasksInput, LessonUncheckedCreateWithoutTasksInput>
  }

  export type TaskFormCreateWithoutTaskInput = {
    task_form_name: string
    task_form_description?: string | null
  }

  export type TaskFormUncheckedCreateWithoutTaskInput = {
    task_form_id?: number
    task_form_name: string
    task_form_description?: string | null
  }

  export type TaskFormCreateOrConnectWithoutTaskInput = {
    where: TaskFormWhereUniqueInput
    create: XOR<TaskFormCreateWithoutTaskInput, TaskFormUncheckedCreateWithoutTaskInput>
  }

  export type TaskOptionCreateWithoutTaskInput = {
    task_option_text: string
    task_option_order?: number | null
    is_correct: boolean
  }

  export type TaskOptionUncheckedCreateWithoutTaskInput = {
    task_option_id?: number
    task_option_text: string
    task_option_order?: number | null
    is_correct: boolean
  }

  export type TaskOptionCreateOrConnectWithoutTaskInput = {
    where: TaskOptionWhereUniqueInput
    create: XOR<TaskOptionCreateWithoutTaskInput, TaskOptionUncheckedCreateWithoutTaskInput>
  }

  export type TaskOptionCreateManyTaskInputEnvelope = {
    data: TaskOptionCreateManyTaskInput | TaskOptionCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type CourseTaskCreateWithoutTaskInput = {
    course_task_id: string
    question: string
    course: CourseCreateNestedOneWithoutCourseTaskInput
    module: ModuleCreateNestedOneWithoutCourseTaskInput
    section: SectionCreateNestedOneWithoutCourseTaskInput
    lesson: LessonCreateNestedOneWithoutCourseTaskInput
    ClassTask?: ClassTaskCreateNestedManyWithoutCourse_taskInput
  }

  export type CourseTaskUncheckedCreateWithoutTaskInput = {
    course_task_id: string
    course_id: string
    module_id: number
    section_id: number
    lesson_id: number
    question: string
    ClassTask?: ClassTaskUncheckedCreateNestedManyWithoutCourse_taskInput
  }

  export type CourseTaskCreateOrConnectWithoutTaskInput = {
    where: CourseTaskWhereUniqueInput
    create: XOR<CourseTaskCreateWithoutTaskInput, CourseTaskUncheckedCreateWithoutTaskInput>
  }

  export type CourseTaskCreateManyTaskInputEnvelope = {
    data: CourseTaskCreateManyTaskInput | CourseTaskCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskTypeUpsertWithoutTaskInput = {
    update: XOR<TaskTypeUpdateWithoutTaskInput, TaskTypeUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskTypeCreateWithoutTaskInput, TaskTypeUncheckedCreateWithoutTaskInput>
    where?: TaskTypeWhereInput
  }

  export type TaskTypeUpdateToOneWithWhereWithoutTaskInput = {
    where?: TaskTypeWhereInput
    data: XOR<TaskTypeUpdateWithoutTaskInput, TaskTypeUncheckedUpdateWithoutTaskInput>
  }

  export type TaskTypeUpdateWithoutTaskInput = {
    task_type_name?: StringFieldUpdateOperationsInput | string
    task_type_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskTypeUncheckedUpdateWithoutTaskInput = {
    task_type_id?: IntFieldUpdateOperationsInput | number
    task_type_name?: StringFieldUpdateOperationsInput | string
    task_type_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskContextUpsertWithoutTaskInput = {
    update: XOR<TaskContextUpdateWithoutTaskInput, TaskContextUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskContextCreateWithoutTaskInput, TaskContextUncheckedCreateWithoutTaskInput>
    where?: TaskContextWhereInput
  }

  export type TaskContextUpdateToOneWithWhereWithoutTaskInput = {
    where?: TaskContextWhereInput
    data: XOR<TaskContextUpdateWithoutTaskInput, TaskContextUncheckedUpdateWithoutTaskInput>
  }

  export type TaskContextUpdateWithoutTaskInput = {
    task_context_id?: StringFieldUpdateOperationsInput | string
    task_context_name?: StringFieldUpdateOperationsInput | string
    task_context_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskContextUncheckedUpdateWithoutTaskInput = {
    task_context_id?: StringFieldUpdateOperationsInput | string
    task_context_name?: StringFieldUpdateOperationsInput | string
    task_context_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LessonUpsertWithoutTasksInput = {
    update: XOR<LessonUpdateWithoutTasksInput, LessonUncheckedUpdateWithoutTasksInput>
    create: XOR<LessonCreateWithoutTasksInput, LessonUncheckedCreateWithoutTasksInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutTasksInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutTasksInput, LessonUncheckedUpdateWithoutTasksInput>
  }

  export type LessonUpdateWithoutTasksInput = {
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    section?: SectionUpdateOneRequiredWithoutLessonNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutLessonNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutLessonNestedInput
    Module?: ModuleUpdateOneWithoutLessonsNestedInput
    LessonCard?: LessonCardUpdateManyWithoutLessonNestedInput
    UserCard?: UserCardUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutTasksInput = {
    lesson_id?: IntFieldUpdateOperationsInput | number
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    section_id?: IntFieldUpdateOperationsInput | number
    moduleModule_id?: NullableIntFieldUpdateOperationsInput | number | null
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutLessonNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutLessonNestedInput
    LessonCard?: LessonCardUncheckedUpdateManyWithoutLessonNestedInput
    UserCard?: UserCardUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type TaskFormUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskFormWhereUniqueInput
    update: XOR<TaskFormUpdateWithoutTaskInput, TaskFormUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskFormCreateWithoutTaskInput, TaskFormUncheckedCreateWithoutTaskInput>
  }

  export type TaskFormUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskFormWhereUniqueInput
    data: XOR<TaskFormUpdateWithoutTaskInput, TaskFormUncheckedUpdateWithoutTaskInput>
  }

  export type TaskFormUpdateManyWithWhereWithoutTaskInput = {
    where: TaskFormScalarWhereInput
    data: XOR<TaskFormUpdateManyMutationInput, TaskFormUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskFormScalarWhereInput = {
    AND?: TaskFormScalarWhereInput | TaskFormScalarWhereInput[]
    OR?: TaskFormScalarWhereInput[]
    NOT?: TaskFormScalarWhereInput | TaskFormScalarWhereInput[]
    task_form_id?: IntFilter<"TaskForm"> | number
    task_form_name?: StringFilter<"TaskForm"> | string
    task_form_description?: StringNullableFilter<"TaskForm"> | string | null
  }

  export type TaskOptionUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskOptionWhereUniqueInput
    update: XOR<TaskOptionUpdateWithoutTaskInput, TaskOptionUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskOptionCreateWithoutTaskInput, TaskOptionUncheckedCreateWithoutTaskInput>
  }

  export type TaskOptionUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskOptionWhereUniqueInput
    data: XOR<TaskOptionUpdateWithoutTaskInput, TaskOptionUncheckedUpdateWithoutTaskInput>
  }

  export type TaskOptionUpdateManyWithWhereWithoutTaskInput = {
    where: TaskOptionScalarWhereInput
    data: XOR<TaskOptionUpdateManyMutationInput, TaskOptionUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskOptionScalarWhereInput = {
    AND?: TaskOptionScalarWhereInput | TaskOptionScalarWhereInput[]
    OR?: TaskOptionScalarWhereInput[]
    NOT?: TaskOptionScalarWhereInput | TaskOptionScalarWhereInput[]
    task_option_id?: IntFilter<"TaskOption"> | number
    task_id?: IntFilter<"TaskOption"> | number
    task_option_text?: StringFilter<"TaskOption"> | string
    task_option_order?: IntNullableFilter<"TaskOption"> | number | null
    is_correct?: BoolFilter<"TaskOption"> | boolean
  }

  export type CourseTaskUpsertWithWhereUniqueWithoutTaskInput = {
    where: CourseTaskWhereUniqueInput
    update: XOR<CourseTaskUpdateWithoutTaskInput, CourseTaskUncheckedUpdateWithoutTaskInput>
    create: XOR<CourseTaskCreateWithoutTaskInput, CourseTaskUncheckedCreateWithoutTaskInput>
  }

  export type CourseTaskUpdateWithWhereUniqueWithoutTaskInput = {
    where: CourseTaskWhereUniqueInput
    data: XOR<CourseTaskUpdateWithoutTaskInput, CourseTaskUncheckedUpdateWithoutTaskInput>
  }

  export type CourseTaskUpdateManyWithWhereWithoutTaskInput = {
    where: CourseTaskScalarWhereInput
    data: XOR<CourseTaskUpdateManyMutationInput, CourseTaskUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskCreateWithoutTask_formsInput = {
    task_description?: string | null
    task_text?: string | null
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    gap_map?: string | null
    task_type: TaskTypeCreateNestedOneWithoutTaskInput
    task_context: TaskContextCreateNestedOneWithoutTaskInput
    lesson: LessonCreateNestedOneWithoutTasksInput
    task_options?: TaskOptionCreateNestedManyWithoutTaskInput
    CourseTask?: CourseTaskCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTask_formsInput = {
    task_id?: number
    task_description?: string | null
    task_text?: string | null
    task_type_id: number
    task_context_id: string
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    lesson_id: number
    gap_map?: string | null
    task_options?: TaskOptionUncheckedCreateNestedManyWithoutTaskInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTask_formsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTask_formsInput, TaskUncheckedCreateWithoutTask_formsInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutTask_formsInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutTask_formsInput, TaskUncheckedUpdateWithoutTask_formsInput>
    create: XOR<TaskCreateWithoutTask_formsInput, TaskUncheckedCreateWithoutTask_formsInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutTask_formsInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutTask_formsInput, TaskUncheckedUpdateWithoutTask_formsInput>
  }

  export type TaskUpdateManyWithWhereWithoutTask_formsInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutTask_formsInput>
  }

  export type TaskCreateWithoutTask_contextInput = {
    task_description?: string | null
    task_text?: string | null
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    gap_map?: string | null
    task_type: TaskTypeCreateNestedOneWithoutTaskInput
    lesson: LessonCreateNestedOneWithoutTasksInput
    task_forms?: TaskFormCreateNestedManyWithoutTaskInput
    task_options?: TaskOptionCreateNestedManyWithoutTaskInput
    CourseTask?: CourseTaskCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTask_contextInput = {
    task_id?: number
    task_description?: string | null
    task_text?: string | null
    task_type_id: number
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    lesson_id: number
    gap_map?: string | null
    task_forms?: TaskFormUncheckedCreateNestedManyWithoutTaskInput
    task_options?: TaskOptionUncheckedCreateNestedManyWithoutTaskInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTask_contextInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTask_contextInput, TaskUncheckedCreateWithoutTask_contextInput>
  }

  export type TaskCreateManyTask_contextInputEnvelope = {
    data: TaskCreateManyTask_contextInput | TaskCreateManyTask_contextInput[]
    skipDuplicates?: boolean
  }

  export type TaskUpsertWithWhereUniqueWithoutTask_contextInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutTask_contextInput, TaskUncheckedUpdateWithoutTask_contextInput>
    create: XOR<TaskCreateWithoutTask_contextInput, TaskUncheckedCreateWithoutTask_contextInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutTask_contextInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutTask_contextInput, TaskUncheckedUpdateWithoutTask_contextInput>
  }

  export type TaskUpdateManyWithWhereWithoutTask_contextInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutTask_contextInput>
  }

  export type TaskCreateWithoutTask_optionsInput = {
    task_description?: string | null
    task_text?: string | null
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    gap_map?: string | null
    task_type: TaskTypeCreateNestedOneWithoutTaskInput
    task_context: TaskContextCreateNestedOneWithoutTaskInput
    lesson: LessonCreateNestedOneWithoutTasksInput
    task_forms?: TaskFormCreateNestedManyWithoutTaskInput
    CourseTask?: CourseTaskCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTask_optionsInput = {
    task_id?: number
    task_description?: string | null
    task_text?: string | null
    task_type_id: number
    task_context_id: string
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    lesson_id: number
    gap_map?: string | null
    task_forms?: TaskFormUncheckedCreateNestedManyWithoutTaskInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTask_optionsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTask_optionsInput, TaskUncheckedCreateWithoutTask_optionsInput>
  }

  export type TaskUpsertWithoutTask_optionsInput = {
    update: XOR<TaskUpdateWithoutTask_optionsInput, TaskUncheckedUpdateWithoutTask_optionsInput>
    create: XOR<TaskCreateWithoutTask_optionsInput, TaskUncheckedCreateWithoutTask_optionsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutTask_optionsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutTask_optionsInput, TaskUncheckedUpdateWithoutTask_optionsInput>
  }

  export type TaskUpdateWithoutTask_optionsInput = {
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
    task_type?: TaskTypeUpdateOneRequiredWithoutTaskNestedInput
    task_context?: TaskContextUpdateOneRequiredWithoutTaskNestedInput
    lesson?: LessonUpdateOneRequiredWithoutTasksNestedInput
    task_forms?: TaskFormUpdateManyWithoutTaskNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTask_optionsInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_type_id?: IntFieldUpdateOperationsInput | number
    task_context_id?: StringFieldUpdateOperationsInput | string
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    lesson_id?: IntFieldUpdateOperationsInput | number
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
    task_forms?: TaskFormUncheckedUpdateManyWithoutTaskNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateWithoutTask_typeInput = {
    task_description?: string | null
    task_text?: string | null
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    gap_map?: string | null
    task_context: TaskContextCreateNestedOneWithoutTaskInput
    lesson: LessonCreateNestedOneWithoutTasksInput
    task_forms?: TaskFormCreateNestedManyWithoutTaskInput
    task_options?: TaskOptionCreateNestedManyWithoutTaskInput
    CourseTask?: CourseTaskCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTask_typeInput = {
    task_id?: number
    task_description?: string | null
    task_text?: string | null
    task_context_id: string
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    lesson_id: number
    gap_map?: string | null
    task_forms?: TaskFormUncheckedCreateNestedManyWithoutTaskInput
    task_options?: TaskOptionUncheckedCreateNestedManyWithoutTaskInput
    CourseTask?: CourseTaskUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTask_typeInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTask_typeInput, TaskUncheckedCreateWithoutTask_typeInput>
  }

  export type TaskCreateManyTask_typeInputEnvelope = {
    data: TaskCreateManyTask_typeInput | TaskCreateManyTask_typeInput[]
    skipDuplicates?: boolean
  }

  export type TaskUpsertWithWhereUniqueWithoutTask_typeInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutTask_typeInput, TaskUncheckedUpdateWithoutTask_typeInput>
    create: XOR<TaskCreateWithoutTask_typeInput, TaskUncheckedCreateWithoutTask_typeInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutTask_typeInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutTask_typeInput, TaskUncheckedUpdateWithoutTask_typeInput>
  }

  export type TaskUpdateManyWithWhereWithoutTask_typeInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutTask_typeInput>
  }

  export type UserRoleCreateManyUserInput = {
    role_id: string
  }

  export type UserApplicationPreferencesCreateManyUserInput = {
    application_id: string
    accepted_privacy_policy: boolean
    accepted_cookies_policy: boolean
  }

  export type MentorCreateManyUserInput = {
    mentor_id: string
    mentor_description_en?: string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
  }

  export type StudentCreateManyUserInput = {
    student_id: string
    student_nickname?: string | null
    enrolled_date?: Date | string | null
    left_date?: Date | string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    class_id: string
  }

  export type DataRemovalRequestCreateManyUserInput = {
    data_removal_request_id?: number
    data_removal_request: string
    data_removal_status?: $Enums.DataRemovalStatusEnum
    data_removal_date: Date | string
  }

  export type DeckCreateManyUserInput = {
    deck_id: string
    deck_description?: string | null
  }

  export type UserCardCreateManyUserInput = {
    user_card_id: string
    question: string
    answer: string
    example?: string | null
    lesson_id?: number | null
  }

  export type VocabularyInboxCreateManyUserInput = {
    question: string
    answer: string
  }

  export type UserRoleUpdateWithoutUserInput = {
    role?: RoleUpdateOneRequiredWithoutUser_rolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    role_id?: StringFieldUpdateOperationsInput | string
  }

  export type UserApplicationPreferencesUpdateWithoutUserInput = {
    accepted_privacy_policy?: BoolFieldUpdateOperationsInput | boolean
    accepted_cookies_policy?: BoolFieldUpdateOperationsInput | boolean
    application?: ApplicationUpdateOneRequiredWithoutUser_application_preferencesNestedInput
  }

  export type UserApplicationPreferencesUncheckedUpdateWithoutUserInput = {
    application_id?: StringFieldUpdateOperationsInput | string
    accepted_privacy_policy?: BoolFieldUpdateOperationsInput | boolean
    accepted_cookies_policy?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserApplicationPreferencesUncheckedUpdateManyWithoutUserInput = {
    application_id?: StringFieldUpdateOperationsInput | string
    accepted_privacy_policy?: BoolFieldUpdateOperationsInput | boolean
    accepted_cookies_policy?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorUpdateWithoutUserInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    mentor_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    mentor_classes?: MentorsClassesUpdateManyWithoutMentorNestedInput
    MentorPayModel?: MentorPayModelUpdateManyWithoutMentorNestedInput
  }

  export type MentorUncheckedUpdateWithoutUserInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    mentor_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    mentor_classes?: MentorsClassesUncheckedUpdateManyWithoutMentorNestedInput
    MentorPayModel?: MentorPayModelUncheckedUpdateManyWithoutMentorNestedInput
  }

  export type MentorUncheckedUpdateManyWithoutUserInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    mentor_description_en?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentUpdateWithoutUserInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    student_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassUpdateOneRequiredWithoutStudentsNestedInput
    student_task?: StudentTaskUpdateManyWithoutStudentNestedInput
    student_answers?: StudentAnswerUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    student_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class_id?: StringFieldUpdateOperationsInput | string
    student_task?: StudentTaskUncheckedUpdateManyWithoutStudentNestedInput
    student_answers?: StudentAnswerUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutUserInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    student_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class_id?: StringFieldUpdateOperationsInput | string
  }

  export type DataRemovalRequestUpdateWithoutUserInput = {
    data_removal_request?: StringFieldUpdateOperationsInput | string
    data_removal_status?: EnumDataRemovalStatusEnumFieldUpdateOperationsInput | $Enums.DataRemovalStatusEnum
    data_removal_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRemovalRequestUncheckedUpdateWithoutUserInput = {
    data_removal_request_id?: IntFieldUpdateOperationsInput | number
    data_removal_request?: StringFieldUpdateOperationsInput | string
    data_removal_status?: EnumDataRemovalStatusEnumFieldUpdateOperationsInput | $Enums.DataRemovalStatusEnum
    data_removal_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataRemovalRequestUncheckedUpdateManyWithoutUserInput = {
    data_removal_request_id?: IntFieldUpdateOperationsInput | number
    data_removal_request?: StringFieldUpdateOperationsInput | string
    data_removal_status?: EnumDataRemovalStatusEnumFieldUpdateOperationsInput | $Enums.DataRemovalStatusEnum
    data_removal_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeckUpdateWithoutUserInput = {
    deck_id?: StringFieldUpdateOperationsInput | string
    deck_description?: NullableStringFieldUpdateOperationsInput | string | null
    Card?: LessonCardUpdateManyWithoutDeckNestedInput
  }

  export type DeckUncheckedUpdateWithoutUserInput = {
    deck_id?: StringFieldUpdateOperationsInput | string
    deck_description?: NullableStringFieldUpdateOperationsInput | string | null
    Card?: LessonCardUncheckedUpdateManyWithoutDeckNestedInput
  }

  export type DeckUncheckedUpdateManyWithoutUserInput = {
    deck_id?: StringFieldUpdateOperationsInput | string
    deck_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCardUpdateWithoutUserInput = {
    user_card_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    lesson?: LessonUpdateOneWithoutUserCardNestedInput
  }

  export type UserCardUncheckedUpdateWithoutUserInput = {
    user_card_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCardUncheckedUpdateManyWithoutUserInput = {
    user_card_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VocabularyInboxUpdateWithoutUserInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type VocabularyInboxUncheckedUpdateWithoutUserInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type VocabularyInboxUncheckedUpdateManyWithoutUserInput = {
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateManyRoleInput = {
    user_email: string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    user?: UserUpdateOneRequiredWithoutUser_rolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    user_email?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    user_email?: StringFieldUpdateOperationsInput | string
  }

  export type UserApplicationPreferencesCreateManyApplicationInput = {
    user_email: string
    accepted_privacy_policy: boolean
    accepted_cookies_policy: boolean
  }

  export type UserApplicationPreferencesUpdateWithoutApplicationInput = {
    accepted_privacy_policy?: BoolFieldUpdateOperationsInput | boolean
    accepted_cookies_policy?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutUser_application_preferencesNestedInput
  }

  export type UserApplicationPreferencesUncheckedUpdateWithoutApplicationInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    accepted_privacy_policy?: BoolFieldUpdateOperationsInput | boolean
    accepted_cookies_policy?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserApplicationPreferencesUncheckedUpdateManyWithoutApplicationInput = {
    user_email?: StringFieldUpdateOperationsInput | string
    accepted_privacy_policy?: BoolFieldUpdateOperationsInput | boolean
    accepted_cookies_policy?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassCallCreateManyMeeting_kindInput = {
    class_call_id: string
    class_id: string
    call_date: Date | string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
  }

  export type ClassCallUpdateWithoutMeeting_kindInput = {
    class_call_id?: StringFieldUpdateOperationsInput | string
    call_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassUpdateOneRequiredWithoutClass_callsNestedInput
  }

  export type ClassCallUncheckedUpdateWithoutMeeting_kindInput = {
    class_call_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    call_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassCallUncheckedUpdateManyWithoutMeeting_kindInput = {
    class_call_id?: StringFieldUpdateOperationsInput | string
    class_id?: StringFieldUpdateOperationsInput | string
    call_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorsClassesCreateManyClassInput = {
    mentor_id: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
  }

  export type StudentCreateManyClassInput = {
    student_id: string
    user_id: string
    student_nickname?: string | null
    enrolled_date?: Date | string | null
    left_date?: Date | string | null
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
  }

  export type BookingRequestCreateManyClassInput = {
    booking_request_id: string
    booking_date: Date | string
    booking_request_status?: $Enums.BookingRequestStatus
    user_stated_name?: string | null
    user_stated_phone?: string | null
    user_stated_email?: string | null
    user_stated_telegram_nickname?: string | null
  }

  export type ClassCallCreateManyClassInput = {
    class_call_id: string
    call_date: Date | string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    meeting_kind_id: string
  }

  export type ClassTaskCreateManyClassInput = {
    class_task_id?: number
    course_task_id: string
  }

  export type MentorsClassesUpdateWithoutClassInput = {
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    mentor?: MentorUpdateOneRequiredWithoutMentor_classesNestedInput
  }

  export type MentorsClassesUncheckedUpdateWithoutClassInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorsClassesUncheckedUpdateManyWithoutClassInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentUpdateWithoutClassInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    student_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutIs_student_ofNestedInput
    student_task?: StudentTaskUpdateManyWithoutStudentNestedInput
    student_answers?: StudentAnswerUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutClassInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    student_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    student_task?: StudentTaskUncheckedUpdateManyWithoutStudentNestedInput
    student_answers?: StudentAnswerUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutClassInput = {
    student_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    student_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    enrolled_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    left_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingRequestUpdateWithoutClassInput = {
    booking_request_id?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_request_status?: EnumBookingRequestStatusFieldUpdateOperationsInput | $Enums.BookingRequestStatus
    user_stated_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_phone?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_telegram_nickname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingRequestUncheckedUpdateWithoutClassInput = {
    booking_request_id?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_request_status?: EnumBookingRequestStatusFieldUpdateOperationsInput | $Enums.BookingRequestStatus
    user_stated_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_phone?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_telegram_nickname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingRequestUncheckedUpdateManyWithoutClassInput = {
    booking_request_id?: StringFieldUpdateOperationsInput | string
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_request_status?: EnumBookingRequestStatusFieldUpdateOperationsInput | $Enums.BookingRequestStatus
    user_stated_name?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_phone?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_stated_telegram_nickname?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassCallUpdateWithoutClassInput = {
    class_call_id?: StringFieldUpdateOperationsInput | string
    call_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    meeting_kind?: MeetingKindUpdateOneRequiredWithoutClass_callsNestedInput
  }

  export type ClassCallUncheckedUpdateWithoutClassInput = {
    class_call_id?: StringFieldUpdateOperationsInput | string
    call_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    meeting_kind_id?: StringFieldUpdateOperationsInput | string
  }

  export type ClassCallUncheckedUpdateManyWithoutClassInput = {
    class_call_id?: StringFieldUpdateOperationsInput | string
    call_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    meeting_kind_id?: StringFieldUpdateOperationsInput | string
  }

  export type ClassTaskUpdateWithoutClassInput = {
    course_task?: CourseTaskUpdateOneRequiredWithoutClassTaskNestedInput
    student_tasks?: StudentTaskUpdateManyWithoutClass_taskNestedInput
    student_answer?: StudentAnswerUpdateManyWithoutClass_taskNestedInput
  }

  export type ClassTaskUncheckedUpdateWithoutClassInput = {
    class_task_id?: IntFieldUpdateOperationsInput | number
    course_task_id?: StringFieldUpdateOperationsInput | string
    student_tasks?: StudentTaskUncheckedUpdateManyWithoutClass_taskNestedInput
    student_answer?: StudentAnswerUncheckedUpdateManyWithoutClass_taskNestedInput
  }

  export type ClassTaskUncheckedUpdateManyWithoutClassInput = {
    class_task_id?: IntFieldUpdateOperationsInput | number
    course_task_id?: StringFieldUpdateOperationsInput | string
  }

  export type ClassCreateManyClass_size_idInput = {
    class_id: string
    class_code?: string | null
    course_id: string
    start_date: Date | string
    end_date?: Date | string | null
    tuition_lang_code: string
    time_of_day_id: string
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
  }

  export type MentorPayModelCreateManyClass_sizeInput = {
    mentor_id: string
    start_date: Date | string
    pay_rate_per_hour: number
    created_date?: Date | string | null
    end_date?: Date | string | null
    deleted?: boolean
  }

  export type ClassUpdateWithoutClass_size_idInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    is_instance_of_course?: CourseUpdateOneRequiredWithoutClassesNestedInput
    time_of_day?: TimeOfDayUpdateOneRequiredWithoutClassesNestedInput
    tuition_lang?: TuitionLangUpdateOneRequiredWithoutClassesNestedInput
    mentor_classes?: MentorsClassesUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutClass_size_idInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    course_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    mentor_classes?: MentorsClassesUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUncheckedUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUncheckedUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutClass_size_idInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    course_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorPayModelUpdateWithoutClass_sizeInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pay_rate_per_hour?: FloatFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    mentor?: MentorUpdateOneRequiredWithoutMentorPayModelNestedInput
  }

  export type MentorPayModelUncheckedUpdateWithoutClass_sizeInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pay_rate_per_hour?: FloatFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorPayModelUncheckedUpdateManyWithoutClass_sizeInput = {
    mentor_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pay_rate_per_hour?: FloatFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseAdviceCreateManyCourseInput = {
    advice_id: string
    advice_text?: string | null
    last_used_date?: string | null
    created_date: string
  }

  export type ClassCreateManyIs_instance_of_courseInput = {
    class_id: string
    class_code?: string | null
    start_date: Date | string
    end_date?: Date | string | null
    tuition_lang_code: string
    time_of_day_id: string
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    classSizeClass_size_id: string
  }

  export type CourseStructureCreateManyCourseInput = {
    module_id: number
    section_id: number
    lesson_id: number
  }

  export type CourseTaskCreateManyCourseInput = {
    course_task_id: string
    module_id: number
    section_id: number
    lesson_id: number
    task_id: number
    question: string
  }

  export type ModuleCreateManyCourseInput = {
    module_id?: number
    module_name: string
    module_description?: string | null
    module_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
  }

  export type LessonCardCreateManyCourseInput = {
    card_id: string
    deck_id: string
    question: string
    answer: string
    example?: string | null
    lesson_id: number
  }

  export type CourseAdviceUpdateWithoutCourseInput = {
    advice_id?: StringFieldUpdateOperationsInput | string
    advice_text?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: StringFieldUpdateOperationsInput | string
  }

  export type CourseAdviceUncheckedUpdateWithoutCourseInput = {
    advice_id?: StringFieldUpdateOperationsInput | string
    advice_text?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: StringFieldUpdateOperationsInput | string
  }

  export type CourseAdviceUncheckedUpdateManyWithoutCourseInput = {
    advice_id?: StringFieldUpdateOperationsInput | string
    advice_text?: NullableStringFieldUpdateOperationsInput | string | null
    last_used_date?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: StringFieldUpdateOperationsInput | string
  }

  export type ClassUpdateWithoutIs_instance_of_courseInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class_size_id?: ClassSizeUpdateOneRequiredWithoutClassesNestedInput
    time_of_day?: TimeOfDayUpdateOneRequiredWithoutClassesNestedInput
    tuition_lang?: TuitionLangUpdateOneRequiredWithoutClassesNestedInput
    mentor_classes?: MentorsClassesUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutIs_instance_of_courseInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    classSizeClass_size_id?: StringFieldUpdateOperationsInput | string
    mentor_classes?: MentorsClassesUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUncheckedUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUncheckedUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutIs_instance_of_courseInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    classSizeClass_size_id?: StringFieldUpdateOperationsInput | string
  }

  export type CourseStructureUpdateWithoutCourseInput = {
    module?: ModuleUpdateOneRequiredWithoutCourseStructureNestedInput
    section?: SectionUpdateOneRequiredWithoutCourseStructureNestedInput
    lesson?: LessonUpdateOneRequiredWithoutCourseStructureNestedInput
  }

  export type CourseStructureUncheckedUpdateWithoutCourseInput = {
    module_id?: IntFieldUpdateOperationsInput | number
    section_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
  }

  export type CourseStructureUncheckedUpdateManyWithoutCourseInput = {
    module_id?: IntFieldUpdateOperationsInput | number
    section_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
  }

  export type CourseTaskUpdateWithoutCourseInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    module?: ModuleUpdateOneRequiredWithoutCourseTaskNestedInput
    section?: SectionUpdateOneRequiredWithoutCourseTaskNestedInput
    lesson?: LessonUpdateOneRequiredWithoutCourseTaskNestedInput
    task?: TaskUpdateOneRequiredWithoutCourseTaskNestedInput
    ClassTask?: ClassTaskUpdateManyWithoutCourse_taskNestedInput
  }

  export type CourseTaskUncheckedUpdateWithoutCourseInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    module_id?: IntFieldUpdateOperationsInput | number
    section_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    ClassTask?: ClassTaskUncheckedUpdateManyWithoutCourse_taskNestedInput
  }

  export type CourseTaskUncheckedUpdateManyWithoutCourseInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    module_id?: IntFieldUpdateOperationsInput | number
    section_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
  }

  export type ModuleUpdateWithoutCourseInput = {
    module_name?: StringFieldUpdateOperationsInput | string
    module_description?: NullableStringFieldUpdateOperationsInput | string | null
    module_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    sections?: SectionUpdateManyWithoutModuleNestedInput
    lessons?: LessonUpdateManyWithoutModuleNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutModuleNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutCourseInput = {
    module_id?: IntFieldUpdateOperationsInput | number
    module_name?: StringFieldUpdateOperationsInput | string
    module_description?: NullableStringFieldUpdateOperationsInput | string | null
    module_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    sections?: SectionUncheckedUpdateManyWithoutModuleNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutModuleNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutModuleNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutCourseInput = {
    module_id?: IntFieldUpdateOperationsInput | number
    module_name?: StringFieldUpdateOperationsInput | string
    module_description?: NullableStringFieldUpdateOperationsInput | string | null
    module_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LessonCardUpdateWithoutCourseInput = {
    card_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    deck?: DeckUpdateOneRequiredWithoutCardNestedInput
    lesson?: LessonUpdateOneRequiredWithoutLessonCardNestedInput
  }

  export type LessonCardUncheckedUpdateWithoutCourseInput = {
    card_id?: StringFieldUpdateOperationsInput | string
    deck_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_id?: IntFieldUpdateOperationsInput | number
  }

  export type LessonCardUncheckedUpdateManyWithoutCourseInput = {
    card_id?: StringFieldUpdateOperationsInput | string
    deck_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_id?: IntFieldUpdateOperationsInput | number
  }

  export type ClassTaskCreateManyCourse_taskInput = {
    class_task_id?: number
    class_id: string
  }

  export type ClassTaskUpdateWithoutCourse_taskInput = {
    class?: ClassUpdateOneRequiredWithoutClassTaskNestedInput
    student_tasks?: StudentTaskUpdateManyWithoutClass_taskNestedInput
    student_answer?: StudentAnswerUpdateManyWithoutClass_taskNestedInput
  }

  export type ClassTaskUncheckedUpdateWithoutCourse_taskInput = {
    class_task_id?: IntFieldUpdateOperationsInput | number
    class_id?: StringFieldUpdateOperationsInput | string
    student_tasks?: StudentTaskUncheckedUpdateManyWithoutClass_taskNestedInput
    student_answer?: StudentAnswerUncheckedUpdateManyWithoutClass_taskNestedInput
  }

  export type ClassTaskUncheckedUpdateManyWithoutCourse_taskInput = {
    class_task_id?: IntFieldUpdateOperationsInput | number
    class_id?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCreateManyCourse_levelInput = {
    course_code: string
    course_name?: string | null
    created_date?: Date | string | null
    subject_code: string
  }

  export type CourseLevelsPerSubjectCreateManyCourse_levelInput = {
    subject_code: string
  }

  export type CourseUpdateWithoutCourse_levelInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_advice?: CourseAdviceUpdateManyWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutIs_instance_of_courseNestedInput
    subject?: SubjectUpdateOneWithoutCourseNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutCourseNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutCourseNestedInput
    Module?: ModuleUpdateManyWithoutCourseNestedInput
    LessonCard?: LessonCardUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCourse_levelInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject_code?: StringFieldUpdateOperationsInput | string
    course_advice?: CourseAdviceUncheckedUpdateManyWithoutCourseNestedInput
    classes?: ClassUncheckedUpdateManyWithoutIs_instance_of_courseNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutCourseNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutCourseNestedInput
    Module?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    LessonCard?: LessonCardUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutCourse_levelInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subject_code?: StringFieldUpdateOperationsInput | string
  }

  export type CourseLevelsPerSubjectUpdateWithoutCourse_levelInput = {
    subject?: SubjectUpdateOneRequiredWithoutCourseLevelsPerSubjectNestedInput
  }

  export type CourseLevelsPerSubjectUncheckedUpdateWithoutCourse_levelInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
  }

  export type CourseLevelsPerSubjectUncheckedUpdateManyWithoutCourse_levelInput = {
    subject_code?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCreateManySubjectInput = {
    course_code: string
    course_name?: string | null
    course_level_id: string
    created_date?: Date | string | null
  }

  export type CourseLevelsPerSubjectCreateManySubjectInput = {
    course_level_id: string
  }

  export type CourseUpdateWithoutSubjectInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_level?: CourseLevelUpdateOneRequiredWithoutCourseNestedInput
    course_advice?: CourseAdviceUpdateManyWithoutCourseNestedInput
    classes?: ClassUpdateManyWithoutIs_instance_of_courseNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutCourseNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutCourseNestedInput
    Module?: ModuleUpdateManyWithoutCourseNestedInput
    LessonCard?: LessonCardUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutSubjectInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    course_level_id?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_advice?: CourseAdviceUncheckedUpdateManyWithoutCourseNestedInput
    classes?: ClassUncheckedUpdateManyWithoutIs_instance_of_courseNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutCourseNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutCourseNestedInput
    Module?: ModuleUncheckedUpdateManyWithoutCourseNestedInput
    LessonCard?: LessonCardUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutSubjectInput = {
    course_code?: StringFieldUpdateOperationsInput | string
    course_name?: NullableStringFieldUpdateOperationsInput | string | null
    course_level_id?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseLevelsPerSubjectUpdateWithoutSubjectInput = {
    course_level?: CourseLevelUpdateOneRequiredWithoutCourseLevelsPerSubjectNestedInput
  }

  export type CourseLevelsPerSubjectUncheckedUpdateWithoutSubjectInput = {
    course_level_id?: StringFieldUpdateOperationsInput | string
  }

  export type CourseLevelsPerSubjectUncheckedUpdateManyWithoutSubjectInput = {
    course_level_id?: StringFieldUpdateOperationsInput | string
  }

  export type TaskCreateManyLessonInput = {
    task_id?: number
    task_description?: string | null
    task_text?: string | null
    task_type_id: number
    task_context_id: string
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    gap_map?: string | null
  }

  export type CourseStructureCreateManyLessonInput = {
    course_id: string
    module_id: number
    section_id: number
  }

  export type CourseTaskCreateManyLessonInput = {
    course_task_id: string
    course_id: string
    module_id: number
    section_id: number
    task_id: number
    question: string
  }

  export type LessonCardCreateManyLessonInput = {
    card_id: string
    deck_id: string
    question: string
    answer: string
    example?: string | null
    course_code: string
  }

  export type UserCardCreateManyLessonInput = {
    user_card_id: string
    user_id: string
    question: string
    answer: string
    example?: string | null
  }

  export type TaskUpdateWithoutLessonInput = {
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
    task_type?: TaskTypeUpdateOneRequiredWithoutTaskNestedInput
    task_context?: TaskContextUpdateOneRequiredWithoutTaskNestedInput
    task_forms?: TaskFormUpdateManyWithoutTaskNestedInput
    task_options?: TaskOptionUpdateManyWithoutTaskNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutLessonInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_type_id?: IntFieldUpdateOperationsInput | number
    task_context_id?: StringFieldUpdateOperationsInput | string
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
    task_forms?: TaskFormUncheckedUpdateManyWithoutTaskNestedInput
    task_options?: TaskOptionUncheckedUpdateManyWithoutTaskNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutLessonInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_type_id?: IntFieldUpdateOperationsInput | number
    task_context_id?: StringFieldUpdateOperationsInput | string
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseStructureUpdateWithoutLessonInput = {
    course?: CourseUpdateOneRequiredWithoutCourseStructureNestedInput
    module?: ModuleUpdateOneRequiredWithoutCourseStructureNestedInput
    section?: SectionUpdateOneRequiredWithoutCourseStructureNestedInput
  }

  export type CourseStructureUncheckedUpdateWithoutLessonInput = {
    course_id?: StringFieldUpdateOperationsInput | string
    module_id?: IntFieldUpdateOperationsInput | number
    section_id?: IntFieldUpdateOperationsInput | number
  }

  export type CourseStructureUncheckedUpdateManyWithoutLessonInput = {
    course_id?: StringFieldUpdateOperationsInput | string
    module_id?: IntFieldUpdateOperationsInput | number
    section_id?: IntFieldUpdateOperationsInput | number
  }

  export type CourseTaskUpdateWithoutLessonInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutCourseTaskNestedInput
    module?: ModuleUpdateOneRequiredWithoutCourseTaskNestedInput
    section?: SectionUpdateOneRequiredWithoutCourseTaskNestedInput
    task?: TaskUpdateOneRequiredWithoutCourseTaskNestedInput
    ClassTask?: ClassTaskUpdateManyWithoutCourse_taskNestedInput
  }

  export type CourseTaskUncheckedUpdateWithoutLessonInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    module_id?: IntFieldUpdateOperationsInput | number
    section_id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    ClassTask?: ClassTaskUncheckedUpdateManyWithoutCourse_taskNestedInput
  }

  export type CourseTaskUncheckedUpdateManyWithoutLessonInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    module_id?: IntFieldUpdateOperationsInput | number
    section_id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
  }

  export type LessonCardUpdateWithoutLessonInput = {
    card_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    deck?: DeckUpdateOneRequiredWithoutCardNestedInput
    course?: CourseUpdateOneRequiredWithoutLessonCardNestedInput
  }

  export type LessonCardUncheckedUpdateWithoutLessonInput = {
    card_id?: StringFieldUpdateOperationsInput | string
    deck_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    course_code?: StringFieldUpdateOperationsInput | string
  }

  export type LessonCardUncheckedUpdateManyWithoutLessonInput = {
    card_id?: StringFieldUpdateOperationsInput | string
    deck_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    course_code?: StringFieldUpdateOperationsInput | string
  }

  export type UserCardUpdateWithoutLessonInput = {
    user_card_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutUserCardNestedInput
  }

  export type UserCardUncheckedUpdateWithoutLessonInput = {
    user_card_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCardUncheckedUpdateManyWithoutLessonInput = {
    user_card_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentorsClassesCreateManyMentorInput = {
    class_id: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
  }

  export type MentorPayModelCreateManyMentorInput = {
    class_size_id: string
    start_date: Date | string
    pay_rate_per_hour: number
    created_date?: Date | string | null
    end_date?: Date | string | null
    deleted?: boolean
  }

  export type MentorsClassesUpdateWithoutMentorInput = {
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassUpdateOneRequiredWithoutMentor_classesNestedInput
  }

  export type MentorsClassesUncheckedUpdateWithoutMentorInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorsClassesUncheckedUpdateManyWithoutMentorInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorPayModelUpdateWithoutMentorInput = {
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pay_rate_per_hour?: FloatFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class_size?: ClassSizeUpdateOneRequiredWithoutMentorPayModelNestedInput
  }

  export type MentorPayModelUncheckedUpdateWithoutMentorInput = {
    class_size_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pay_rate_per_hour?: FloatFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentorPayModelUncheckedUpdateManyWithoutMentorInput = {
    class_size_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    pay_rate_per_hour?: FloatFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SectionCreateManyModuleInput = {
    section_id?: number
    section_name: string
    section_description?: string | null
    section_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
  }

  export type LessonCreateManyModuleInput = {
    lesson_id?: number
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    section_id: number
  }

  export type CourseStructureCreateManyModuleInput = {
    course_id: string
    section_id: number
    lesson_id: number
  }

  export type CourseTaskCreateManyModuleInput = {
    course_task_id: string
    course_id: string
    section_id: number
    lesson_id: number
    task_id: number
    question: string
  }

  export type SectionUpdateWithoutModuleInput = {
    section_name?: StringFieldUpdateOperationsInput | string
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    section_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    CourseStructure?: CourseStructureUpdateManyWithoutSectionNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutSectionNestedInput
    Lesson?: LessonUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateWithoutModuleInput = {
    section_id?: IntFieldUpdateOperationsInput | number
    section_name?: StringFieldUpdateOperationsInput | string
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    section_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutSectionNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutSectionNestedInput
    Lesson?: LessonUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type SectionUncheckedUpdateManyWithoutModuleInput = {
    section_id?: IntFieldUpdateOperationsInput | number
    section_name?: StringFieldUpdateOperationsInput | string
    section_description?: NullableStringFieldUpdateOperationsInput | string | null
    section_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LessonUpdateWithoutModuleInput = {
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    section?: SectionUpdateOneRequiredWithoutLessonNestedInput
    tasks?: TaskUpdateManyWithoutLessonNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutLessonNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutLessonNestedInput
    LessonCard?: LessonCardUpdateManyWithoutLessonNestedInput
    UserCard?: UserCardUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutModuleInput = {
    lesson_id?: IntFieldUpdateOperationsInput | number
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    section_id?: IntFieldUpdateOperationsInput | number
    tasks?: TaskUncheckedUpdateManyWithoutLessonNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutLessonNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutLessonNestedInput
    LessonCard?: LessonCardUncheckedUpdateManyWithoutLessonNestedInput
    UserCard?: UserCardUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutModuleInput = {
    lesson_id?: IntFieldUpdateOperationsInput | number
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    section_id?: IntFieldUpdateOperationsInput | number
  }

  export type CourseStructureUpdateWithoutModuleInput = {
    course?: CourseUpdateOneRequiredWithoutCourseStructureNestedInput
    section?: SectionUpdateOneRequiredWithoutCourseStructureNestedInput
    lesson?: LessonUpdateOneRequiredWithoutCourseStructureNestedInput
  }

  export type CourseStructureUncheckedUpdateWithoutModuleInput = {
    course_id?: StringFieldUpdateOperationsInput | string
    section_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
  }

  export type CourseStructureUncheckedUpdateManyWithoutModuleInput = {
    course_id?: StringFieldUpdateOperationsInput | string
    section_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
  }

  export type CourseTaskUpdateWithoutModuleInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutCourseTaskNestedInput
    section?: SectionUpdateOneRequiredWithoutCourseTaskNestedInput
    lesson?: LessonUpdateOneRequiredWithoutCourseTaskNestedInput
    task?: TaskUpdateOneRequiredWithoutCourseTaskNestedInput
    ClassTask?: ClassTaskUpdateManyWithoutCourse_taskNestedInput
  }

  export type CourseTaskUncheckedUpdateWithoutModuleInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    section_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    ClassTask?: ClassTaskUncheckedUpdateManyWithoutCourse_taskNestedInput
  }

  export type CourseTaskUncheckedUpdateManyWithoutModuleInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    section_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
  }

  export type CourseStructureCreateManySectionInput = {
    course_id: string
    module_id: number
    lesson_id: number
  }

  export type CourseTaskCreateManySectionInput = {
    course_task_id: string
    course_id: string
    module_id: number
    lesson_id: number
    task_id: number
    question: string
  }

  export type LessonCreateManySectionInput = {
    lesson_id?: number
    lesson_name: string
    lesson_description?: string | null
    lesson_order: number
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    moduleModule_id?: number | null
  }

  export type CourseStructureUpdateWithoutSectionInput = {
    course?: CourseUpdateOneRequiredWithoutCourseStructureNestedInput
    module?: ModuleUpdateOneRequiredWithoutCourseStructureNestedInput
    lesson?: LessonUpdateOneRequiredWithoutCourseStructureNestedInput
  }

  export type CourseStructureUncheckedUpdateWithoutSectionInput = {
    course_id?: StringFieldUpdateOperationsInput | string
    module_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
  }

  export type CourseStructureUncheckedUpdateManyWithoutSectionInput = {
    course_id?: StringFieldUpdateOperationsInput | string
    module_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
  }

  export type CourseTaskUpdateWithoutSectionInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutCourseTaskNestedInput
    module?: ModuleUpdateOneRequiredWithoutCourseTaskNestedInput
    lesson?: LessonUpdateOneRequiredWithoutCourseTaskNestedInput
    task?: TaskUpdateOneRequiredWithoutCourseTaskNestedInput
    ClassTask?: ClassTaskUpdateManyWithoutCourse_taskNestedInput
  }

  export type CourseTaskUncheckedUpdateWithoutSectionInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    module_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    ClassTask?: ClassTaskUncheckedUpdateManyWithoutCourse_taskNestedInput
  }

  export type CourseTaskUncheckedUpdateManyWithoutSectionInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    module_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    task_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
  }

  export type LessonUpdateWithoutSectionInput = {
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    tasks?: TaskUpdateManyWithoutLessonNestedInput
    CourseStructure?: CourseStructureUpdateManyWithoutLessonNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutLessonNestedInput
    Module?: ModuleUpdateOneWithoutLessonsNestedInput
    LessonCard?: LessonCardUpdateManyWithoutLessonNestedInput
    UserCard?: UserCardUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutSectionInput = {
    lesson_id?: IntFieldUpdateOperationsInput | number
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    moduleModule_id?: NullableIntFieldUpdateOperationsInput | number | null
    tasks?: TaskUncheckedUpdateManyWithoutLessonNestedInput
    CourseStructure?: CourseStructureUncheckedUpdateManyWithoutLessonNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutLessonNestedInput
    LessonCard?: LessonCardUncheckedUpdateManyWithoutLessonNestedInput
    UserCard?: UserCardUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutSectionInput = {
    lesson_id?: IntFieldUpdateOperationsInput | number
    lesson_name?: StringFieldUpdateOperationsInput | string
    lesson_description?: NullableStringFieldUpdateOperationsInput | string | null
    lesson_order?: IntFieldUpdateOperationsInput | number
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    moduleModule_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClassCreateManyTime_of_dayInput = {
    class_id: string
    class_code?: string | null
    course_id: string
    start_date: Date | string
    end_date?: Date | string | null
    tuition_lang_code: string
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    classSizeClass_size_id: string
  }

  export type ClassUpdateWithoutTime_of_dayInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class_size_id?: ClassSizeUpdateOneRequiredWithoutClassesNestedInput
    is_instance_of_course?: CourseUpdateOneRequiredWithoutClassesNestedInput
    tuition_lang?: TuitionLangUpdateOneRequiredWithoutClassesNestedInput
    mentor_classes?: MentorsClassesUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutTime_of_dayInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    course_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    classSizeClass_size_id?: StringFieldUpdateOperationsInput | string
    mentor_classes?: MentorsClassesUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUncheckedUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUncheckedUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutTime_of_dayInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    course_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tuition_lang_code?: StringFieldUpdateOperationsInput | string
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    classSizeClass_size_id?: StringFieldUpdateOperationsInput | string
  }

  export type ClassCreateManyTuition_langInput = {
    class_id: string
    class_code?: string | null
    course_id: string
    start_date: Date | string
    end_date?: Date | string | null
    time_of_day_id: string
    start_time_gmt3: string
    created_date?: Date | string | null
    updated_date?: Date | string | null
    deleted?: boolean
    classSizeClass_size_id: string
  }

  export type ClassUpdateWithoutTuition_langInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    class_size_id?: ClassSizeUpdateOneRequiredWithoutClassesNestedInput
    is_instance_of_course?: CourseUpdateOneRequiredWithoutClassesNestedInput
    time_of_day?: TimeOfDayUpdateOneRequiredWithoutClassesNestedInput
    mentor_classes?: MentorsClassesUpdateManyWithoutClassNestedInput
    students?: StudentUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutTuition_langInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    course_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    classSizeClass_size_id?: StringFieldUpdateOperationsInput | string
    mentor_classes?: MentorsClassesUncheckedUpdateManyWithoutClassNestedInput
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    booking_requests?: BookingRequestUncheckedUpdateManyWithoutClassNestedInput
    class_calls?: ClassCallUncheckedUpdateManyWithoutClassNestedInput
    ClassTask?: ClassTaskUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutTuition_langInput = {
    class_id?: StringFieldUpdateOperationsInput | string
    class_code?: NullableStringFieldUpdateOperationsInput | string | null
    course_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_of_day_id?: StringFieldUpdateOperationsInput | string
    start_time_gmt3?: StringFieldUpdateOperationsInput | string
    created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    classSizeClass_size_id?: StringFieldUpdateOperationsInput | string
  }

  export type LessonCardCreateManyDeckInput = {
    card_id: string
    question: string
    answer: string
    example?: string | null
    course_code: string
    lesson_id: number
  }

  export type LessonCardUpdateWithoutDeckInput = {
    card_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneRequiredWithoutLessonCardNestedInput
    lesson?: LessonUpdateOneRequiredWithoutLessonCardNestedInput
  }

  export type LessonCardUncheckedUpdateWithoutDeckInput = {
    card_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    course_code?: StringFieldUpdateOperationsInput | string
    lesson_id?: IntFieldUpdateOperationsInput | number
  }

  export type LessonCardUncheckedUpdateManyWithoutDeckInput = {
    card_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    example?: NullableStringFieldUpdateOperationsInput | string | null
    course_code?: StringFieldUpdateOperationsInput | string
    lesson_id?: IntFieldUpdateOperationsInput | number
  }

  export type StudentTaskCreateManyClass_taskInput = {
    student_task_id?: number
    student_id: string
    task_status: $Enums.StudentTaskStatus
  }

  export type StudentAnswerCreateManyClass_taskInput = {
    student_answer_id?: number
    student_id: string
    answer: string
  }

  export type StudentTaskUpdateWithoutClass_taskInput = {
    task_status?: EnumStudentTaskStatusFieldUpdateOperationsInput | $Enums.StudentTaskStatus
    student?: StudentUpdateOneRequiredWithoutStudent_taskNestedInput
  }

  export type StudentTaskUncheckedUpdateWithoutClass_taskInput = {
    student_task_id?: IntFieldUpdateOperationsInput | number
    student_id?: StringFieldUpdateOperationsInput | string
    task_status?: EnumStudentTaskStatusFieldUpdateOperationsInput | $Enums.StudentTaskStatus
  }

  export type StudentTaskUncheckedUpdateManyWithoutClass_taskInput = {
    student_task_id?: IntFieldUpdateOperationsInput | number
    student_id?: StringFieldUpdateOperationsInput | string
    task_status?: EnumStudentTaskStatusFieldUpdateOperationsInput | $Enums.StudentTaskStatus
  }

  export type StudentAnswerUpdateWithoutClass_taskInput = {
    answer?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutStudent_answersNestedInput
  }

  export type StudentAnswerUncheckedUpdateWithoutClass_taskInput = {
    student_answer_id?: IntFieldUpdateOperationsInput | number
    student_id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type StudentAnswerUncheckedUpdateManyWithoutClass_taskInput = {
    student_answer_id?: IntFieldUpdateOperationsInput | number
    student_id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTaskCreateManyStudentInput = {
    student_task_id?: number
    class_task_id: number
    task_status: $Enums.StudentTaskStatus
  }

  export type StudentAnswerCreateManyStudentInput = {
    student_answer_id?: number
    class_task_id: number
    answer: string
  }

  export type StudentTaskUpdateWithoutStudentInput = {
    task_status?: EnumStudentTaskStatusFieldUpdateOperationsInput | $Enums.StudentTaskStatus
    class_task?: ClassTaskUpdateOneRequiredWithoutStudent_tasksNestedInput
  }

  export type StudentTaskUncheckedUpdateWithoutStudentInput = {
    student_task_id?: IntFieldUpdateOperationsInput | number
    class_task_id?: IntFieldUpdateOperationsInput | number
    task_status?: EnumStudentTaskStatusFieldUpdateOperationsInput | $Enums.StudentTaskStatus
  }

  export type StudentTaskUncheckedUpdateManyWithoutStudentInput = {
    student_task_id?: IntFieldUpdateOperationsInput | number
    class_task_id?: IntFieldUpdateOperationsInput | number
    task_status?: EnumStudentTaskStatusFieldUpdateOperationsInput | $Enums.StudentTaskStatus
  }

  export type StudentAnswerUpdateWithoutStudentInput = {
    answer?: StringFieldUpdateOperationsInput | string
    class_task?: ClassTaskUpdateOneRequiredWithoutStudent_answerNestedInput
  }

  export type StudentAnswerUncheckedUpdateWithoutStudentInput = {
    student_answer_id?: IntFieldUpdateOperationsInput | number
    class_task_id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type StudentAnswerUncheckedUpdateManyWithoutStudentInput = {
    student_answer_id?: IntFieldUpdateOperationsInput | number
    class_task_id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type TaskOptionCreateManyTaskInput = {
    task_option_id?: number
    task_option_text: string
    task_option_order?: number | null
    is_correct: boolean
  }

  export type CourseTaskCreateManyTaskInput = {
    course_task_id: string
    course_id: string
    module_id: number
    section_id: number
    lesson_id: number
    question: string
  }

  export type TaskFormUpdateWithoutTaskInput = {
    task_form_name?: StringFieldUpdateOperationsInput | string
    task_form_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskFormUncheckedUpdateWithoutTaskInput = {
    task_form_id?: IntFieldUpdateOperationsInput | number
    task_form_name?: StringFieldUpdateOperationsInput | string
    task_form_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskFormUncheckedUpdateManyWithoutTaskInput = {
    task_form_id?: IntFieldUpdateOperationsInput | number
    task_form_name?: StringFieldUpdateOperationsInput | string
    task_form_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskOptionUpdateWithoutTaskInput = {
    task_option_text?: StringFieldUpdateOperationsInput | string
    task_option_order?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskOptionUncheckedUpdateWithoutTaskInput = {
    task_option_id?: IntFieldUpdateOperationsInput | number
    task_option_text?: StringFieldUpdateOperationsInput | string
    task_option_order?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskOptionUncheckedUpdateManyWithoutTaskInput = {
    task_option_id?: IntFieldUpdateOperationsInput | number
    task_option_text?: StringFieldUpdateOperationsInput | string
    task_option_order?: NullableIntFieldUpdateOperationsInput | number | null
    is_correct?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseTaskUpdateWithoutTaskInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutCourseTaskNestedInput
    module?: ModuleUpdateOneRequiredWithoutCourseTaskNestedInput
    section?: SectionUpdateOneRequiredWithoutCourseTaskNestedInput
    lesson?: LessonUpdateOneRequiredWithoutCourseTaskNestedInput
    ClassTask?: ClassTaskUpdateManyWithoutCourse_taskNestedInput
  }

  export type CourseTaskUncheckedUpdateWithoutTaskInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    module_id?: IntFieldUpdateOperationsInput | number
    section_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    ClassTask?: ClassTaskUncheckedUpdateManyWithoutCourse_taskNestedInput
  }

  export type CourseTaskUncheckedUpdateManyWithoutTaskInput = {
    course_task_id?: StringFieldUpdateOperationsInput | string
    course_id?: StringFieldUpdateOperationsInput | string
    module_id?: IntFieldUpdateOperationsInput | number
    section_id?: IntFieldUpdateOperationsInput | number
    lesson_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
  }

  export type TaskUpdateWithoutTask_formsInput = {
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
    task_type?: TaskTypeUpdateOneRequiredWithoutTaskNestedInput
    task_context?: TaskContextUpdateOneRequiredWithoutTaskNestedInput
    lesson?: LessonUpdateOneRequiredWithoutTasksNestedInput
    task_options?: TaskOptionUpdateManyWithoutTaskNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTask_formsInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_type_id?: IntFieldUpdateOperationsInput | number
    task_context_id?: StringFieldUpdateOperationsInput | string
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    lesson_id?: IntFieldUpdateOperationsInput | number
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
    task_options?: TaskOptionUncheckedUpdateManyWithoutTaskNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutTask_formsInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_type_id?: IntFieldUpdateOperationsInput | number
    task_context_id?: StringFieldUpdateOperationsInput | string
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    lesson_id?: IntFieldUpdateOperationsInput | number
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateManyTask_contextInput = {
    task_id?: number
    task_description?: string | null
    task_text?: string | null
    task_type_id: number
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    lesson_id: number
    gap_map?: string | null
  }

  export type TaskUpdateWithoutTask_contextInput = {
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
    task_type?: TaskTypeUpdateOneRequiredWithoutTaskNestedInput
    lesson?: LessonUpdateOneRequiredWithoutTasksNestedInput
    task_forms?: TaskFormUpdateManyWithoutTaskNestedInput
    task_options?: TaskOptionUpdateManyWithoutTaskNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTask_contextInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_type_id?: IntFieldUpdateOperationsInput | number
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    lesson_id?: IntFieldUpdateOperationsInput | number
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
    task_forms?: TaskFormUncheckedUpdateManyWithoutTaskNestedInput
    task_options?: TaskOptionUncheckedUpdateManyWithoutTaskNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutTask_contextInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_type_id?: IntFieldUpdateOperationsInput | number
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    lesson_id?: IntFieldUpdateOperationsInput | number
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateManyTask_typeInput = {
    task_id?: number
    task_description?: string | null
    task_text?: string | null
    task_context_id: string
    task_form_id?: number | null
    task_created_date?: Date | string | null
    task_updated_date?: Date | string | null
    deleted?: boolean
    lesson_id: number
    gap_map?: string | null
  }

  export type TaskUpdateWithoutTask_typeInput = {
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
    task_context?: TaskContextUpdateOneRequiredWithoutTaskNestedInput
    lesson?: LessonUpdateOneRequiredWithoutTasksNestedInput
    task_forms?: TaskFormUpdateManyWithoutTaskNestedInput
    task_options?: TaskOptionUpdateManyWithoutTaskNestedInput
    CourseTask?: CourseTaskUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTask_typeInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_context_id?: StringFieldUpdateOperationsInput | string
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    lesson_id?: IntFieldUpdateOperationsInput | number
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
    task_forms?: TaskFormUncheckedUpdateManyWithoutTaskNestedInput
    task_options?: TaskOptionUncheckedUpdateManyWithoutTaskNestedInput
    CourseTask?: CourseTaskUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutTask_typeInput = {
    task_id?: IntFieldUpdateOperationsInput | number
    task_description?: NullableStringFieldUpdateOperationsInput | string | null
    task_text?: NullableStringFieldUpdateOperationsInput | string | null
    task_context_id?: StringFieldUpdateOperationsInput | string
    task_form_id?: NullableIntFieldUpdateOperationsInput | number | null
    task_created_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    task_updated_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted?: BoolFieldUpdateOperationsInput | boolean
    lesson_id?: IntFieldUpdateOperationsInput | number
    gap_map?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleCountOutputTypeDefaultArgs instead
     */
    export type RoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApplicationCountOutputTypeDefaultArgs instead
     */
    export type ApplicationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApplicationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MeetingKindCountOutputTypeDefaultArgs instead
     */
    export type MeetingKindCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MeetingKindCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassCountOutputTypeDefaultArgs instead
     */
    export type ClassCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassSizeCountOutputTypeDefaultArgs instead
     */
    export type ClassSizeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassSizeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseCountOutputTypeDefaultArgs instead
     */
    export type CourseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseTaskCountOutputTypeDefaultArgs instead
     */
    export type CourseTaskCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseTaskCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseLevelCountOutputTypeDefaultArgs instead
     */
    export type CourseLevelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseLevelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubjectCountOutputTypeDefaultArgs instead
     */
    export type SubjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LessonCountOutputTypeDefaultArgs instead
     */
    export type LessonCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LessonCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MentorCountOutputTypeDefaultArgs instead
     */
    export type MentorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MentorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuleCountOutputTypeDefaultArgs instead
     */
    export type ModuleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SectionCountOutputTypeDefaultArgs instead
     */
    export type SectionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SectionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimeOfDayCountOutputTypeDefaultArgs instead
     */
    export type TimeOfDayCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimeOfDayCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TuitionLangCountOutputTypeDefaultArgs instead
     */
    export type TuitionLangCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TuitionLangCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeckCountOutputTypeDefaultArgs instead
     */
    export type DeckCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeckCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassTaskCountOutputTypeDefaultArgs instead
     */
    export type ClassTaskCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassTaskCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentCountOutputTypeDefaultArgs instead
     */
    export type StudentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskCountOutputTypeDefaultArgs instead
     */
    export type TaskCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskFormCountOutputTypeDefaultArgs instead
     */
    export type TaskFormCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskFormCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskContextCountOutputTypeDefaultArgs instead
     */
    export type TaskContextCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskContextCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskTypeCountOutputTypeDefaultArgs instead
     */
    export type TaskTypeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskTypeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoleDefaultArgs instead
     */
    export type RoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleDefaultArgs instead
     */
    export type UserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserApplicationPreferencesDefaultArgs instead
     */
    export type UserApplicationPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserApplicationPreferencesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApplicationDefaultArgs instead
     */
    export type ApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DataRemovalRequestDefaultArgs instead
     */
    export type DataRemovalRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DataRemovalRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MeetingKindDefaultArgs instead
     */
    export type MeetingKindArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MeetingKindDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseStructureDefaultArgs instead
     */
    export type CourseStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseStructureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassDefaultArgs instead
     */
    export type ClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassCallDefaultArgs instead
     */
    export type ClassCallArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassCallDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassSizeDefaultArgs instead
     */
    export type ClassSizeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassSizeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseDefaultArgs instead
     */
    export type CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseAdviceDefaultArgs instead
     */
    export type CourseAdviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseAdviceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseTaskDefaultArgs instead
     */
    export type CourseTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseTaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseLevelDefaultArgs instead
     */
    export type CourseLevelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseLevelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubjectDefaultArgs instead
     */
    export type SubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseLevelsPerSubjectDefaultArgs instead
     */
    export type CourseLevelsPerSubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseLevelsPerSubjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LessonDefaultArgs instead
     */
    export type LessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LessonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MentorDefaultArgs instead
     */
    export type MentorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MentorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MentorsClassesDefaultArgs instead
     */
    export type MentorsClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MentorsClassesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MentorPayModelDefaultArgs instead
     */
    export type MentorPayModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MentorPayModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuleDefaultArgs instead
     */
    export type ModuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SectionDefaultArgs instead
     */
    export type SectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimeOfDayDefaultArgs instead
     */
    export type TimeOfDayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimeOfDayDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TuitionLangDefaultArgs instead
     */
    export type TuitionLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TuitionLangDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeckDefaultArgs instead
     */
    export type DeckArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeckDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LessonCardDefaultArgs instead
     */
    export type LessonCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LessonCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCardDefaultArgs instead
     */
    export type UserCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VocabularyDefaultArgs instead
     */
    export type VocabularyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VocabularyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VocabularyInboxDefaultArgs instead
     */
    export type VocabularyInboxArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VocabularyInboxDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingRequestDefaultArgs instead
     */
    export type BookingRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassTaskDefaultArgs instead
     */
    export type ClassTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassTaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentDefaultArgs instead
     */
    export type StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentAnswerDefaultArgs instead
     */
    export type StudentAnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentAnswerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentTaskDefaultArgs instead
     */
    export type StudentTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentTaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskDefaultArgs instead
     */
    export type TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskFormDefaultArgs instead
     */
    export type TaskFormArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskFormDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskContextDefaultArgs instead
     */
    export type TaskContextArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskContextDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskOptionDefaultArgs instead
     */
    export type TaskOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskOptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TaskTypeDefaultArgs instead
     */
    export type TaskTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TaskTypeDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}